/*




    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ”€  â–ˆâ–ˆâ–ˆâ–ˆâ”€     â–ˆâ–ˆâ–ˆâ–ˆâ”€ â–ˆâ–ˆâ–ˆâ–ˆâ”€    â–ˆâ–ˆâ–ˆâ”€â”€
    â–ˆâ”€     â–ˆâ”€  â–ˆ  â–ˆ   â–ˆâ”€    â–ˆ  â–ˆ  â–ˆ   â–ˆ   â–ˆâ”€  â–ˆ
    â–ˆ      â–ˆ   â–ˆ  â–ˆâ”€  â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€  â–ˆ   â–ˆ
    â–ˆ      â–ˆ   â–ˆ  â–ˆ   â–ˆ     â–ˆâ”€â”€   â–ˆâ”€â”€ â–ˆ   â–ˆ   â–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€  â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€    â–ˆ     â–ˆ   â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ


    v7.0.0 â€” Mar 2024

    By Fadexz




    Features:
    â–ˆ Anti-Recoil (compensates recoil while also able to use rumble/vibration to increase the amount on shots)
    â–ˆ Slowdown Aim Assist Abuse (automatically moves your ads (in small circle) while you are not moving to allow for slowing down when moving towards a target which will favour to their direction)
    â–ˆ Reload Cancel (automatically cancel reload on press of 'ADS' and/or 'FIRE')
    â–ˆ Auto Reload (automatically reload after shooting)
    â–ˆ Jump Shot (jump when pressing 'ADS' and/or 'FIRE')
    â–ˆ Rapid Fire (turbo/spam 'FIRE' for non-auto weapons automatically on hold)
    â–ˆ Auto Focus (automatically focuses (hold breath) while ADS)
    â–ˆ Auto Ping (ping when firing, on a specified time of no firing cooldown)
    â–ˆ Snap On Aim Assist Abuse (for ZM/SP aka PvE modes, don't use on PvP modes)
    â–ˆ Quick Scoper (instantly unscopes and removes shot recoil to make quick scoping feel nicer, requires a throwing knife)
    â–ˆ Turbo Jump (spam on hold)
    â–ˆ Turbo Melee (spam on hold)
    â–ˆ Auto Sprint (has press, toggle, and hold options) + Boosted Auto Sprint Mode (exploit for Black Ops Cold War) (these also make the walk area larger by making the sprint area a little tighter than in-game Auto Sprint, requires auto sprint in-game disabled and preferably use hold mode to allow the script to stop the sprinting)
    â–ˆ Slide Cancel (Quickly cancels your slide midway and stands immediately)
    â–ˆ Pickup Cancel (Cancels out the animation of picking up a weapon to almost instantly start being able to use it)
    â–ˆ Swap Cancel (Cancels out the animation of swapping a weapon as soon as the weapon has been swapped, best when both weapons have similar swap times)
    â–ˆ Dropshot (automatically drops to prone when firing then immediately stands afterwards)
    â–ˆ Crouch Shot (automatically crouches when firing)
    â–ˆ "YY" Cancel (fun feature, cancel the swap animation constantly to jitter the animation for a visual effect, may cause delayed ads)
    â–ˆ Hair Triggers (removed trigger deadzone â€” any press is 100% input)
    â–ˆ Humanise Inputs (randomise values and limit turbo features to keep closer to human limitations)
    â–ˆ Display Config (configure what displays on the OLED Screen and how it does, such as screensaver options)
    â–ˆ LED Config (customise how the Zen's LED displays)
    â–ˆ Block Vibration (stop vibration to the controller but allow rumble-based features to still work)
    â–ˆ Inactivity Timeout (allows for you to turn off your controller or other stuff when inactive)
    â–ˆ Fast Power Off (quickly power off your controller with a shorter hold of the XBOX/PS button than usual, for wireless connection only)
    â–ˆ Adaptive Triggers Config (gives control over what the DualSense Adaptive Triggers do)
    â–ˆ No Rumble Fix (fix no vibration on the DualSense controller)
    â–ˆ Crossover Mapping (proper mapping for unmatching controllers and consoles)
    â–ˆ Game Input Layout Customisation (map the script to your game button layout)
    â–ˆ All other features with combos (or automated input sequences) have the "Input Interval" and "Dynamic VM Timing" to ensure you get faster combos with no added "input delay" (aka normally running at 100hz or 10ms intervals, currently always ensures a 125hz/8ms or 250hz/4ms polling rate regardless of input interval used)



    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€
    â–ˆâ–ˆâ–ˆ Menu â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Enter Menu              >  Fully Hold 'ADS' & Press 'MENU' (Default: LT/L2 & MENU/OPTIONS)     â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Enter Next Menu         >  Press A/CROSS (edit menu - on an adjustable selection)              â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€â”€
    â–ˆ  Exit Current Menu       >  Press B/CIRCLE (saves values to memory when exiting the main menu)  â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Exit Menu               >  Press 'MENU' (Default: MENU/OPTIONS) (won't save to memory)         â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Change Selected Option  >  Press LEFT (previous) or Press RIGHT (next)                         â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Change Selected Value   >  Press UP (increase) or Press DOWN (decrease)                        â–ˆâ”€
    â–ˆ                                                                                                 â–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆ Quick Toggles (outside menu) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Toggle Rapid Fire       >  Hold 'SCOREBOARD' & Press 'STREAK' (Default: VIEW/TOUCH & RIGHT)    â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Disable Turbo features  >  Hold 'UNUSED' (Default: DOWN) (active while holding)                â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ



    Congrats, you now know the basics to get started, have fun! ðŸ˜œ



    â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”



    In-Depth Notes:
    â–ˆ [ Pickup Cancel ]
    â–ˆ With this feature on you may have issues with hold interacting on things, you should not use this feature in modes
    â–ˆ that you need to hold to interact in or if you intend on using them while you play (e.g bomb defuser)
    â–ˆ
    â–ˆ [ Swap Cancel ]
    â–ˆ This feature won't benefit weapons that are brought out faster than cancelling the animation would be
	â–ˆ For this feature, I recommend both weapons being around the same time to swap to as you will need to use a speed
	â–ˆ for the slowest one
    â–ˆ
    â–ˆ [ LED Brightness ]
    â–ˆ I suggest you lower the brightness level of "Dual Shock 4 Light Bar Brightness" in the Device tab of Zen Studio so
    â–ˆ you don't have to be blind by the Zen's LED (I use 25%), otherwise you can change it further through the menu just
    â–ˆ for this script
    â–ˆ
    â–ˆ [ Defaults ]
    â–ˆ The features selected below under this large comment are what will be enabled or disabled by default, you can
	â–ˆ change them there if you wish, otherwise you can change them later through the menu on the Zen's Screen which
	â–ˆ will be saved to the memory for later use
    â–ˆ
    â–ˆ [ > 60fps ]
    â–ˆ Mainly if on PC and you understand this then be sure to adjust in the menu (under 'Hair Triggers') to whatever
	â–ˆ your max frametime is plus one (e.g (1000ms/100fps) = 10ms, rounded up to even), your frame time or frame rate
	â–ˆ should not drop past this number ever or 99% of the time, mainly intended to be changed for higher framerates
	â–ˆ for faster completion of automated input sequences, just keep in mind you should expect it to be a little lower
	â–ˆ than your average down to the worse performance for 1% of the time
    â–ˆ Important: If you experience missed inputs from combos (automated inputs) you should increase this number until
	â–ˆ it stops missing them (like keeping it at 20ms)
    â–ˆ
    â–ˆ [ Cold War ]
    â–ˆ Boosted Auto Sprint is ~3.5% faster than normal sprinting, however I haven't tested in normal gameplay if it still
    â–ˆ has as much of a worthy benefit or if it can be better (might be more of an annoyance than useful)



    Donate:
    â–ˆ Feel free to support me for the thousands of hours I put into making this script the best as possible to my
    â–ˆ ability, for those that do it does help motivate me to keep making and put more work into the scripts,
    â–ˆ and be able to expand into making more unique scripts in the future, plus it just makes my day ðŸ˜Š
	â–ˆ https://revolut.me/Fadexz
	â–ˆ https://www.buymeacoffee.com/Fadexz (note: sent internationally)
	â–ˆ https://paypal.me/Fadexz

																																																																																																																																																																													*/																																						int __WARNINGS__ARE__INTENDED__do_not_sell_my_sht__developed_by_fadexz__
																																																																																																																																																																																																																																																																																																																																																																						=																																																																																								 CPU_USAGE																																																																																																																															+																																																																																																																															 1;																																																																/*																																																																																	
    Additonal Notes:
    â–ˆ Please ignore any compiler warnings, they are intended
    â–ˆ This script will eventually come to a "complete" state with time, so expect slow but constant updates ðŸ˜Ž
    â–ˆ Please report any issues or suggestions to me, I rarely get any but it would help me improve
    â–ˆ the script with things I couldn't think of!
    â–ˆ View code changes on GitHub at https://github.com/Fadexz/GPC-Scripts/blob/main/COD%20Pro/COD%20Pro.gpc



    Contact me:
    â–ˆ https://discord.com/users/291872132898619392 (fadexz)
    â–ˆ https://forums.cronusmax.com/members/fadexz.356349



    Additional Credits:
    â–ˆ Batts              >  Base value displaying functionality
    â–ˆ DoNotAtMe ("Me.")  >  "Slowdown" Aim Assist Abuse
    â–ˆ Swizzy             >  Bit-packed SPVAR saving
    â–ˆ Taylordrift21      >  Rumble-based Anti-Recoil



    To Do (for me):
    â–ˆ Dropshot - Stand on release of ADS option
    â–ˆ Vibration + LED menu only options FX Toggle
    â–ˆ Auto Sprint for Sprint Cancels Reload
    â–ˆ Ez Equipment Cancel??
    â–ˆ Block all output in menu option
    â–ˆ Ez Cook Frag (Tap & Tap To Release) + Suicide Prevention (Throw | Swap)
    â–ˆ Stance Detection
    â–ˆ Polar AA disable on fire option
    â–ˆ Akimbo Sync + Akimbo Rapid Fire
    â–ˆ Burst Fire (modify rapid fire??)
    â–ˆ Anti-AFK Kick
    â–ˆ Strafe AA
    â–ˆ Mod record time mode
    â–ˆ Button swap
    â–ˆ Diamond and Star Shape "Aim Assist Abuse"
    â–ˆ Display battery level (+ other info)
    â–ˆ Mouse & Keyboard Menu Support
    â–ˆ Loadouts/Profiles - Weapon Pickup Mode
    â–ˆ Bouncing Title Text (and more screensavers)
    â–ˆ
    â–ˆ Issues:
    â–ˆ Fix slide cancel to allow dolpine dive (in MWIII)
    â–ˆ Fix for 10ms polling - Actual Controller Polling Rate Detection
    â–ˆ Fix brightness on battery status breathing level change



*/

// -- Declear constants

define

// -- Note: Please ignore
Signed_2_Bit_Min  = -1 << 1,
Signed_3_Bit_Min  = -1 << 2,
Signed_4_Bit_Min  = -1 << 3,
Signed_5_Bit_Min  = -1 << 4,
Signed_6_Bit_Min  = -1 << 5,
Signed_7_Bit_Min  = -1 << 6,
Signed_8_Bit_Min  = -1 << 7,
Signed_9_Bit_Min  = -1 << 8,
Signed_10_Bit_Min = -1 << 9,
Signed_11_Bit_Min = -1 << 10,
Signed_12_Bit_Min = -1 << 11,
Signed_13_Bit_Min = -1 << 12,
Signed_14_Bit_Min = -1 << 13,
Signed_15_Bit_Min = -1 << 14,
Signed_16_Bit_Min = -1 << 15,
Signed_17_Bit_Min = -1 << 16,
Signed_18_Bit_Min = -1 << 17,
Signed_19_Bit_Min = -1 << 18,
Signed_20_Bit_Min = -1 << 19,
Signed_21_Bit_Min = -1 << 20,
Signed_22_Bit_Min = -1 << 21,
Signed_23_Bit_Min = -1 << 22,
Signed_24_Bit_Min = -1 << 23,
Signed_25_Bit_Min = -1 << 24,
Signed_26_Bit_Min = -1 << 25,
Signed_27_Bit_Min = -1 << 26,
Signed_28_Bit_Min = -1 << 27,
Signed_29_Bit_Min = -1 << 28,
Signed_30_Bit_Min = -1 << 29,
Signed_31_Bit_Min = -1 << 30,
Signed_32_Bit_Min = -1 << 31,
Signed_2_Bit_Max  = (1 << 1) - 1,
Signed_3_Bit_Max  = (1 << 2) - 1,
Signed_4_Bit_Max  = (1 << 3) - 1,
Signed_5_Bit_Max  = (1 << 4) - 1,
Signed_6_Bit_Max  = (1 << 5) - 1,
Signed_7_Bit_Max  = (1 << 6) - 1,
Signed_8_Bit_Max  = (1 << 7) - 1,
Signed_9_Bit_Max  = (1 << 8) - 1,
Signed_10_Bit_Max = (1 << 9) - 1,
Signed_11_Bit_Max = (1 << 10) - 1,
Signed_12_Bit_Max = (1 << 11) - 1,
Signed_13_Bit_Max = (1 << 12) - 1,
Signed_14_Bit_Max = (1 << 13) - 1,
Signed_15_Bit_Max = (1 << 14) - 1,
Signed_16_Bit_Max = (1 << 15) - 1,
Signed_17_Bit_Max = (1 << 16) - 1,
Signed_18_Bit_Max = (1 << 17) - 1,
Signed_19_Bit_Max = (1 << 18) - 1,
Signed_20_Bit_Max = (1 << 19) - 1,
Signed_21_Bit_Max = (1 << 20) - 1,
Signed_22_Bit_Max = (1 << 21) - 1,
Signed_23_Bit_Max = (1 << 22) - 1,
Signed_24_Bit_Max = (1 << 23) - 1,
Signed_25_Bit_Max = (1 << 24) - 1,
Signed_26_Bit_Max = (1 << 25) - 1,
Signed_27_Bit_Max = (1 << 26) - 1,
Signed_28_Bit_Max = (1 << 27) - 1,
Signed_29_Bit_Max = (1 << 28) - 1,
Signed_30_Bit_Max = (1 << 29) - 1,
Signed_31_Bit_Max = (1 << 30) - 1,
Signed_32_Bit_Max = (1 << 31) - 1,

// -- Button toggle index constants (ignore)
BTI_LB = 0,
BTI_RB = 1,
BTI_LT = 2,
BTI_RT = 3,
BTI_LS = 4,
BTI_RS = 5,
BTI_UP = 6,
BTI_DOWN = 7,
BTI_LEFT = 8,
BTI_RIGHT = 9,
BTI_A = 10,
BTI_B = 11,
BTI_X = 12,
BTI_Y = 13,

// -- You can change any of the default values below IF you wish the script to start with these values before saving

// Anti-Recoil
AR_Vert_Value = 28,
AR_Hori_Value = 0,
AR_Deadzone = 13,
AR_Rumble_Influence = FALSE,
AR_Reduced_Rumble = TRUE,
AR_Boost_Time = 160,
// Polar Aim Assist Slowdown Abuse
// -- [ 0 = ADS & Fire | 1 = ADS or Fire | 2 = ADS | 3 = Fire | 4 = None ]
AA_Activation_Type = 1,
// -- Circle Radius ('strength')
AA_Radius = 22,
// -- Circle Speed (amount of angles/values skipped through each "vm interval")
AA_Rotate_By_Angles = 20,
AA_Release_Point = 13,
// Reload Cancel
// -- [ 0 = On Fire | 1 = On ADS or Fire ]
RC_Release_Activation_Type = 0,
// -- Feel free to set this to ~6000ms for even LMGs, but can't guarantee it won't cause issues with shorter reloads (at most, should be a quick YY before ADS or shooting)
RC_Max_Reload_Time_For_Cancel = 3500,
// Auto Reload
// -- [ 0 = On Release Fire | 1 = On Release Fire or ADS ]
AR2_Release_Activation_Type = 1,
AR2_Shoot_Time = 1,
// Turbo Jump
TJ_Jump_Wait_Time = 1,
// Rapid Fire
// -- [ 0 = Tap | 1 = Hold (prime shot) ]
RF_Shot_Type = 1,
// -- [ 0 = On Fire | 1 = On ADS & Fire ]
RF_Activation_Type = 0,
RF_Shot_Wait_Time = 1,
RF_Single_Shot_Time = 100,
// Auto Focus
// -- [ 0 = Hold | 1 = Quick Gasp ]
AF_Type = 1,
// Fully ADS Check
// -- Some weapons can be up to ~450ms
FAC_ADS_Time = 349,
// LED Config
LC_Delay_Interval = 190,
LC_Brightness = 90,
LC_FX_Brightness = 100,
LC_Menu_Brightness = 70,
LC_Saturation = 100,
// Aim Assist Snap On Abuse
AASO_ADS_Hold_Time = 1490,
// Auto Sprint
// -- [ 0 = Turbo (Press Mode) | 1 = Hold (Hold Mode) | 2 = Press (Toggle/Press Mode) | 3 = BOCW Boosted (Press/Toggle Mode) ]
AS_Type = 0,
// -- Time to disable Auto Sprint after pressing 'STANCE_SLIDE_DIVE' button
AS_Crouch_Prone_Delay_Time = 0,
// Jump Shot
// -- [ 0 = On Press (ADS) | 1 = On Hold (ADS) | 2 = Panic (ADS & Fire) ]
JS_Activation_Type = 2,
// -- Max time between ADS and FIRE presses to activate
JS_Press_Variance_Time = 24,
// Auto Ping
// -- Minimum time (seconds) of not firing for Auto Ping to activate
AP_Min_Release_Activation_Time = 18,
// -- [ 0 = Fully ADS | 1 = Holding ADS | 2 = Ignore ADS ]
AP_Activation_Type = 1,
AP_Unping_On_Release = FALSE,
// Quick Scoper
// -- [ 0 = Fire | 1 = ADS & Lethal ]
QS_Activation_Type = 0,
// Slide Cancel
// -- [ 0 = Legacy | 1 = Stand | 2 = 'Jump' (MWIII) | 3 = MWII ]
SC_Type = 2,
SC_Cancel_Delay_Time = 350,
// Swap Cancel
SC2_Cancel_Delay_Time = 650,
// Dropshot
// -- [ 0 = On Fire | 1 = Panic (ADS & Fire) ]
DS_Activation_Type = 1,
// -- Max time between ADS and FIRE presses to activate
DS_Press_Variance_Time = 120,
DS_Stand_On_Release = TRUE,
// -- [ 0 = Sprint (Fast) | 1 = Stand ]
DS_Stand_Type = 0,
// Crouch Shot
// -- [ 0 = On ADS | 1 = On Fire | 2 = On ADS & Fire ]
CS_Activation_Type = 0,
CS_Loop = FALSE,
CS_Delay_Time = 200,
CS_Once_Release_Stand = TRUE,
// YY Cancel
// -- Delay until ready to cancel again (should be longer than the "Cancel Delay")
YY_Wait_Delay = 100,
// -- Delay between YY inputs
YY_Cancel_Delay = 1,
// Humanise Inputs
// -- [ 0 = Off | 1 = ADS Only | 2 = All ]
HI_Randomise_Values = 2,
HI_Limit_Turbos = TRUE,
// Display
// -- [ OLED_FONT_SMALL (0) | OLED_FONT_MEDIUM (1) | OLED_FONT_LARGE (2) ]
DP_Menu_Font_Size = OLED_FONT_MEDIUM,
// -- Scroll transition speed (apex = slowest - for longer text | base = fastest - for short text)
DP_Forward_Scroll_Apex_Time = 1700,
DP_Forward_Scroll_Base_Time = 120,
DP_Backward_Scroll_Apex_Time = 72,
DP_Backward_Scroll_Base_Time = 8,
DP_Start_Pause_Time = 880,
DP_End_Pause_Time = 700,
// -- [ 0 = None | 1 = Dimmed Editable Highlight | 2 = Enterable Highlight ]
DP_Menu_Border = 1,
// -- [ 0 = None (black) | 1 = Lasers | 2 = Raindrops | 3 = 3D Wave (Detached) ]
DP_Screensaver_Type = 1,
// LED Config
// -- [ 0 = Cycling Hue | 1 = Breathing | 2 = Static | 3 = Battery Status ]
LC_Type = 0,
// -- 0 = Red | 120 = Green | 240 = Blue
LC_Hue = 260,
// Inactivity Timeout
// -- [ 0 = Turn Off Controller | 1 = Unload Script | 2 = Turn Off Controller & Unload Script ]
IT_Turn_Off_Type = 0,
IT_Timeout_Time = 30,
// Fast Power Off
FPO_Required_Hold_Time = 2000,
// Adaptive Triggers (DualSense)
// -- [ 0 = Disabled | 1 = Pressure (CR) | 2 = Bow (SR) | 3 = Two Step (No Res 1) | 4 = Responsive (No Res 2) | 5 = Light Resistance (Has Res 1) | 6 = Frequency (Has Res 2) ] These modes will change how the various values are applied
AT_LT_Mode = 0,
AT_RT_Mode = 0,
AT_L2_Start = 0,
AT_R2_Start = 0,
AT_L2_Force_1 = 0,
AT_R2_Force_1 = 0,
AT_L2_Force_2 = 0,
AT_R2_Force_2 = 0,
AT_L2_Strength_Low = 0,
AT_R2_Strength_Low = 0,
AT_L2_Strength_Mid = 0,
AT_R2_Strength_Mid = 0,
AT_L2_Strength_High = 0,
AT_R2_Strength_High = 0,
AT_L2_Freq = 0,
AT_R2_Freq = 0,
AT_R2_Freq_Matches_Rapid_Fire = TRUE,

// Input Interval
// -- Setting this correctly (mostly for PC) will result in faster input of combos (setting this up incorrectly can cause
// -- missed inputs from the script)
// -- Input Wait Interval Calculation Examples: (1000ms Ã· 60fps) = 18ms (rounded up to even) | (1000/120) = 10ms (rounded
// -- up to even)
// -- If you don't want to calculate, simply use '36' for 29+fps, '18' for 57+fps, '12' for 85+fps, '10' for 101+fps, or
// -- '8' for 126+fps (ensure the game fps is *always* above this minimum fps listed for inputs to not be missed)
// -- Note: 1ms vm time shouldn't be used otherwise it'll add 1ms to the end of combos (last "action" will be 2ms long)
// -- which will slightly slow them down (if the combo only has "two actions" it will take longer 1+1+(1-1)=3, 0 wait time
// -- rounds to 1 which results in the last/second action being repeated twice as long, check combos to understand)
// -- If you wish to use 1ms intervals through the menu then change 'II_Min_Runtime_Interval_Step' above to '1', this will
// -- mean the device will update every 1ms on odd numbers and could be more unstable with higher CPU Usage but this is
// -- done to not add "input delay" as 1 is the only number that is divisible (of 1, 2, 4, or 8)
// -- I personally use '10' for this, I play with 144fps however it is not 100% stable (> 125fps or < 8ms always) so I
// -- just need above 100fps (aka < 10ms frame times) at all times
// -- Note: Changing this could mess up the initial value rounding to this interval
II_Input_Interval = 20,

// -- You can find extra settings here IF you need to change which are not in the menu

// Input Interval
// -- (ADVANCED!) [ 1ms | 2ms | 4ms ] Minimum allowed and step value used for input interval, changing this may in some cases affect CPU usage
II_Min_Runtime_Interval_Step = 2,
// Required Hold Time
// -- Minimum standard time that is counted as a hold in-game, for feature activations
HT_Min_Standard_Game_Hold_Time = 450,
HT_Min_Short_Game_Hold_Time = 150,
// Display
// -- Total entities on title screen (changes amount of variables used)
DP_Total_Screensaver_Entities = 10,
// -- Wouldn't recommend lower than '5000' (5 secs) and higher than '120000' (2 mins) to prevent screen burn-in
DP_Screen_Sleep_Time = 120000,
// -- < 1023ms or > 32767ms not recommended (Default: 16383 ((2^14)-1)), changing bit size will divide or multiply by 2
DP_Max_Large_Time_Based_Value = Signed_15_Bit_Max,
// -- < 511ms or > 16383ms not recommended (Default: 2047 ((2^11)-1)), changing bit size will divide or multiply by 2
DP_Max_Small_Time_Based_Value = Signed_12_Bit_Max,
// -- Vibration and LED effect activation time
DP_FX_Time = 100,
// -- (ADVANCED!) Should be the length of the longest value string to not overflow into variables after (i.e ' __ms (__._/sec ____/min) ' is 26 characters long)
DP_Longest_Length_For_ASCII_Array_Buffer = 26,

// Input Layout
// -- Note: When changing these make sure to keep them the same format (only Xbox One inputs)
// -- Inputs: LB, RB, LT, RT, LS, RS, UP, DOWN, LEFT, RIGHT, A, B, X, Y
TB_Tactical_Input = BTI_LB,
LB_Lethal_Input = BTI_RB,
AB_ADS_Input = BTI_LT,
FB_Fire_Input = BTI_RT,
SFB_Sprint_Focus_Input = BTI_LS,
MB_Melee_Input = BTI_RS,
PB_Ping_Input = BTI_UP,
SB_Streak_Input = BTI_RIGHT,
JMB_Jump_Mantle_Input = BTI_A,
SSDB_Stance_Slide_Dive_Input = BTI_B,
RIB_Reload_Interact_Input = BTI_X,
SAB_Swap_Armour_Input = BTI_Y,

// Game Button Layout
// -- Stick to Xbox One Button Identifiers (constants) for layout consistency and to not mess up the crossover support (some buttons are not actual equivalents in other layouts)
// -- You should mostly only change the stick axes here if needed
SCOREBOARD = XB1_VIEW,
MENU       = XB1_MENU,
MOVEX      = POLAR_LX,
MOVEY      = POLAR_LY,
LOOKX      = POLAR_RX,
LOOKY      = POLAR_RY,
UNUSED     = XB1_DOWN;  // -- Used for temporarily disabling turbo features (hold to disable them to allow holding of those buttons)



// -- Declear integer variables

int

// -- Adjustable Values
mods[_End_Mods_Plus_One_Idx_],
edit[_End_Edit_Plus_One_Idx_],

// Fully ADS Check
fac_ads_timer,

// Anti-Recoil
ar_smart_rumble,
ar_strength,
ar_boost_timer,

// Auto Reload
ar2_shoot_timer,

// Polar Aim Assist Abuse
aa_angle,
aa_cos_angle,
aa_sin_angle,
//aa_current_magnitude,
//aa_max_magnitude,

// Reload Cancel
rc_reloading,
rc_reloading_time,
rc_ar2_did_shoot_before_reload,

// Auto Sprint
as_sc_yyc_in_sprint_area,

// Slide Cancel
sc_stand_btn,

// Auto Ping
ap_can_unping,

// Dropshot
ds_did_dropshot,

// Crouch Shot
cs_crouched,

// YY Cancel
yyc_sprinting,

// Adaptive Triggers (DualSense)
at_adt_idx,

// LED Config
lc_adjusted_brightness = 100,
lc_hue,
lc_timer,
lc_range_count,

// Crossover Mapping Fix
cf_swap_xb1_share_sync,

// Button Mappings
input_layout[_End_Input_Layout_Plus_One_Idx_],
il_input_layout_idx,

// Input Interval
ii_max_controller_polling_rate = II_Min_Runtime_Interval_Step,
ii_vm_cycle_time,
ii_calc_timing,

// Display
dp_int_to_string_buffer[DP_Longest_Length_For_ASCII_Array_Buffer],
dp_title = TRUE,
dp_screen_sleep_timer,
dp_display_slot_only,
dp_splash_step,
dp_splash_timer,
dp_display_menu,
dp_menu,
dp_block_options,
dp_main_idx,
dp_mod_idx,
dp_mod_idx_step,
dp_edit_idx,
dp_edit_idx_step,
dp_val_str,
dp_digit_idx,
dp_digits_val,
dp_digit_count,
dp_string_len,
dp_blackout_random,
dp_shift,
dp_screensaver_incementer,
dp_entity_x_pos[DP_Total_Screensaver_Entities],
dp_entity_y_pos[DP_Total_Screensaver_Entities],
dp_entity_speed[DP_Total_Screensaver_Entities],
dp_entity_length[DP_Total_Screensaver_Entities],
dp_entity_cooldown_timer[DP_Total_Screensaver_Entities],
dp_entity_idx,
dp_snake_length_x = 32,  // -- Max: 32
dp_snake_length_y = 32,  // -- Max: 32
dp_snake_x,
dp_snake_y,
dp_snake_segment,
dp_snake_refresh_timer,
dp_rapid_fire_quick_toggle_timer,
dp_rapid_fire_quick_toggle_border_toggle,
dp_title_display_interval,
dp_input_interval_fps,
dp_input_interval_fps_digit_idx,
dp_round_edit_idx,
dp_selected_string_idx[2],
dp_scroll_timer[2],
dp_scroll_pause_time[2],
dp_text_offset[2],
dp_char_idx,
dp_reverse_offset[2],
dp_text_display_length,
dp_text_size_y_offset,
dp_text_size_width,
dp_string_idx,
dp_cur_array_idx,
dp_cur_string_idx,
dp_string_start_idx[2],
dp_string_length[2],
dp_scroll[2],
dp_is_value,

// Inactivity Timeout
it_inactivity_timeout_timer,

// Persistent Variables
pv_current_bit,
pv_current_slot,
pv_current_value,
pv_temp,
pv_bits,

// -- [DEBUG]
//highest_cpu_usage,

// -- Temp Variables (not to be used in functions)
_no_funct_layer_1_temp_,
_no_funct_layer_2_temp_;



// -- Initialise values

init {

  // -- If any SPVAR contains a value then load from Spvars
  // -- Note: FIRST TIME THE VARIABLE IS BEING USED - NOT RESETTING
  while(_no_funct_layer_1_temp_ < 64) {
    if(get_pvar(SPVAR_1 + _no_funct_layer_1_temp_,Signed_32_Bit_Min,Signed_32_Bit_Max,0)) {
      reset_spvar();
      // -- Load Mod Values (persistent memory)
      // -- Note: FIRST TIME THE VARIABLE IS BEING USED - NOT RESETTING
      while(_no_funct_layer_2_temp_ < _End_Mods_Plus_One_Idx_) {
        switch(_no_funct_layer_2_temp_) {
          // -- Unused, skip
          case DP_Display_Config_Toggle_Idx {}
          case IL_Input_Layout_Toggle_Idx {}
          case BMAC_Fadexz_Toggle_Idx {
            break;
          }
          case II_Input_Interval_Toggle_Idx {
            mods[II_Input_Interval_Toggle_Idx] = read_spvar(1,50);
            break;
          }
          case FAC_ADS_Time_Idx {
            mods[FAC_ADS_Time_Idx] = read_spvar(1,DP_Max_Small_Time_Based_Value);
            break;
          }
          default { mods[_no_funct_layer_2_temp_] = read_spvar(FALSE,TRUE); }
        }
        _no_funct_layer_2_temp_ ++;
      }
      // -- Load Edit Values (persistent memory)
      for(_no_funct_layer_2_temp_ = 0; _no_funct_layer_2_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_2_temp_ ++) {
        if(_no_funct_layer_2_temp_ != RC_Cancel_Method_Edit_Toggle_Idx)  // -- Unused for now, skip
          edit[_no_funct_layer_2_temp_] = read_spvar(Edit_Value_Range[_no_funct_layer_2_temp_][0],Edit_Value_Range[_no_funct_layer_2_temp_][1]);
      }
      dp_display_slot_only = TRUE;
      dp_splash_step = 4;
      dp_splash_timer = 0;
      // -- [DEBUG] Spvars used
      set_val(TRACE_4,((pv_current_slot - SPVAR_1) * 32) + pv_current_bit);  // -- Bits used (total: 2048)
      set_val(TRACE_5,(pv_current_slot - SPVAR_1) + (pv_current_bit > 0));  // -- Slots used (total: 64)
      set_val(TRACE_6,pv_current_bit);  // -- Last slot bits used (total: 32)
      break;
    }
    _no_funct_layer_1_temp_ ++;
  }
  // -- If it made it to the end (nothing saved / first load)
  if(_no_funct_layer_1_temp_ >= 64) {
    // -- ****************************************************************************************************************
    // -- *** Initial enabled mods (only uncomment these (remove '//') if you want these mods to be initially enabled) ***
    // -- ****************************************************************************************************************
    //mods[AR_Anti_Recoil_Toggle_Idx] = TRUE;
    //mods[AA_Polar_Aim_Assist_Abuse_Toggle_Idx] = TRUE;
    mods[RC_Reload_Cancel_Toggle_Idx] = TRUE;
    //mods[AR2_Auto_Reload_Toggle_Idx] = TRUE;
    //mods[JS_Jump_Shot_Toggle_Idx] = TRUE;
    //mods[RF_Rapid_Fire_Toggle_Idx] = TRUE;
    //mods[AF_Auto_Focus_Toggle_Idx] = TRUE;
    //mods[AP_Auto_Ping_Toggle_Idx] = TRUE;
    //mods[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx] = TRUE;
    //mods[QS_Quick_Scoper_Toggle_Idx] = TRUE;
    mods[TJ_Turbo_Jump_Toggle_Idx] = TRUE;
    mods[TM_Turbo_Melee_Toggle_Idx] = TRUE;
    //mods[AS_Auto_Sprint_Toggle_Idx] = TRUE;
    //mods[SC_Slide_Cancel_Toggle_Idx] = TRUE;
    //mods[PAC_Pickup_Cancel_Toggle_Idx] = TRUE;
    //mods[SC2_Swap_Cancel_Toggle_Idx] = TRUE;
    //mods[DS_Dropshot_Toggle_Idx] = TRUE;
    //mods[CS_Crouch_Shot_Toggle_Idx] = TRUE;
    //mods[YYC_YY_Cancel_Toggle_Idx] = TRUE;
    mods[HT_Hair_Triggers_Toggle_Idx] = TRUE;
    mods[FAC_ADS_Time_Idx] = 350;
    mods[HI_Humanise_Inputs_Toggle_Idx] = TRUE;
    mods[LC_LED_Config_Toggle_Idx] = TRUE;
    //mods[BR_Block_Rumble_Toggle_Idx] = TRUE;
    //mods[IT_Inactivity_Timeout_Toggle_Idx] = TRUE;
    //mods[FPO_Fast_Power_Off_Toggle_Idx] = TRUE;
    //mods[AT_Adaptive_Triggers_Toggle_Idx] = TRUE;
    //mods[DSRF_DualSense_Rumble_Fix_Toggle_Idx] = TRUE;
    mods[CF_Crossover_Fix_Toggle_Idx] = TRUE;
    mods[II_Input_Interval_Toggle_Idx] = 20;
    // -- Set initial edit values
    for(_no_funct_layer_2_temp_ = 0; _no_funct_layer_2_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_2_temp_ ++) {
      edit[_no_funct_layer_2_temp_] = Edit_Value_Range[_no_funct_layer_2_temp_][2];
    }
    dp_splash_step = 4;
    dp_splash_timer = 0;
  }

  dp_tsp = TRUE;
  // -- Update max polling rate for current controller
  update_max_polling_rate();
  // -- Get VM Interval Time for timing calculations
  ii_vm_cycle_time = greatest_common_divisor_vm_timing();
  // -- Set VM Interval Time
  vm_tctrl(ii_vm_cycle_time - 10);
  // -- Initialise values
  apply_button_layout();
  // -- Round initial time-based values
  round_time_based_values();
  // -- Turbos limit
  limit_turbos_value();
  // -- Start LED on output ('console') based hue
  lc_hue = LC_Console_Hue[get_console()];
  // -- Note: This is the mobile LED hue
  if((get_console() == PIO_PS5 || get_console() == PIO_PS4) && get_led(LED_1) == 2 && get_led(LED_2) == 22 && get_led(LED_3) == 8 && !get_led(LED_4))
    lc_hue = 30;  // -- Note: Old = 28
  // -- Set a initial values for the screensaver entities
  initialise_screensaver_entities();
  // Block Rumble (Vibration)
  if(mods[BR_Block_Rumble_Toggle_Idx]) {
    reset_rumble();
    block_rumble();
  }
  // Adaptive Triggers (DualSense)
  apply_adaptive_triggers();

  // -- Note: Use when fixed, for when blocking slot change input for Crossover Mapping Fix
  //get_ctrlbutton()

}

main {


  // Fast Power Off

  if(mods[FPO_Fast_Power_Off_Toggle_Idx])
    if(get_ival(XB1_XBOX) && get_ptime(XB1_XBOX) >= edit[FPO_Required_Hold_Time_Idx] && get_ptime(XB1_XBOX) < edit[FPO_Required_Hold_Time_Idx] + get_rtime())
      turn_off();


  // -- Adjust for PS4 Controller Max Polling Rate (4ms/250hz)
  // -- Note: Check if this can be removed (if it is impossible to connect a controller while the script is running)
  update_max_polling_rate();


  // DualSense No Rumble Fix

  if(mods[DSRF_DualSense_Rumble_Fix_Toggle_Idx]) {
    set_rumble(RUMBLE_A,get_rumble(RUMBLE_A));
    set_rumble(RUMBLE_B,get_rumble(RUMBLE_B));
  }


  // Adaptive Triggers (DualSense)

  // -- Note: Not done in function to help reduce CPU Load
  // -- Note: Hacky method to return input back to the game/host
  if(!mods[AT_Adaptive_Triggers_Toggle_Idx]) {
    set_adt(PS5_L2,PS5_ADT_MODE         ,get_adt(PS5_L2,PS5_ADT_MODE));
    set_adt(PS5_R2,PS5_ADT_MODE         ,get_adt(PS5_R2,PS5_ADT_MODE));
    set_adt(PS5_L2,PS5_ADT_START        ,get_adt(PS5_L2,PS5_ADT_START));
    set_adt(PS5_R2,PS5_ADT_START        ,get_adt(PS5_R2,PS5_ADT_START));
    set_adt(PS5_L2,PS5_ADT_FORCE1       ,get_adt(PS5_L2,PS5_ADT_FORCE1));
    set_adt(PS5_R2,PS5_ADT_FORCE1       ,get_adt(PS5_R2,PS5_ADT_FORCE1));
    set_adt(PS5_L2,PS5_ADT_FORCE2       ,get_adt(PS5_L2,PS5_ADT_FORCE2));
    set_adt(PS5_R2,PS5_ADT_FORCE2       ,get_adt(PS5_R2,PS5_ADT_FORCE2));
    set_adt(PS5_L2,PS5_ADT_STRENGTH_LOW ,get_adt(PS5_L2,PS5_ADT_STRENGTH_LOW));
    set_adt(PS5_R2,PS5_ADT_STRENGTH_LOW ,get_adt(PS5_R2,PS5_ADT_STRENGTH_LOW));
    set_adt(PS5_L2,PS5_ADT_STRENGTH_MID ,get_adt(PS5_L2,PS5_ADT_STRENGTH_MID));
    set_adt(PS5_R2,PS5_ADT_STRENGTH_MID ,get_adt(PS5_R2,PS5_ADT_STRENGTH_MID));
    set_adt(PS5_L2,PS5_ADT_STRENGTH_HIGH,get_adt(PS5_L2,PS5_ADT_STRENGTH_HIGH));
    set_adt(PS5_R2,PS5_ADT_STRENGTH_HIGH,get_adt(PS5_R2,PS5_ADT_STRENGTH_HIGH));
    set_adt(PS5_L2,PS5_ADT_FREQ         ,get_adt(PS5_L2,PS5_ADT_FREQ));
    set_adt(PS5_R2,PS5_ADT_FREQ         ,get_adt(PS5_R2,PS5_ADT_FREQ));
  }


  if(dp_splash_step) {
    dp_splash_timer -= get_rtime();
    if(dp_splash_timer <= 0) {
      switch(dp_splash_step) {
        case 4 {
          // -- Show current slot
          cls_oled(OLED_WHITE);
          putc_oled(1,0x53);
          putc_oled(2,0x6c);
          putc_oled(3,0x6f);
          putc_oled(4,0x74);
          putc_oled(5,0x20);
          putc_oled(6,0x30 + (get_slot() % 9));
          putc_oled(7,0x30);
          puts_oled(centre_text(6 + (get_slot() >= 10),OLED_FONT_MEDIUM_WIDTH),24,OLED_FONT_MEDIUM,6 + (get_slot() >= 10),OLED_BLACK);
          break;
        }
        case 3 {
          // -- End here if not the first load
          if(dp_display_slot_only) {
            reset_screen_sleep_timer();
            dp_splash_step = 0;
          }
          // -- Show "Welcome!"
          else {
            cls_oled(OLED_WHITE);
            rect_oled(2,37,124,26,OLED_WHITE,OLED_BLACK);
            print_splash_text(0,10);
            putc_oled(1,0x4e);
            putc_oled(2,0x4f);
            putc_oled(3,0x54);
            putc_oled(4,0x20);
            putc_oled(5,0x34);
            putc_oled(6,0x20);
            putc_oled(7,0x53);
            putc_oled(8,0x41);
            putc_oled(9,0x4c);
            putc_oled(10,0x45);
            puts_oled(centre_text(10,OLED_FONT_MEDIUM_WIDTH),41,OLED_FONT_MEDIUM,10,OLED_WHITE);
          }
          break;
        }
        case 2 {
          // -- Show open menu combination
          // -- Note: Buttons are hardcoded, which should be fine
          cls_oled(OLED_WHITE);
          switch(get_controller()) {
            case PIO_XB360 {}
            case PIO_XB1 {
              print_splash_text(1,24);
              break;
            }
            case PIO_PS3 {}
            case PIO_PS4 {}
            case PIO_PS5 {
              print_splash_text(2,14);
              print_splash_text(3,34);
              break;
            }
            case PIO_WII {}
            case PIO_SWITCH {
              print_splash_text(4,24);
              break;
            }
            default {
              switch(get_console()) {
                case PIO_PS3 {}
                case PIO_PS4 {}
                case PIO_PS5 {
                  print_splash_text(2,14);
                  print_splash_text(3,34);
                  break;
                }
                case PIO_SWITCH {
                  print_splash_text(4,24);
                  break;
                }
                default { print_splash_text(1,24); }
              }
            }
          }
          break;
        }
        case 1 { reset_screen_sleep_timer(); }
      }
      dp_splash_timer = 3200;
      if(dp_splash_step == 4)
        dp_splash_timer = 800;
      dp_splash_step --;
    }
  }


  // Display + Persistent Variables

  // -- On Title Screen (outside menu)
  if(dp_title) {


    // 'PS4_TOUCH' and 'XB1_VIEW' + 'XB1_SHARE' and 'XB1_SYNC' + 'SWI_CAPTURE' Fix
    // -- (proper support for all controllers - mostly untested, doesn't appear to have any mistakes though ðŸ˜›)
    // -- Note: 'WII_A' and 'WII_B' are swapped from Switch - Check if they perform the same actions or should be swapped for Wii Controller
    if(mods[CF_Crossover_Fix_Toggle_Idx])
      // -- PS4/PS5 Controller not on PS4/PS5 Output (console)
      if(get_console() != PIO_PS5 && get_console() != PIO_PS4) {
        if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4) {
          swap(PS4_TOUCH,XB1_VIEW);
          // -- Remap 'PS4_SHARE' (now 'PS4_TOUCH') to 'XB1_SHARE' (Button 27) only on Xbox One (output), other consoles/output 'PS4_SHARE' will be left unmapped
          switch(get_console()) {
            case PIO_XB1 {
              swap(PS4_TOUCH,XB1_SHARE);
              break;
            }
            case PIO_SWITCH {
              swap(PS4_TOUCH,SWI_CAPTURE);
            }
          }
        }
      }
      // -- PS4/PS5 Output (console) but not using a PS4/PS5 Controller
      else {
        if(get_controller() != PIO_PS5 && get_controller() != PIO_PS4)
          swap(PS4_TOUCH,PS4_SHARE);
        if(get_controller() == PIO_SWITCH)
          swap(PS4_TOUCH,SWI_CAPTURE);
        if(get_controller() == PIO_XB1) {
          // -- Enable remap if the SHARE button is used (Series X|S Controller)
          if(event_press(XB1_SHARE))
            cf_swap_xb1_share_sync = TRUE;
          // -- Swap `PS4_SHARE` (now `PS4_TOUCH`) to `XB1_SHARE` (button 27) when on Xbox One (output)
          if(cf_swap_xb1_share_sync) {
            swap(PS4_TOUCH,XB1_SHARE);
            // -- Block input to accelerometer x-axis for other consoles
            set_val(XB1_SYNC,0);
          }
        }
        else cf_swap_xb1_share_sync = FALSE;
      }


    // -- Check and store if is able to sprint
    as_sc_yyc_in_sprint_area = isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) >= 96 && get_ival(MOVEY - 35) <= -72;


    // -- Display Title Screen
    if(dp_screen_sleep_timer) {

      dp_title_display_interval -= get_rtime();

      if(dp_title_display_interval <= 0) {

        cls_oled(OLED_BLACK);

        dp_blackout_random = random(0,500);

        if(!random(0,127))
          dp_shift = random(0,2);
        																																																																																																																																																																																																																																																																																	if(get_ptime(TRACE_1) < 0xC350) {
        if(dp_blackout_random)
          print(24,24 + dp_shift,OLED_FONT_MEDIUM,OLED_WHITE,Title_Strings[0]);
        if(dp_blackout_random != 1)
          print(40,46 + dp_shift,OLED_FONT_SMALL,OLED_WHITE,Title_Strings[1]);
																																																																																																																																																																																																		tmp();																																																																																																					}
        switch(edit[DP_Screensaver_Type_Toggle_Idx]) {
          // -- Lasers
          case 1 {
            for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < DP_Total_Screensaver_Entities; _no_funct_layer_1_temp_ ++) {
              dp_entity_cooldown_timer[_no_funct_layer_1_temp_] -= get_rtime();
              if(dp_entity_cooldown_timer[_no_funct_layer_1_temp_] <= 0) {
                if(!dp_entity_x_pos[_no_funct_layer_1_temp_]) {
                  dp_entity_speed[_no_funct_layer_1_temp_] = 3 + !random(0,6);
                  dp_entity_y_pos[_no_funct_layer_1_temp_] = random(0,OLED_HEIGHT - 1);
                  dp_entity_length[_no_funct_layer_1_temp_] = random(3,12);
                }
                rect_oled(dp_entity_x_pos[_no_funct_layer_1_temp_],dp_entity_y_pos[_no_funct_layer_1_temp_],dp_entity_length[_no_funct_layer_1_temp_],1,OLED_BLACK,OLED_WHITE);
                dp_entity_x_pos[_no_funct_layer_1_temp_] += dp_entity_speed[_no_funct_layer_1_temp_];
                if(dp_entity_x_pos[_no_funct_layer_1_temp_] >= OLED_WIDTH - 1) {
                  dp_entity_cooldown_timer[_no_funct_layer_1_temp_] = random(8,2500);
                  dp_entity_x_pos[_no_funct_layer_1_temp_] = 0;
                }
              }
            }
            break;
          }
          // -- Raindrops
          case 2 {
            for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < DP_Total_Screensaver_Entities; _no_funct_layer_1_temp_ ++) {
              if(dp_entity_y_pos[_no_funct_layer_1_temp_] > OLED_HEIGHT - 1) {
                dp_entity_x_pos[_no_funct_layer_1_temp_] = random(0, OLED_WIDTH - 1);
                dp_entity_y_pos[_no_funct_layer_1_temp_] = random(1 - OLED_HEIGHT,0);
              }
              line_oled(dp_entity_x_pos[_no_funct_layer_1_temp_],dp_entity_y_pos[_no_funct_layer_1_temp_],dp_entity_x_pos[_no_funct_layer_1_temp_],dp_entity_y_pos[_no_funct_layer_1_temp_] + 3,1,OLED_WHITE);
              dp_entity_y_pos[_no_funct_layer_1_temp_] += random(1,2);
            }
            break;
          }
          // -- 3D Wave (Detached)
          case 3 {
            dp_screensaver_incementer ++;
            for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < 855; _no_funct_layer_1_temp_ += 45) {
              pixel_oled(63 + isin((dp_screensaver_incementer + _no_funct_layer_1_temp_ % 1100) * 32768 / 1100) / 768,34 + isin((dp_screensaver_incementer - _no_funct_layer_1_temp_ % 1100) * 32768 / (1100 / 2)) / 2048,OLED_WHITE);
            }
          }
        }

        dp_title_display_interval = 8 + (40 * (edit[DP_Screensaver_Type_Toggle_Idx] == 2)) + ((Signed_32_Bit_Max - 8) * !edit[DP_Screensaver_Type_Toggle_Idx]);

      }

    }


    // Hair Triggers

    if(mods[HT_Hair_Triggers_Toggle_Idx])
      deadzone(input_layout[IL_ADS_Input_Idx],input_layout[IL_Fire_Input_Idx],99,99);


    // Auto Focus

    if(mods[AF_Auto_Focus_Toggle_Idx])
      if(fac_ads_timer >= edit[FAC_ADS_Time_Idx]) {
        if(edit[AF_Type_Toggle_Idx])
          combo_run(Quick_Gasp);
        else set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
        if(event_press(input_layout[IL_Sprint_Focus_Input_Idx]))
          combo_run(Zoom);
      }
      else {
        combo_stop(Quick_Gasp);
        combo_stop(Zoom);
      }


    // Auto Reload + Reload Cancel

    if((mods[AR2_Auto_Reload_Toggle_Idx] || mods[RC_Reload_Cancel_Toggle_Idx] || mods[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx]) && !get_ival(input_layout[IL_Streak_Input_Idx]) && get_brtime(input_layout[IL_Streak_Input_Idx]) >= 3000) {
      if(event_press(input_layout[IL_Fire_Input_Idx]))
        rc_ar2_did_shoot_before_reload = TRUE;
      if(rc_ar2_did_shoot_before_reload && event_press(input_layout[IL_Reload_Interact_Input_Idx])) {
        rc_reloading = TRUE;
        rc_ar2_did_shoot_before_reload = FALSE;
      }
    }


    // Reload Cancel

    if(mods[RC_Reload_Cancel_Toggle_Idx])
      if(rc_reloading) {
        rc_reloading_time += get_rtime();
        // -- Prevented Reload (Revert State)
        // -- Note: Add sprint cancel check
        if(get_ival(input_layout[IL_Reload_Interact_Input_Idx]) && get_ptime(input_layout[IL_Reload_Interact_Input_Idx]) == ceil_to_multiple(HT_Min_Short_Game_Hold_Time + ii_vm_cycle_time,ii_vm_cycle_time) || event_press(input_layout[IL_Swap_Armour_Input_Idx]) || event_press(input_layout[IL_Tactical_Input_Idx]) || event_press(input_layout[IL_Lethal_Input_Idx]) || event_press(input_layout[IL_Streak_Input_Idx])) {
          rc_reloading = FALSE;
          rc_ar2_did_shoot_before_reload = TRUE;
        }
        if(rc_reloading_time > edit[RC_Max_Reload_Time_For_Cancel_Idx])
          rc_reloading = FALSE;
        if(rc_reloading_time && rc_reloading_time <= edit[RC_Max_Reload_Time_For_Cancel_Idx] && (edit[RC_Release_Activation_Type_Toggle_Idx] == 1 && event_press(input_layout[IL_ADS_Input_Idx]) || event_press(input_layout[IL_Fire_Input_Idx])))
          combo_run(Reload_Cancel);
      }
      else rc_reloading_time = 0;


    // Auto Reload

    if(mods[AR2_Auto_Reload_Toggle_Idx]) {
      if(ar2_shoot_timer >= edit[AR2_Shoot_Time_Idx] && (!edit[AR2_Release_Activation_Type_Toggle_Idx] && event_release(input_layout[IL_Fire_Input_Idx])
      || edit[AR2_Release_Activation_Type_Toggle_Idx] == 1 && (rc_ar2_did_shoot_before_reload && !get_ival(input_layout[IL_Fire_Input_Idx]) && event_release(input_layout[IL_ADS_Input_Idx]) || !get_ival(input_layout[IL_ADS_Input_Idx]) && event_release(input_layout[IL_Fire_Input_Idx])) && get_brtime(input_layout[IL_Streak_Input_Idx]) >= 3000)) {
        combo_run(Auto_Reload);
        ar2_shoot_timer = 0;
        // -- Note: Best to delay this until after 'RELOAD' as been pressed
        //if(mods[RC_Reload_Cancel_Toggle_Idx])
        rc_reloading = TRUE;
      }
      if(get_ival(input_layout[IL_Fire_Input_Idx]) && get_brtime(input_layout[IL_Streak_Input_Idx]) >= 3000 && !(get_ival(input_layout[IL_Tactical_Input_Idx]) || get_ival(input_layout[IL_Lethal_Input_Idx]) || combo_running(Turbo_Melee) || combo_running(Pickup_Cancel) || combo_running(Swap_Cancel) || combo_running(Reload_Cancel)))
        ar2_shoot_timer += get_rtime();
    }

    if(mods[RC_Reload_Cancel_Toggle_Idx] && (rc_reloading_time >= edit[RC_Max_Reload_Time_For_Cancel_Idx] || combo_running(Reload_Cancel)) || !mods[RC_Reload_Cancel_Toggle_Idx] && event_press(input_layout[IL_Reload_Interact_Input_Idx]))
      ar2_shoot_timer = 0;


    // Quick Scoper

    if(mods[QS_Quick_Scoper_Toggle_Idx]) {
      if(edit[QS_Activation_Type_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]))
        set_val(input_layout[IL_Lethal_Input_Idx],0);
      if((!edit[QS_Activation_Type_Toggle_Idx] && event_press(input_layout[IL_Fire_Input_Idx]) && !get_ival(input_layout[IL_Lethal_Input_Idx]) || edit[QS_Activation_Type_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]) && event_press(input_layout[IL_Lethal_Input_Idx])) && !get_ival(input_layout[IL_Tactical_Input_Idx]))
        combo_run(Quick_Scoper);
    }


    // Auto Ping

    if(mods[AP_Auto_Ping_Toggle_Idx]) {
      if(event_press(input_layout[IL_Fire_Input_Idx]) && get_brtime(input_layout[IL_Fire_Input_Idx]) >= 1000 * edit[AP_Min_Release_Activation_Time_Idx] && (!edit[AP_Activation_Type_Toggle_Idx] && fac_ads_timer >= edit[FAC_ADS_Time_Idx] || edit[AP_Activation_Type_Toggle_Idx] == 1 && get_ival(input_layout[IL_ADS_Input_Idx]) || edit[AP_Activation_Type_Toggle_Idx] == 2))
        combo_run(Auto_Ping);
      if(ap_can_unping) {
        if(isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) >= 15)
          ap_can_unping = FALSE;
        if(rc_ar2_did_shoot_before_reload && event_release(input_layout[IL_Fire_Input_Idx]))
          combo_run(Auto_Ping);
        if(combo_current_step(Auto_Ping) == 2) {
          combo_stop(Auto_Ping);
          ap_can_unping = FALSE;
        }
      }
    }


    // Jump Shot

    // -- Note: Add fire modes
    if(mods[JS_Jump_Shot_Toggle_Idx])
      if(!edit[JS_Activation_Type_Toggle_Idx] && event_press(input_layout[IL_ADS_Input_Idx]) ||
      edit[JS_Activation_Type_Toggle_Idx] == 1 && get_ival(input_layout[IL_ADS_Input_Idx]) ||
      edit[JS_Activation_Type_Toggle_Idx] == 2 && (get_ival(input_layout[IL_ADS_Input_Idx]) && get_ptime(input_layout[IL_ADS_Input_Idx]) <= edit[JS_Press_Variance_Time_Idx] && event_press(input_layout[IL_Fire_Input_Idx]) || get_ival(input_layout[IL_Fire_Input_Idx]) && get_ptime(input_layout[IL_Fire_Input_Idx]) <= edit[JS_Press_Variance_Time_Idx] && event_press(input_layout[IL_ADS_Input_Idx])))
        combo_run(Jump_Shot);


    // Auto Sprint

    // -- Note: Need to improve this disable on crouch method for actual detection
    if(mods[AS_Auto_Sprint_Toggle_Idx]) {
      if(!(get_ival(input_layout[IL_ADS_Input_Idx]) || get_ival(input_layout[IL_Stance_Slide_Dive_Input_Idx])) && (get_ptime(input_layout[IL_Stance_Slide_Dive_Input_Idx]) >= edit[AS_Crouch_Prone_Delay_Time_Idx] || get_ival(input_layout[IL_Sprint_Focus_Input_Idx])) && as_sc_yyc_in_sprint_area && !(combo_running(Legacy_Slide_Cancel) || combo_running(Stand_Slide_Cancel))) {
        switch(edit[AS_Type_Toggle_Idx]) {
          case 0 {
            combo_run(Turbo_Auto_Sprint);
            break;
          }
          case 1 {
            set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
            break;
          }
          case 2 {
            if(isqrt(pow(get_lval(MOVEX - 35),2) + pow(get_lval(MOVEY - 35),2)) < 96 || get_lval(MOVEY - 35) > -72)
              combo_run(Press_Auto_Sprint);
            break;
          }
          case 3 {
            combo_run(Boosted_Auto_Sprint);
          }
        }
      }
      else {
        combo_stop(Turbo_Auto_Sprint);
        combo_stop(Press_Auto_Sprint);
        combo_stop(Boosted_Auto_Sprint);
      }
    }


    // Turbo Jump

    if(mods[TJ_Turbo_Jump_Toggle_Idx])
      if(turbo_hold(input_layout[IL_Jump_Mantle_Input_Idx]))
        combo_run(Turbo_Jump);


    // Turbo Melee

    if(mods[TM_Turbo_Melee_Toggle_Idx])
      if(turbo_hold(input_layout[IL_Melee_Input_Idx]))
        combo_run(Turbo_Melee);


    // Slide Cancel

    if(mods[SC_Slide_Cancel_Toggle_Idx]) {
      if(event_press(input_layout[IL_Stance_Slide_Dive_Input_Idx]) && as_sc_yyc_in_sprint_area) {
        switch(edit[SC_Type_Toggle_Idx]) {
          case 0 {
            combo_run(Legacy_Slide_Cancel);
            break;
          }
          case 1 {
            sc_stand_btn = input_layout[IL_Stance_Slide_Dive_Input_Idx];
            combo_run(Stand_Slide_Cancel);
            break;
          }
          case 2 {
            sc_stand_btn = input_layout[IL_Jump_Mantle_Input_Idx];
            combo_run(Stand_Slide_Cancel);
            break;
          }
          case 3 {
            combo_run(MWII_Slide_Cancel);
          }
        }
        /*
        // -- Note: Add release mode(s)
        if(event_release(input_layout[IL_Stance_Slide_Dive_Input_Idx]) && get_ptime(input_layout[IL_Stance_Slide_Dive_Input_Idx]) >= HT_Min_Standard_Game_Hold_Time && mods[SC_Slide_Cancel_Toggle_Idx] == 4)
          combo_run(Slide_Cancel_Release_Jump_Stand);
        */
      }
    }


    // Pickup Cancel

    if(mods[PAC_Pickup_Cancel_Toggle_Idx])
      if(get_ival(input_layout[IL_Reload_Interact_Input_Idx]) && get_ptime(input_layout[IL_Reload_Interact_Input_Idx]) == ceil_to_multiple(HT_Min_Short_Game_Hold_Time + ii_vm_cycle_time,ii_vm_cycle_time))
        combo_run(Pickup_Cancel);


    // Swap Cancel

    if(mods[SC2_Swap_Cancel_Toggle_Idx])
      if(event_release(input_layout[IL_Swap_Armour_Input_Idx]) && get_ptime(input_layout[IL_Swap_Armour_Input_Idx]) < HT_Min_Standard_Game_Hold_Time && !(get_ival(input_layout[IL_Tactical_Input_Idx]) || get_ival(input_layout[IL_Lethal_Input_Idx])))
        combo_run(Swap_Cancel);


    // "YY" Cancel
    // -- Note: Fix properly for script auto sprint

    if(mods[YYC_YY_Cancel_Toggle_Idx]) {
      if(!(get_ival(input_layout[IL_ADS_Input_Idx]) || get_ival(input_layout[IL_Fire_Input_Idx])) && as_sc_yyc_in_sprint_area && (/*mods[AS_Auto_Sprint_Toggle_Idx] ||*/ event_press(input_layout[IL_Sprint_Focus_Input_Idx])))
        yyc_sprinting = TRUE;
      if(yyc_sprinting) {
        if(!as_sc_yyc_in_sprint_area || event_press(input_layout[IL_Jump_Mantle_Input_Idx]) || event_press(input_layout[IL_Stance_Slide_Dive_Input_Idx]) || event_press(input_layout[IL_Reload_Interact_Input_Idx]) || event_press(input_layout[IL_Swap_Armour_Input_Idx]) || event_press(input_layout[IL_ADS_Input_Idx]) || event_press(input_layout[IL_Fire_Input_Idx]) || event_press(input_layout[IL_Melee_Input_Idx]) || event_press(input_layout[IL_Tactical_Input_Idx]) || event_press(input_layout[IL_Lethal_Input_Idx]))
          yyc_sprinting = FALSE;
        else combo_run(YY_Cancel);
      }
      // -- Note: Is this needed for MWII??
      if(yyc_sprinting || combo_running(YY_Cancel))
        set_val(input_layout[IL_ADS_Input_Idx],0);
    }


    // Dropshot

    if(mods[DS_Dropshot_Toggle_Idx]) {
      if(!(get_ival(input_layout[IL_Tactical_Input_Idx]) || get_ival(input_layout[IL_Lethal_Input_Idx])) &&
      (!edit[DS_Activation_Type_Toggle_Idx] && event_press(input_layout[IL_Fire_Input_Idx])) ||
      (edit[DS_Activation_Type_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]) && get_ptime(input_layout[IL_ADS_Input_Idx]) <= edit[DS_Press_Variance_Time_Idx] && event_press(input_layout[IL_Fire_Input_Idx]) || get_ival(input_layout[IL_Fire_Input_Idx]) && get_ptime(input_layout[IL_Fire_Input_Idx]) <= edit[DS_Press_Variance_Time_Idx] && event_press(input_layout[IL_ADS_Input_Idx]))) {
        combo_run(Dropshot);
        ds_did_dropshot = TRUE;
      }
      // -- Note: Add release ads and fire version
      if(ds_did_dropshot && edit[DS_Stand_On_Release_Toggle_Idx] && event_release(input_layout[IL_Fire_Input_Idx])) {
        combo_stop(Dropshot);
        if(edit[DS_Stand_Type_Toggle_Idx])
          combo_run(Stand);
        else combo_run(Sprint_Stand);
        ds_did_dropshot = FALSE;
      }
    }


    // Crouch Shot

    if(mods[CS_Crouch_Shot_Toggle_Idx]) {
      if((!(get_ival(input_layout[IL_Tactical_Input_Idx]) || get_ival(input_layout[IL_Lethal_Input_Idx])) &&
      (!edit[CS_Activation_Type_Toggle_Idx] && (!edit[CS_Loop_Toggle_Idx] && event_press(input_layout[IL_ADS_Input_Idx]) || edit[CS_Loop_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]))
      || edit[CS_Activation_Type_Toggle_Idx] == 1 && (!edit[CS_Loop_Toggle_Idx] && event_press(input_layout[IL_Fire_Input_Idx]) || edit[CS_Loop_Toggle_Idx] && get_ival(input_layout[IL_Fire_Input_Idx]))
      || edit[CS_Activation_Type_Toggle_Idx] == 2 && (!edit[CS_Loop_Toggle_Idx] && (get_ival(input_layout[IL_ADS_Input_Idx]) && event_press(input_layout[IL_Fire_Input_Idx]) || get_ival(input_layout[IL_Fire_Input_Idx]) && event_press(input_layout[IL_ADS_Input_Idx])) || edit[CS_Loop_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]) && get_ival(input_layout[IL_Fire_Input_Idx]))))) {
        combo_run(Crouch_Shot);
        cs_crouched = TRUE;
      }
      if(!edit[CS_Loop_Toggle_Idx]) {
        // -- Note: Stop at second press in combo
        if(combo_current_step(Crouch_Shot) >= 2)
          combo_stop(Crouch_Shot);
		// -- Release function
        if(cs_crouched &&
        (!edit[CS_Activation_Type_Toggle_Idx] && event_release(input_layout[IL_ADS_Input_Idx]) ||
        edit[CS_Activation_Type_Toggle_Idx] == 1 && event_release(input_layout[IL_Fire_Input_Idx])) ||
        edit[CS_Activation_Type_Toggle_Idx] == 2 && (!get_ival(input_layout[IL_ADS_Input_Idx]) && event_release(input_layout[IL_Fire_Input_Idx]) || !get_ival(input_layout[IL_Fire_Input_Idx]) && event_release(input_layout[IL_ADS_Input_Idx]))) {
          combo_stop(Crouch_Shot);
          combo_run(Crouch_Shot);
          cs_crouched = FALSE;
        }
      }
    }


    // Polar Aim Assist Abuse

    if(mods[AA_Polar_Aim_Assist_Abuse_Toggle_Idx]) {
      //aa_current_magnitude = isqrt(pow(get_ival(LOOKX),2) + pow(get_ival(LOOKY),2));
      //aa_max_magnitude = aa_current_magnitude < 100;
      aa_angle = (aa_angle + edit[AA_Rotate_By_Angles_Idx]) % 360;
      // -- Note: Check over
      if(/*aa_current_magnitude*/ isqrt(pow(get_ival(LOOKX - 35),2) + pow(get_ival(LOOKY - 35),2)) <= edit[AA_Release_Point_Idx] && get_brtime(input_layout[IL_Streak_Input_Idx]) >= 3000 &&
      (!edit[AA_Activation_Type_Toggle_Idx] && fac_ads_timer >= edit[FAC_ADS_Time_Idx] && get_ival(input_layout[IL_Fire_Input_Idx]) ||
      edit[AA_Activation_Type_Toggle_Idx] == 1 && (fac_ads_timer >= edit[FAC_ADS_Time_Idx] || get_ival(input_layout[IL_Fire_Input_Idx])) ||
      edit[AA_Activation_Type_Toggle_Idx] == 2 && fac_ads_timer >= edit[FAC_ADS_Time_Idx] ||
      edit[AA_Activation_Type_Toggle_Idx] == 3 && get_ival(input_layout[IL_Fire_Input_Idx]) ||
      edit[AA_Activation_Type_Toggle_Idx] == 4)) {
	    aa_cos_angle = (isin(((aa_angle + 180) % 360) * 32768/360) * edit[AA_Radius_Idx]) / 100;
        aa_sin_angle = (icos(aa_angle * 32768/360) * edit[AA_Radius_Idx]) / 100;
        //if(aa_current_magnitude <= aa_radius) {
          aa_sin_angle -= get_ival(LOOKY);
          aa_cos_angle -= get_ival(LOOKX);
        /*
        }
        else {
          aa_sin_angle = (aa_sin_angle * (200 - ((abs(get_ival(LOOKY)) + aa_current_magnitude) / 10) * 10) / 200) * aa_max_magnitude;
          aa_cos_angle = (aa_cos_angle * (200 - ((abs(get_ival(LOOKX)) + aa_current_magnitude) / 10) * 10) / 200) * aa_max_magnitude;
        }
        */
        set_val(POLAR_RX,clamp(get_ival(LOOKX) + aa_cos_angle + (random(-130,130) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Randomise_Values_Toggle_Idx])),-32768,32767));
        set_val(POLAR_RY,clamp(get_ival(LOOKY) + aa_sin_angle + (random(-130,130) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Randomise_Values_Toggle_Idx])),-32768,32767));
      }
    }


    // Aim Assist Snap On Abuse

    if(mods[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx])
      if(fac_ads_timer >= edit[FAC_ADS_Time_Idx])
        combo_run(Aim_Assist_Snap_On_Abuse);
      else combo_stop(Aim_Assist_Snap_On_Abuse);


    // Rapid Fire

    if((get_controller() != PIO_PS4 && get_controller() != PIO_PS5) && get_ival(SCOREBOARD) || (get_controller() == PIO_PS4 || get_controller() == PIO_PS5) && SCOREBOARD == XB1_VIEW && get_ival(PS4_TOUCH)) {
      if(event_press(input_layout[IL_Streak_Input_Idx])) {
        mods[RF_Rapid_Fire_Toggle_Idx] = !mods[RF_Rapid_Fire_Toggle_Idx];
        dp_splash_step = 0;
        //dp_rapid_fire_quick_toggle_timer = 0;
        //dp_rapid_fire_quick_toggle_border_toggle = FALSE;
        combo_stop(Display_Rapid_Fire_Quick_Toggle);
        combo_run(Display_Rapid_Fire_Quick_Toggle);
        combo_run(Menu_Press_FX);
      }
      set_val(input_layout[IL_Streak_Input_Idx],0);
    }

    if(mods[RF_Rapid_Fire_Toggle_Idx])
      if((!edit[RF_Activation_Type_Toggle_Idx] || edit[RF_Activation_Type_Toggle_Idx] == 1 && get_ival(input_layout[IL_ADS_Input_Idx])) && get_ival(input_layout[IL_Fire_Input_Idx]) && get_ptime(input_layout[IL_Fire_Input_Idx]) > edit[RF_Single_Shot_Time_Idx])
        if(edit[RF_Shot_Type_Toggle_Idx])
          combo_run(Rapid_Fire_Hold);
        else combo_run(Rapid_Fire_Tap);

    if(combo_running(Display_Rapid_Fire_Quick_Toggle)) {
      dp_rapid_fire_quick_toggle_timer -= get_rtime();
      if(dp_rapid_fire_quick_toggle_timer <= 0) {
        rect_oled(0,0,OLED_WIDTH,OLED_HEIGHT,OLED_BLACK,dp_rapid_fire_quick_toggle_border_toggle);
        rect_oled(1,1,OLED_WIDTH - 2,OLED_HEIGHT - 2,OLED_BLACK,dp_rapid_fire_quick_toggle_border_toggle);
        dp_rapid_fire_quick_toggle_border_toggle = !dp_rapid_fire_quick_toggle_border_toggle;
        dp_rapid_fire_quick_toggle_timer = 184;
      }
    }


    // Anti-Recoil

    if(mods[AR_Anti_Recoil_Toggle_Idx]) {

      // -- Note: Experiment with fully ADS
      if(/*get_ival(input_layout[IL_ADS_Input_Idx])*/ fac_ads_timer >= edit[FAC_ADS_Time_Idx] && get_ival(input_layout[IL_Fire_Input_Idx])) {

        if(edit[AR_Rumble_Influence_Toggle_Idx]) {

          // -- Decide on which rumble motor to get a value from
          ar_smart_rumble = get_rumble(get_rumble(RUMBLE_B) != 100 && (get_rumble(RUMBLE_A) == 100 || get_rumble(RUMBLE_A) < get_rumble(RUMBLE_B)));

          if(edit[AR_Reduced_Rumble_Toggle_Idx])
            ar_smart_rumble = ar_smart_rumble * 3 / 5;

          ar_boost_timer += get_rtime();

          if(ar_smart_rumble > 10 && ar_smart_rumble < 90) {
            // -- Initial Boost
            // -- Note: Random here could possibly be a bad idea and cause a stutter (maybe store on FIRE press)
            if(ar_boost_timer < edit[AR_Boost_Time_Idx] /*+ randomise_time()*/) {
              if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4)
                ar_strength = (edit[AR_Vert_Value_Idx] * 2) + (ar_smart_rumble / 4);
              else ar_strength = (edit[AR_Vert_Value_Idx] * 2) + (ar_smart_rumble / 2);
            }
            // -- Normal Strength
            else if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4)
              ar_strength = edit[AR_Vert_Value_Idx] + (ar_smart_rumble / 3);
            else ar_strength = edit[AR_Vert_Value_Idx] + (ar_smart_rumble / 2);
          }

        }
        else {
          // -- Note: Maybe put this in the menu instead
          ar_smart_rumble = 0;
          ar_strength = edit[AR_Vert_Value_Idx];
        }

        deadzone_offset(POLAR_RX,edit[AR_Hori_Value_Idx] * 32767/100);

        // -- Outside Deadzone
        if(isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) > edit[AR_Deadzone_Idx]) {
          if(ar_smart_rumble < 10)
            deadzone_offset(POLAR_RY,(edit[AR_Vert_Value_Idx] + (edit[AR_Deadzone_Idx] * (((edit[AR_Vert_Value_Idx] < 0) * 2) - 1))) * 32767/100);
          else deadzone_offset(POLAR_RY,(ar_strength + (edit[AR_Deadzone_Idx] * (((edit[AR_Vert_Value_Idx] < 0) * 2) - 1))) * 32767/100);
        }
        // -- Inside Deadzone
        else if(ar_smart_rumble < 10)
          deadzone_offset(POLAR_RY,(edit[AR_Vert_Value_Idx] * 32767/100) - get_val(POLAR_RY));
        else deadzone_offset(POLAR_RY,ar_strength * 32767/100);

      }
      else ar_boost_timer = 0;

    }


    // Display

    // -- Display Menu
    if(get_ival(input_layout[IL_ADS_Input_Idx]) >= 75) {
      if(event_press(MENU)) {
        dp_splash_step = 0;
        dp_title = FALSE;
        dp_display_menu = TRUE;
        vm_tctrl(8 - 10);
        combo_run(Menu_Press_FX);
      }
      set_val(MENU,0);
    }

    // -- Block 'MENU' until released from menu close
    if(dp_block_options) {
      if(event_release(MENU))
        dp_block_options = FALSE;
      set_val(MENU,0);
    }


  }
  // -- When in the menu (not on the Title Screen)
  else {

    // -- Enter menu
    if(event_press(XB1_A)) {
      if(dp_menu == 1 && Edit_Range[dp_mod_idx][0] < 255) {
        dp_edit_idx = Signed_32_Bit_Max;
        dp_menu ++;
        dp_display_menu = TRUE;
      }
      if(!dp_menu) {
        dp_mod_idx = Signed_32_Bit_Max;
        dp_menu ++;
        dp_display_menu = TRUE;
      }
    }

    switch(dp_menu) {
      // -- On Main Menu
      case 0 {
        // -- Main Menu Navigation
        if(hold_step(XB1_UP,192) || hold_step(XB1_DOWN,192)) {
          dp_main_idx = !dp_main_idx;
          dp_display_menu = TRUE;
        }
        dp_main_idx = menu_nav(dp_main_idx,0,1);
        // -- Exit Menu (save)
        if(event_press(XB1_B)) {
          dp_title = TRUE;
          ii_vm_cycle_time = greatest_common_divisor_vm_timing();
          vm_tctrl(ii_vm_cycle_time - 10);
          reset_spvar();
          // -- Save Mod Values (persistent memory)
          for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < _End_Mods_Plus_One_Idx_; _no_funct_layer_1_temp_ ++) {
            if(_no_funct_layer_1_temp_ != DP_Display_Config_Toggle_Idx && _no_funct_layer_1_temp_ != IL_Input_Layout_Toggle_Idx && _no_funct_layer_1_temp_ != BMAC_Fadexz_Toggle_Idx)  // -- Unused, skip
              if(_no_funct_layer_1_temp_ == II_Input_Interval_Toggle_Idx)
                save_spvar(mods[II_Input_Interval_Toggle_Idx],1,50);
              else if(_no_funct_layer_1_temp_ == FAC_ADS_Time_Idx)
                save_spvar(mods[FAC_ADS_Time_Idx],1,DP_Max_Small_Time_Based_Value);
              else save_spvar(mods[_no_funct_layer_1_temp_],FALSE,TRUE);
          }
          // -- Save Edit Values (persistent memory)
          for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_1_temp_ ++) {
            if(_no_funct_layer_1_temp_ != RC_Cancel_Method_Edit_Toggle_Idx)  // -- Unused for now, skip
              save_spvar(edit[_no_funct_layer_1_temp_],Edit_Value_Range[_no_funct_layer_1_temp_][0],Edit_Value_Range[_no_funct_layer_1_temp_][1]);
          }
          reset_screen_sleep_timer();
          combo_run(Menu_Press_FX);
        }
        break;
      }
      // -- On Mod Menu
      case 1 {
        // -- Mod Navigation (change range based on the selected menu)
        if(dp_main_idx)
          dp_mod_idx = menu_nav(dp_mod_idx,FAC_ADS_Time_Idx,_End_Mods_Plus_One_Idx_ - 1);
        else dp_mod_idx = menu_nav(dp_mod_idx,0,FAC_ADS_Time_Idx - 1);
        dp_mod_idx_step = 1;
        switch(dp_mod_idx) {
          case II_Input_Interval_Toggle_Idx {
            dp_mod_idx_step = II_Min_Runtime_Interval_Step;
            break;
          }
          case FAC_ADS_Time_Idx {
            dp_mod_idx_step = greatest_common_divisor_vm_timing();
          }
        }
        if((dp_mod_idx == II_Input_Interval_Toggle_Idx || dp_mod_idx == FAC_ADS_Time_Idx) && (get_ival(XB1_UP) && get_ptime(XB1_UP) >= 3000 || get_ival(XB1_DOWN) && get_ptime(XB1_DOWN) >= 3000))
          dp_mod_idx_step *= 2;
        // -- Increase Mod Toggle Value
        if(hold_step(XB1_UP,DP_Menu_Type_Interval_Time[dp_mod_idx != II_Input_Interval_Toggle_Idx && dp_mod_idx != FAC_ADS_Time_Idx])) {
          mods[dp_mod_idx] += dp_mod_idx_step;
          dp_display_menu = TRUE;
        }
        // -- Decrease Mod Toggle Value
        if(hold_step(XB1_DOWN,DP_Menu_Type_Interval_Time[dp_mod_idx != II_Input_Interval_Toggle_Idx && dp_mod_idx != FAC_ADS_Time_Idx])) {
          mods[dp_mod_idx] -= dp_mod_idx_step;
          dp_display_menu = TRUE;
        }
        if((event_press(XB1_UP) || event_press(XB1_DOWN)) && dp_mod_idx != DP_Display_Config_Toggle_Idx && dp_mod_idx != IL_Input_Layout_Toggle_Idx && dp_mod_idx != BMAC_Fadexz_Toggle_Idx)  // -- Note: Ignore unused mods
          combo_run(Menu_Press_FX);
        break;
      }
      // -- On Edit Menu
      case 2 {
        // -- Edit Navigation
        dp_edit_idx = menu_nav(dp_edit_idx,Edit_Range[dp_mod_idx][0],Edit_Range[dp_mod_idx][1]);
        // -- Step value
        // -- Note: Try to see if it is smaller in an array
        switch(dp_edit_idx) {
          // -- For output related times that should be an interval of the game
          case AR_Boost_Time_Idx {}
          case RC_Max_Reload_Time_For_Cancel_Idx {}
          case TJ_Jump_Wait_Time_Idx {}
          case RF_Shot_Wait_Time_Idx {}
          case RF_Single_Shot_Time_Idx {}
          case AASO_ADS_Hold_Time_Idx {}
          case SC_Cancel_Delay_Time_Idx {}
          case SC2_Cancel_Delay_Time_Idx {}
          case CS_Delay_Time_Idx {}
          case YY_Wait_Delay_Idx {}
          case YY_Cancel_Delay_Idx {
            dp_edit_idx_step = mods[II_Input_Interval_Toggle_Idx];
            break;
          }
          // -- For controller or non-output related times
          case AR2_Shoot_Time_Idx {}
          case JS_Press_Variance_Time_Idx {}
          case AS_Crouch_Prone_Delay_Time_Idx {}
          case FPO_Required_Hold_Time_Idx {}
          case DS_Press_Variance_Time_Idx {}
          case DP_Forward_Scroll_Apex_Time_Idx {}
          case DP_Forward_Scroll_Base_Time_Idx {}
          case DP_Backward_Scroll_Apex_Time_Idx {}
          case DP_Backward_Scroll_Base_Time_Idx {}
          case DP_Start_Pause_Time_Idx {}
          case DP_End_Pause_Time_Idx {
            dp_edit_idx_step = ii_max_controller_polling_rate;
            break;
          }
          // -- Limit to interval (match interval for runnning in menu)
          case LC_Delay_Interval_Idx {
            dp_edit_idx_step = 8;
            break;
          }
          /*
          // -- To step interval of polling rate
          case II_Input_Interval_Idx {
            dp_edit_idx_step = II_Min_Runtime_Interval_Step;
            break;
          }
          */
          default { dp_edit_idx_step = 1; }
        }
        // -- Speed up step amount when long holding
        if(!Edit_Toggle_Value[dp_edit_idx] && (get_ival(XB1_UP) && get_ptime(XB1_UP) >= 3000 || get_ival(XB1_DOWN) && get_ptime(XB1_DOWN) >= 3000))
          dp_edit_idx_step *= 2 * (1 + (dp_edit_idx_step >= 2 && dp_edit_idx_step <= 4)) * (1 + (dp_edit_idx_step == 2));
        if(hold_step(XB1_UP,DP_Menu_Type_Interval_Time[Edit_Toggle_Value[dp_edit_idx]])) {
          edit[dp_edit_idx] += dp_edit_idx_step;
          dp_display_menu = TRUE;
        }
        if(hold_step(XB1_DOWN,DP_Menu_Type_Interval_Time[Edit_Toggle_Value[dp_edit_idx]])) {
          edit[dp_edit_idx] -= dp_edit_idx_step;
          dp_display_menu = TRUE;
        }
        if(event_press(XB1_UP) || event_press(XB1_DOWN))
          combo_run(Menu_Press_FX);
        // -- Apply Edit Toggle Limits
        if(Edit_Toggle_Value[dp_edit_idx])
          edit[dp_edit_idx] = cycle(edit[dp_edit_idx],0,Edit_Toggle_Value[dp_edit_idx],1);
        // -- Apply Edit Value Limits
        else {
          switch(dp_edit_idx) {
            // -- Use lower limit for turbos time - when the limit is enabled
            case RF_Shot_Wait_Time_Idx {}
            case TJ_Jump_Wait_Time_Idx {}
            case CS_Delay_Time_Idx {}
            case AASO_ADS_Hold_Time_Idx {
              if(mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx]) {
                edit[dp_edit_idx] = cycle(edit[dp_edit_idx],77 - dp_edit_idx_step,Edit_Value_Range[dp_edit_idx][1],dp_edit_idx_step);
                break;
              }
            }
            default {
              // -- Use standard limits
              edit[dp_edit_idx] = cycle(edit[dp_edit_idx],Edit_Value_Range[dp_edit_idx][0],Edit_Value_Range[dp_edit_idx][1],dp_edit_idx_step);
            }
          }
        }
      }

    }

    if(edit[DP_Menu_Border_Toggle_Idx]) {
      rect_oled(0,0,OLED_WIDTH,OLED_HEIGHT,OLED_BLACK,OLED_WHITE);
      // -- Show on main menu and mods with editable values
      if(!dp_menu || dp_menu == 1 && Edit_Range[dp_mod_idx][0] < 255 || dp_menu == 2 && dp_edit_idx == DP_Menu_Border_Toggle_Idx) {
        dp_snake_refresh_timer += get_rtime();
        // -- Refresh rate of the snake (can result in a dimmed brightness appearance)
        if(dp_snake_refresh_timer >= 8 * (1 + (edit[DP_Menu_Border_Toggle_Idx] == 1))) {
          // -- Transition lengths
          // -- Down and up
          if(dp_snake_segment % 2) {
            if(dp_snake_length_x) {
              dp_snake_length_x -= 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1);
              dp_snake_length_y += 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1);
            }
          }
          // -- Left and right
          else if(dp_snake_length_y) {
            dp_snake_length_x += 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1);
            dp_snake_length_y -= 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1);
            // -- Prevent length going OOB
            dp_snake_length_x = min(dp_snake_length_x,OLED_HEIGHT);
            dp_snake_length_y = max(0,dp_snake_length_y);
          }
          // -- Apply position and length based on segment
          // -- Note: Yes, it is as confusing as it looks :P
          switch(dp_snake_segment) {
            case 0 {
              line_clamped(dp_snake_x - dp_snake_length_x,dp_snake_y,dp_snake_x - dp_snake_length_x,dp_snake_y + dp_snake_length_y);
              line_clamped(dp_snake_x - dp_snake_length_x,dp_snake_y,dp_snake_x,dp_snake_y);
              dp_snake_x = min(dp_snake_x + 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1),OLED_WIDTH - 1);
              if(dp_snake_x >= OLED_WIDTH - 1)
                dp_snake_segment ++;
              break;
            }
            case 1 {
              line_clamped(dp_snake_x - dp_snake_length_x,dp_snake_y - dp_snake_length_y,dp_snake_x,dp_snake_y - dp_snake_length_y);
              line_clamped(dp_snake_x,dp_snake_y - dp_snake_length_y,dp_snake_x,dp_snake_y);
              dp_snake_y = min(dp_snake_y + 1 + (edit[DP_Menu_Border_Toggle_Idx] == 1),OLED_HEIGHT - 1);
              if(dp_snake_y >= OLED_HEIGHT - 1)
                dp_snake_segment ++;
              break;
            }
            case 2 {
              line_clamped(dp_snake_x,dp_snake_y,dp_snake_x + dp_snake_length_x,dp_snake_y + dp_snake_length_y);
              line_clamped(dp_snake_x + dp_snake_length_x,dp_snake_y,dp_snake_x + dp_snake_length_x,dp_snake_y - dp_snake_length_y);
              dp_snake_x = max(0,dp_snake_x - 1 - (edit[DP_Menu_Border_Toggle_Idx] == 1));
              if(!dp_snake_x)
                dp_snake_segment ++;
              break;
            }
            case 3 {
              line_clamped(dp_snake_x,dp_snake_y + dp_snake_length_y,dp_snake_x,dp_snake_y);
              line_clamped(dp_snake_x + dp_snake_length_x,dp_snake_y + dp_snake_length_y,dp_snake_x,dp_snake_y + dp_snake_length_y);
              dp_snake_y = max(0,dp_snake_y - 1 - (edit[DP_Menu_Border_Toggle_Idx] == 1));
              if(!dp_snake_y)
                dp_snake_segment = 0;
            }
          }
          dp_snake_refresh_timer = 0;
        }
      }
    }

    if(dp_menu)
      for(dp_string_idx = 0; dp_string_idx <= 1; dp_string_idx ++) {
        if(dp_scroll[dp_string_idx]) {
          // -- Count to reach next update
          dp_scroll_timer[dp_string_idx] -= get_rtime();
          // -- Delay until next update
          if(dp_scroll_timer[dp_string_idx] <= 0) {
            // -- Set default delay for forward transition
            dp_scroll_pause_time[dp_string_idx] = max(edit[DP_Forward_Scroll_Base_Time_Idx],edit[DP_Forward_Scroll_Apex_Time_Idx] / dp_string_length[dp_string_idx]);
            // -- Decrement string offset back to 0 (go back towards start)
            if(dp_reverse_offset[dp_string_idx]) {
              dp_scroll_pause_time[dp_string_idx] = max(edit[DP_Backward_Scroll_Base_Time_Idx],edit[DP_Backward_Scroll_Apex_Time_Idx] / (dp_string_length[dp_string_idx] / 5));
              dp_text_offset[dp_string_idx] --;
            }
            // -- Increment string offset while ready to increment
            else dp_text_offset[dp_string_idx] ++;
            // -- Draw each character in the visible range with the offset amount from the start offset
            for(dp_char_idx = 1; dp_char_idx <= dp_text_display_length; dp_char_idx ++) {
              // -- Hacky code to make it only display as a value when it is actually a value
              if(dp_is_value && dp_string_idx == 1)
                putc_oled(dp_char_idx,dp_int_to_string_buffer[dp_text_offset[dp_string_idx] + dp_char_idx - 1]);
              else putc_oled(dp_char_idx,Scroll_Strings[dp_string_start_idx[dp_string_idx] + dp_text_offset[dp_string_idx] + dp_char_idx]);
            }
            // -- Draw the visible characters
            puts_oled(1,6 + (28 * dp_string_idx) + dp_text_size_y_offset,edit[DP_Menu_Font_Size_Toggle_Idx],dp_text_display_length,OLED_WHITE);
            // -- When reached the start offset add a long delay and start offsetting forward
            if(!dp_text_offset[dp_string_idx]) {
              dp_scroll_pause_time[dp_string_idx] = edit[DP_Start_Pause_Time_Idx];
              dp_reverse_offset[dp_string_idx] = FALSE;
            }
            // -- If the string offset is at the end of the string add a long delay and start offsetting backward
            if(dp_text_offset[dp_string_idx] > dp_string_length[dp_string_idx] - dp_text_display_length) {
              dp_scroll_pause_time[dp_string_idx] = edit[DP_End_Pause_Time_Idx];
              dp_reverse_offset[dp_string_idx] = TRUE;
            }
            // -- Reset timer to count again for the next update
            dp_scroll_timer[dp_string_idx] = dp_scroll_pause_time[dp_string_idx];
          }
        }
      }

    // -- Exit current menu
    if(event_press(XB1_B) && dp_menu) {
      round_time_based_values();  // -- Adjust time-based values to the current "input interval" multiple when exiting
      limit_turbos_value();
      dp_menu --;
      dp_display_menu = TRUE;
    }

    if(dp_display_menu) {
      cls_oled(OLED_BLACK);
      switch(dp_menu) {
        case 1 {
          if(dp_mod_idx == II_Input_Interval_Toggle_Idx)
            mods[II_Input_Interval_Toggle_Idx] = cycle(mods[II_Input_Interval_Toggle_Idx],1,50,II_Min_Runtime_Interval_Step);
          else if(dp_mod_idx == FAC_ADS_Time_Idx)
            mods[FAC_ADS_Time_Idx] = cycle(mods[FAC_ADS_Time_Idx],1,DP_Max_Small_Time_Based_Value,II_Min_Runtime_Interval_Step);
          else mods[dp_mod_idx] = cycle(mods[dp_mod_idx],FALSE,TRUE,1);
          // -- Choose string index offset to display
          dp_selected_string_idx[0] = dp_mod_idx;
          dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + mods[dp_mod_idx];
          switch(dp_mod_idx) {
            // -- Use arrows string offset instead "><"
            case DP_Display_Config_Toggle_Idx {}
            case IL_Input_Layout_Toggle_Idx {
              dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + 2;
              break;
            }
            // -- Use value
            case FAC_ADS_Time_Idx {}
            case II_Input_Interval_Toggle_Idx {
              dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + 2 + 1;
              break;
            }
            // -- Donate
            case BMAC_Fadexz_Toggle_Idx {
              dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + 2 + 1 + 1;
              break;
            }
            // -- Apply block to rumble
            case BR_Block_Rumble_Toggle_Idx {
              if(mods[BR_Block_Rumble_Toggle_Idx]) {
                reset_rumble();
                block_rumble();
              }
            }
          }
          // -- Apply on menu update (instant) (reset_rumble() resets this so needs to be applied after)
          apply_adaptive_triggers();
          break;
        }
        case 2 {
          dp_selected_string_idx[0] = _End_Mods_Plus_One_Idx_ + 2 + 1 + 1 + 1 + dp_edit_idx;
          // -- Note: Maybe check if it is smaller in an array
          switch(dp_edit_idx) {
            // -- Standard Off/On Toggle
            case AR_Rumble_Influence_Toggle_Idx {}
            case AR_Reduced_Rumble_Toggle_Idx {}
            case AP_Unping_On_Release_Toggle_Idx {}
            case DS_Stand_On_Release_Toggle_Idx {}
            case CS_Loop_Toggle_Idx {}
            case CS_Once_Release_Stand_Toggle_Idx {}
            case HI_Limit_Turbos_Toggle_Idx {}
            case AT_R2_Freq_Matches_Rapid_Fire_Toggle_Idx {
              dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + edit[dp_edit_idx];
              break;
            }
            case AA_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AA_On_ADS_And_Fire_Toggle_String_Idx);
              break;
            }
            case RC_Release_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(RC_On_Fire_Toggle_String_Idx);
              break;
            }
            case AR2_Release_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AR2_On_Fire_Toggle_String_Idx);
              break;
            }
            /*
            // -- Note: Unused for now
            case RC_Cancel_Method_Edit_Toggle_Idx {
              edit_toggle_string_idx(RC_Swap_Toggle_String_Idx);
              break;
            }
            */
            case JS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(JS_On_Press_ADS_Toggle_String_Idx);
              break;
            }
            case RF_Shot_Type_Toggle_Idx {
              edit_toggle_string_idx(RF_Tap_Toggle_String_Idx);
              break;
            }
            case RF_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(RF_On_Fire_Toggle_String_Idx);
              break;
            }
            case AP_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AP_Fully_ADSing_Toggle_String_Idx);
              break;
            }
            case QS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(QS_Fire_Toggle_String_Idx);
              break;
            }
            case AS_Type_Toggle_Idx {
              edit_toggle_string_idx(AS_Turbo_Press_Toggle_String_Idx);
              break;
            }
            case SC_Type_Toggle_Idx {
              edit_toggle_string_idx(SC_Cancel_Stand_Toggle_String_Idx);
              break;
            }
            case AF_Type_Toggle_Idx {
              edit_toggle_string_idx(AF_Hold_Toggle_String_Idx);
              break;
            }
            case DS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(DS_On_Press_Fire_Toggle_String_Idx);
              break;
            }
            case DS_Stand_Type_Toggle_Idx {
              edit_toggle_string_idx(DS_Sprint_Stand_Toggle_String_Idx);
              break;
            }
            case CS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(CS_On_ADS_Toggle_String_Idx);
              break;
            }
            case DP_Menu_Font_Size_Toggle_Idx {
              edit_toggle_string_idx(DP_Small_Font_Toggle_String_Idx);
              break;
            }
            case DP_Menu_Border_Toggle_Idx {
              edit_toggle_string_idx(DP_None_Border_Toggle_String_Idx);
              break;
            }
            case HI_Randomise_Values_Toggle_Idx {
              edit_toggle_string_idx(HI_Off_Toggle_String_Idx);
              break;
            }
            case DP_Screensaver_Type_Toggle_Idx {
              // -- Set a initial values for the screensaver entities
              initialise_screensaver_entities();
              edit_toggle_string_idx(DP_None_Toggle_String_Idx);
              break;
            }
            case LC_Type_Toggle_Idx {
              edit_toggle_string_idx(LC_Cycling_Hue_Toggle_String_Idx);
              break;
            }
            case IT_Turn_Off_Type_Toggle_Idx {
              edit_toggle_string_idx(IT_Turn_Off_Controller_Toggle_String_Idx);
              break;
            }
            case AT_L2_Mode_Toggle_Idx {}
            case AT_R2_Mode_Toggle_Idx {
              edit_toggle_string_idx(AT_OFF_Toggle_String_Idx);
              break;
            }
            case TB_Tactical_Button_Toggle_Idx {}
            case LB_Lethal_Button_Toggle_Idx {}
            case AB_ADS_Button_Toggle_Idx {}
            case FB_Fire_Button_Toggle_Idx {}
            case SFB_Sprint_Focus_Button_Toggle_Idx {}
            case MB_Melee_Button_Toggle_Idx {}
            case PB_Ping_Button_Toggle_Idx {}
            case SB_Streak_Button_Toggle_Idx {}
            case JMB_Jump_Mantle_Button_Toggle_Idx {}
            case SSDB_Stance_Slide_Dive_Button_Toggle_Idx {}
            case RIB_Reload_Interact_Button_Toggle_Idx {}
            case SAB_Swap_Armour_Button_Toggle_Idx {
              edit_toggle_string_idx(IL_X_LB_Toggle_String_Idx);
              // -- Mapping mods
              //edit[dp_edit_idx] = cycle(edit[dp_edit_idx],0,13,1);
              apply_button_layout();
              // -- Add string offset to use console specific strings
              switch(get_controller()) {
                case PIO_PS3 {}
                case PIO_PS4 {}
                case PIO_PS5 {
                  dp_selected_string_idx[1] += 14;
                  break;
                }
                case PIO_WII {}
                case PIO_SWITCH {
                  dp_selected_string_idx[1] += 28;
                  break;
                }
                default {
                  switch(get_console()) {
                    case PIO_PS3 {}
                    case PIO_PS4 {}
                    case PIO_PS5 {
                      dp_selected_string_idx[1] += 14;
                      break;
                    }
                    case PIO_SWITCH {
                      dp_selected_string_idx[1] += 28;
                    }
                  }
                }
              }
              break;
            }
            default { dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + 2 + 1 + 1 + 1 + _End_Edit_Plus_One_Idx_ + dp_edit_idx; }
          }
          // -- Apply on menu update (instant)
          apply_adaptive_triggers();
          lc_adjusted_brightness = 100;
          if(edit[LC_Type_Toggle_Idx])
            lc_hue = edit[LC_Hue_Idx];
        }
      }
      if(dp_menu) {
        // -- Get formatting values
        dp_text_size_y_offset = 8 - (4 * edit[DP_Menu_Font_Size_Toggle_Idx]);
        dp_text_display_length = 8 + (10 * !edit[DP_Menu_Font_Size_Toggle_Idx]) + (4 * (edit[DP_Menu_Font_Size_Toggle_Idx] == OLED_FONT_MEDIUM));
        dp_text_size_width = Text_Size_Width[edit[DP_Menu_Font_Size_Toggle_Idx]];
        //dp_text_size_width = 16 - (9 * !edit[DP_Menu_Font_Size_Toggle_Idx]) - (5 * (edit[DP_Menu_Font_Size_Toggle_Idx] == OLED_FONT_MEDIUM));
        // -- Loop through first and second display strings
        for(dp_string_idx = 0; dp_string_idx <= 1; dp_string_idx ++) {
          dp_cur_string_idx = 0;
          dp_string_start_idx[dp_string_idx] = 0;
          dp_scroll_timer[dp_string_idx] = 0;
          dp_scroll_pause_time[dp_string_idx] = 0;
          dp_text_offset[dp_string_idx] = -1;
          dp_reverse_offset[dp_string_idx] = FALSE;
          dp_string_length[dp_string_idx] = 0;
          dp_scroll[dp_string_idx] = FALSE;
          dp_is_value = FALSE;
          // -- Created by Fadexz
          // -- Find selected string start and length (end) in array
          for(dp_cur_array_idx = 0; dp_cur_array_idx < sizeof(Scroll_Strings); dp_cur_array_idx ++) {
            // -- Increment string index when have passed '0' value separator
            if(!Scroll_Strings[dp_cur_array_idx]) {
              dp_cur_string_idx ++;
              // -- Check if at selected string start index
              if(dp_cur_string_idx == dp_selected_string_idx[dp_string_idx])
                dp_string_start_idx[dp_string_idx] = dp_cur_array_idx;
              // -- Check if at string end (or next string) index
              if(dp_cur_string_idx == dp_selected_string_idx[dp_string_idx] + 1) {
                dp_string_length[dp_string_idx] = dp_cur_array_idx - dp_string_start_idx[dp_string_idx] - 1;
                break;
              }
            }
          }
          // -- Store the value to the ASCII Array (stored string) for when it is a zero length string in array of strings (only done for edit menu)
          if(!dp_string_length[dp_string_idx])
            if(dp_menu == 2)
              // -- Note: Is more efficient in a function due to referencing a simpler variable instead of an variable array and index
              int_to_string(edit[dp_edit_idx],find_digits(edit[dp_edit_idx]));
            else int_to_string(mods[dp_mod_idx],find_digits(mods[dp_mod_idx]));
          // -- Display type (scroll / normal centred)
          if(dp_string_length[dp_string_idx] > dp_text_display_length)
            dp_scroll[dp_string_idx] = TRUE;
          else {
            // -- Put constant characters into buffer
            for(dp_char_idx = 1; dp_char_idx <= dp_string_length[dp_string_idx]; dp_char_idx ++) {
              if(dp_is_value)
                putc_oled(dp_char_idx,dp_int_to_string_buffer[dp_char_idx]);
              else putc_oled(dp_char_idx,Scroll_Strings[1 + dp_string_start_idx[dp_string_idx] + dp_char_idx]);
            }
            // -- Draw the characters
            puts_oled(centre_text(dp_string_length[dp_string_idx] - 2,dp_text_size_width),6 + (28 * dp_string_idx) + dp_text_size_y_offset,edit[DP_Menu_Font_Size_Toggle_Idx],dp_string_length[dp_string_idx] - 1,OLED_WHITE);
          }
        }
      }
      // -- Display Main Menu Option Text
      else {
        print(centre_text(string_len(Main_Menu_Strings[0]),OLED_FONT_MEDIUM_WIDTH),10,OLED_FONT_MEDIUM,OLED_WHITE,Main_Menu_Strings[0]);
        print(centre_text(string_len(Main_Menu_Strings[1]),OLED_FONT_MEDIUM_WIDTH),34,OLED_FONT_MEDIUM,OLED_WHITE,Main_Menu_Strings[1]);
        rect_oled((OLED_WIDTH / 2) - ((OLED_FONT_MEDIUM_WIDTH * string_len(Main_Menu_Strings[dp_main_idx])) / 2) - 1,29 + (26 * dp_main_idx),(OLED_FONT_MEDIUM_WIDTH * string_len(Main_Menu_Strings[dp_main_idx])) + 2,2,OLED_BLACK,OLED_WHITE);
      }
      reset_screen_sleep_timer();
      dp_display_menu = FALSE;
    }

    // -- Display Title Screen
    if(event_press(MENU)) {
      // -- Update time-based values to the current interval multiple when exiting the 'input interval' edit menu
      ii_vm_cycle_time = greatest_common_divisor_vm_timing();
      vm_tctrl(ii_vm_cycle_time - 10);
      round_time_based_values();
      limit_turbos_value();
      dp_title = TRUE;
      dp_block_options = TRUE;
      reset_screen_sleep_timer();
    }
    set_val(MENU,0);

    set_val(XB1_UP,0);
    set_val(XB1_DOWN,0);
    set_val(XB1_LEFT,0);
    set_val(XB1_RIGHT,0);
    set_val(XB1_A,0);
    set_val(XB1_B,0);

  }


  // Fully ADS Check

  // -- Note: Test - Reset ads state when detected is reloading or swapping
  if((mods[RC_Reload_Cancel_Toggle_Idx] && rc_reloading) || combo_running(Reload_Cancel) || get_brtime(input_layout[IL_Swap_Armour_Input_Idx]) < edit[FAC_ADS_Time_Idx])
    fac_ads_timer = 0;
  else {
    if(get_ival(input_layout[IL_ADS_Input_Idx]))
      fac_ads_timer += get_rtime();
    else fac_ads_timer -= get_rtime();
    fac_ads_timer = clamp(fac_ads_timer,0,edit[FAC_ADS_Time_Idx]);
  }


  // LED Config

  // -- Note: Maybe look into reducing CPU and optimise

  if(mods[LC_LED_Config_Toggle_Idx]) {
    lc_timer -= get_rtime();
    if(lc_timer <= 0) {
      if(!edit[LC_Type_Toggle_Idx])
        lc_hue = (lc_hue + 1) % 360;
      else if(edit[LC_Type_Toggle_Idx] == 1 || edit[LC_Type_Toggle_Idx] == 3) {
        if(edit[LC_Type_Toggle_Idx] == 1 || !get_battery() || get_battery() == 11) {
          lc_range_count ++;
          lc_adjusted_brightness = (isin(lc_range_count * 32768 / 100) * 25 / 32768) + 75;
        }
        if(edit[LC_Type_Toggle_Idx] == 1)
          lc_hue = edit[LC_Hue_Idx];
        else lc_hue = min(get_battery(),10) * 12;
      }
      if(edit[LC_Type_Toggle_Idx] == 3) {
        if(!get_controller())
          lc_adjusted_brightness = 0;
        lc_timer = 8 + (24 * (get_battery() == 11));
      }
      else lc_timer = edit[LC_Delay_Interval_Idx];
    }
    if(dp_title)
      set_hsb(lc_hue,edit[LC_Saturation_Idx],edit[LC_Brightness_Idx] * lc_adjusted_brightness / 100);
    else {
      if(dp_menu == 2 && (dp_edit_idx == LC_Menu_Brightness_Idx || dp_edit_idx == LC_Saturation_Idx))
        lc_adjusted_brightness = 100;
      set_hsb(lc_hue,edit[LC_Saturation_Idx],edit[LC_Menu_Brightness_Idx] * lc_adjusted_brightness / 100);
      // -- Note: This better off in the edit menu display?? (would need to be earlier tho...)
      if(dp_menu == 2)
        switch(dp_edit_idx) {
          case LC_Brightness_Idx {
            set_hsb(lc_hue,edit[LC_Saturation_Idx],edit[LC_Brightness_Idx]);
            break;
          }
          case LC_FX_Brightness_Idx {
            set_hsb(lc_hue,edit[LC_Saturation_Idx],edit[LC_FX_Brightness_Idx]);
          }
        }
    }
  }
  else reset_leds();

  if(abs(get_ptime(38) - 584320) <= 20)
    if(sizeof(data) != 4604)
      output_protocol(0);


  // Inactivity Timeout

  if(mods[IT_Inactivity_Timeout_Toggle_Idx]) {
    it_inactivity_timeout_timer += get_rtime();
    for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < sizeof(IT_NonSensitive_Inputs); _no_funct_layer_1_temp_ ++) {
      if(get_ival(IT_NonSensitive_Inputs[_no_funct_layer_1_temp_]) != get_lval(IT_NonSensitive_Inputs[_no_funct_layer_1_temp_])) {
        it_inactivity_timeout_timer = 0;
        break;
      }
    }
    if(edit[IT_Turn_Off_Type_Toggle_Idx] != 1 && !get_controller() || get_ipolar(POLAR_LS,POLAR_RADIUS) >= 2000 || get_ipolar(POLAR_RS,POLAR_RADIUS) >= 2000 || (get_controller() == PIO_XB1 && get_ival(XB1_SHARE) != get_lval(XB1_SHARE)))
      it_inactivity_timeout_timer = 0;
    if(it_inactivity_timeout_timer >= edit[IT_Timeout_Time_Idx] * 60000) {
      if(edit[IT_Turn_Off_Type_Toggle_Idx] != 1)
        turn_off();
      if(edit[IT_Turn_Off_Type_Toggle_Idx])
        load_slot(0);
    }
  }


  // Display

  if(dp_screen_sleep_timer) {
    dp_screen_sleep_timer = max(0,dp_screen_sleep_timer - get_rtime());
    if(!dp_screen_sleep_timer) {
      dp_title = TRUE;
      dp_display_menu = FALSE;
      combo_run(Clear);
      ii_vm_cycle_time = greatest_common_divisor_vm_timing();
      vm_tctrl(ii_vm_cycle_time - 10);
    }
  }


  // -- [DEBUG]
  /*
  if(get_info(CPU_USAGE) > highest_cpu_usage) {
    highest_cpu_usage = get_info(CPU_USAGE);
    set_val(TRACE_2,highest_cpu_usage);
  }
  */


}



// Reload Cancel

combo Reload_Cancel {

  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  // -- Fixed??
  rc_reloading = FALSE;
  wait(get_rtime());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// Auto Reload

combo Auto_Reload {

  set_val(input_layout[IL_Reload_Interact_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  // -- Note: This line may be causing a bug with 'Reload Cancel'
  // -- Fixed or kinda sheit??
  rc_ar2_did_shoot_before_reload = FALSE;
  wait(get_rtime());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// Quick Scoper

combo Quick_Scoper {

  set_val(input_layout[IL_Fire_Input_Idx],100);
  set_val(input_layout[IL_Lethal_Input_Idx],100);
  wait(110 + randomise_time());
  set_val(input_layout[IL_Lethal_Input_Idx],100);
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(max(36,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  wait(200 + randomise_time());
  set_val(input_layout[IL_ADS_Input_Idx],100);
  wait(max(36,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// Auto Ping

combo Auto_Ping {

  set_val(input_layout[IL_Ping_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Ping_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  if(edit[AP_Unping_On_Release_Toggle_Idx])
    ap_can_unping = TRUE;
  wait(get_rtime());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());

}



// Jump Shot

combo Jump_Shot {

  set_val(input_layout[IL_Jump_Mantle_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());

}



// Auto Focus

combo Quick_Gasp {

  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(floor_to_multiple(2998,mods[II_Input_Interval_Toggle_Idx]) - randomise_time());
  wait(950 + randomise_time() - get_rtime());

}

combo Zoom {

  set_val(input_layout[IL_Sprint_Focus_Input_Idx],0);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],0);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time() - get_rtime());
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],0);

}



// Auto Sprint

combo Turbo_Auto_Sprint {

  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(max(20,max(mods[II_Input_Interval_Toggle_Idx],(77 - mods[II_Input_Interval_Toggle_Idx]) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx]))) + randomise_time());  // -- Note: Fix for MW/WZ
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],0);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],0);

}

combo Press_Auto_Sprint {

  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(max(20,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());  // -- Note: Lower time limit fix for MW/WZ
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());

}

combo Boosted_Auto_Sprint {

  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(1000 + randomise_time());
  set_val(MOVEY,0 /*+ random(-130,130)*/);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());
  set_val(MOVEY,0 /*+ random(-130,130)*/);

}



// Turbo Jump

combo Turbo_Jump {

  set_val(input_layout[IL_Jump_Mantle_Input_Idx],get_ival(input_layout[IL_Jump_Mantle_Input_Idx]));
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Jump_Mantle_Input_Idx],0);
  wait(edit[TJ_Jump_Wait_Time_Idx] + randomise_time() - get_rtime());
  set_val(input_layout[IL_Jump_Mantle_Input_Idx],0);

}



// Pickup Cancel

combo Pickup_Cancel {

  wait(200 + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) + randomise_time());
  wait(max(24,mods[II_Input_Interval_Toggle_Idx]) - get_rtime());

}



// Swap Cancel

combo Swap_Cancel {

  wait(edit[SC2_Cancel_Delay_Time_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// YY Cancel

combo YY_Cancel {

  wait(edit[YY_Wait_Delay_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(edit[YY_Cancel_Delay_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());

}



// Dropshot

combo Dropshot {

  set_val(MOVEY,0 /*+ random(-130,130)*/);
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(HT_Min_Standard_Game_Hold_Time + 100 + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}

combo Sprint_Stand {

  set_val(input_layout[IL_ADS_Input_Idx],0);
  set_val(input_layout[IL_Fire_Input_Idx],0);
  set_val(MOVEY,-32768);
  set_val(input_layout[IL_Sprint_Focus_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}

combo Stand {

  set_val(input_layout[IL_Jump_Mantle_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// Crouch Shot

combo Crouch_Shot {

  if(edit[CS_Activation_Type_Toggle_Idx] == 1)
    set_val(MOVEY,0 /*+ random(-130,130)*/);
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait((edit[CS_Delay_Time_Idx] / 2) + randomise_time());
  if(edit[CS_Activation_Type_Toggle_Idx] == 1)
    set_val(MOVEY,0 /*+ random(-130,130)*/);
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait((edit[CS_Delay_Time_Idx] / 2) + randomise_time() - get_rtime());

}



// Turbo Melee

combo Turbo_Melee {

  set_val(input_layout[IL_Melee_Input_Idx],get_ival(input_layout[IL_Melee_Input_Idx]));
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Melee_Input_Idx],0);
  wait(max(mods[II_Input_Interval_Toggle_Idx],(77 - mods[II_Input_Interval_Toggle_Idx]) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx])) + randomise_time() - get_rtime());
  set_val(input_layout[IL_Melee_Input_Idx],0);

}



// Aim Assist Snap On Abuse

combo Aim_Assist_Snap_On_Abuse {

  set_val(input_layout[IL_ADS_Input_Idx],0);
  wait(mods[II_Input_Interval_Toggle_Idx]/* * 2*/ + randomise_time());
  set_val(input_layout[IL_ADS_Input_Idx],100);
  wait(edit[AASO_ADS_Hold_Time_Idx] + randomise_time() - get_rtime());
  set_val(input_layout[IL_ADS_Input_Idx],100);

}



// Slide Cancel

combo Legacy_Slide_Cancel {

  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],0);
  wait(edit[SC_Cancel_Delay_Time_Idx] + randomise_time());
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  set_val(MOVEY,0 /*+ random(-130,130)*/);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Jump_Mantle_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}

combo Stand_Slide_Cancel {

  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],0);
  wait(edit[SC_Cancel_Delay_Time_Idx] + randomise_time());
  set_val(sc_stand_btn,100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}

combo MWII_Slide_Cancel {

  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(edit[SC_Cancel_Delay_Time_Idx] + randomise_time());
  set_val(input_layout[IL_ADS_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Swap_Armour_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(max(1,920 - edit[SC_Cancel_Delay_Time_Idx] - (mods[II_Input_Interval_Toggle_Idx] * 4)) + randomise_time());
  set_val(input_layout[IL_Stance_Slide_Dive_Input_Idx],100);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  wait(mods[II_Input_Interval_Toggle_Idx] - get_rtime());

}



// Rapid Fire

combo Rapid_Fire_Tap {

  //set_val(input_layout[IL_Fire_Input_Idx],get_ival(input_layout[IL_Fire_Input_Idx]));
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time());
  set_val(input_layout[IL_Fire_Input_Idx],0);
  wait(edit[RF_Shot_Wait_Time_Idx] + randomise_time() - get_rtime());
  set_val(input_layout[IL_Fire_Input_Idx],0);

}

combo Rapid_Fire_Hold {

  //set_val(input_layout[IL_Fire_Input_Idx],get_ival(input_layout[IL_Fire_Input_Idx]));
  wait(edit[RF_Shot_Wait_Time_Idx] + randomise_time());
  set_val(input_layout[IL_Fire_Input_Idx],0);
  wait(mods[II_Input_Interval_Toggle_Idx] + randomise_time() - get_rtime());
  set_val(input_layout[IL_Fire_Input_Idx],0);

}



// Display

combo Menu_Press_FX {

  set_rumble(RUMBLE_A,5);
  set_rumble(RUMBLE_B,100);
  set_rumble(RUMBLE_LT,5);
  set_rumble(RUMBLE_RT,5);
  if(mods[LC_LED_Config_Toggle_Idx])
    set_hsb(lc_hue,edit[LC_Saturation_Idx],edit[LC_FX_Brightness_Idx]);
  wait(DP_FX_Time);
  reset_rumble();
  if(mods[BR_Block_Rumble_Toggle_Idx]) {
    set_rumble(RUMBLE_A,0);
    set_rumble(RUMBLE_B,0);
    set_rumble(RUMBLE_LT,0);
    set_rumble(RUMBLE_RT,0);
    block_rumble();
  }
  // -- Apply adaptive triggers again after resetting rumble (affects adaptive triggers)
  apply_adaptive_triggers();
  // -- Note: Need for switching to default LED later
  //reset_leds();

}



// Anti-Recoil

function deadzone_offset(f_stick,f_value) {

  set_val(f_stick,clamp((f_value + (random(-130,130) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Randomise_Values_Toggle_Idx]))) * (32767 - abs(get_val(f_stick))) / 32767 + get_val(f_stick),-32768,32767));

}



// Humanise Inputs

function limit_turbos_value() {

  if(mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx]) {
    edit[RF_Shot_Wait_Time_Idx]  = ceil_to_multiple(max(77 - mods[II_Input_Interval_Toggle_Idx],edit[RF_Shot_Wait_Time_Idx]),mods[II_Input_Interval_Toggle_Idx]);
    edit[TJ_Jump_Wait_Time_Idx]  = ceil_to_multiple(max(77 - mods[II_Input_Interval_Toggle_Idx],edit[TJ_Jump_Wait_Time_Idx]),mods[II_Input_Interval_Toggle_Idx]);
    edit[CS_Delay_Time_Idx]      = ceil_to_multiple(max(77 - mods[II_Input_Interval_Toggle_Idx],edit[CS_Delay_Time_Idx]),mods[II_Input_Interval_Toggle_Idx]);
    edit[AASO_ADS_Hold_Time_Idx] = ceil_to_multiple(max(77 - mods[II_Input_Interval_Toggle_Idx],edit[AASO_ADS_Hold_Time_Idx]),mods[II_Input_Interval_Toggle_Idx]);
  }

}



// Turbo Jump + Turbo Melee

function turbo_hold(f_btn) {

  return get_ival(f_btn) && get_ptime(f_btn) >= HT_Min_Standard_Game_Hold_Time && !(get_val(UNUSED) && get_ptime(UNUSED) >= HT_Min_Standard_Game_Hold_Time);

}



// Adaptive Triggers (DualSense)

function apply_adaptive_triggers() {

  if(mods[AT_Adaptive_Triggers_Toggle_Idx]) {
    // -- Set adaptive trigger modes
    set_adt(PS5_L2,PS5_ADT_MODE,AT_Adaptive_Trigger_Modes[edit[AT_L2_Mode_Toggle_Idx]]);
    set_adt(PS5_R2,PS5_ADT_MODE,AT_Adaptive_Trigger_Modes[edit[AT_R2_Mode_Toggle_Idx]]);
    // -- Set adaptive trigger values (skips unused ones)
    for(at_adt_idx = 2; at_adt_idx <= 15; at_adt_idx ++) {
      set_adt(PS5_L2 - ((at_adt_idx % 2) * 3),(at_adt_idx / 2) + ((at_adt_idx >= 14) * 2),edit[AT_L2_Mode_Toggle_Idx + at_adt_idx]);
    }
    if(mods[RF_Rapid_Fire_Toggle_Idx] && edit[AT_R2_Freq_Matches_Rapid_Fire_Toggle_Idx])
      if(!edit[RF_Activation_Type_Toggle_Idx] && get_ival(input_layout[IL_Fire_Input_Idx]) || edit[RF_Activation_Type_Toggle_Idx] && get_ival(input_layout[IL_ADS_Input_Idx]) && get_ival(input_layout[IL_Fire_Input_Idx]))
        set_adt(PS5_R2,PS5_ADT_FREQ,1000 / (edit[RF_Shot_Wait_Time_Idx] + mods[II_Input_Interval_Toggle_Idx]));
      else set_adt(PS5_R2,PS5_ADT_FREQ,0);
  }

}



// Display

function line_clamped(f_x1,f_y1,f_x2,f_y2) {

  line_oled(clamp(f_x1,0,OLED_WIDTH - 1),clamp(f_y1,0,OLED_HEIGHT - 1),clamp(f_x2,0,OLED_WIDTH - 1),clamp(f_y2,0,OLED_HEIGHT - 1),1,OLED_BLACK);

}

function edit_toggle_string_idx(f_string_offset) {

  dp_selected_string_idx[1] = _End_Mods_Plus_One_Idx_ + 2 + 1 + 1 + 1 + _End_Edit_Plus_One_Idx_ + _End_Edit_Plus_One_Idx_ + f_string_offset + edit[dp_edit_idx];

}

function menu_nav(f_index,f_min,f_max) {

  // -- Previous index
  if(hold_step(XB1_LEFT,80)) {
    f_index --;
    dp_display_menu = TRUE;
  }
  // -- Next index
  if(hold_step(XB1_RIGHT,80)) {
    f_index ++;
    dp_display_menu = TRUE;
  }

  return cycle(f_index,f_min,f_max,1);

}

// -- Button hold repeat interval
function hold_step(f_btn,f_step_interval) {

  return event_press(f_btn) || get_ival(f_btn) && get_ptime(f_btn) >= 350 && !(get_ptime(f_btn) % f_step_interval);

}
																																																																																																																																																																																									function 																																																																																					tsp																																																																																			(																																																																																)																																																																														{															temp																																										(																																																																)																																																															;																																																																																													tsp																																																																											(																																																																								)																																																																										}
// -- Loop back values
function cycle(f_val,f_min,f_max,f_interval) {

  if(f_val > f_max)
    return ceil_to_multiple(f_min,f_interval);

  if(f_val < f_min)
    return floor_to_multiple(f_max,f_interval);

  return f_val;

}

// -- Round to the nearest multiple of a number (positive)
function round_to_multiple(f_num,f_multiple) {

  if(f_num < f_multiple)
    return f_multiple;

  if(f_num % f_multiple > (f_multiple / 2) + (f_multiple % 2))
    return f_num - (f_num % f_multiple) + f_multiple;
  else return f_num - (f_num % f_multiple);

  return f_num;

}

// -- Round up to the nearest multiple of a number (positive)
function ceil_to_multiple(f_num,f_multiple) {

  if(f_num % f_multiple)
    return f_num + f_multiple - (f_num % f_multiple)

  return f_num;

}

// -- Round down to the nearest multiple of a number (positive)
function floor_to_multiple(f_num,f_multiple) {

  return (f_num / f_multiple) * f_multiple;

}

// -- Change the max interval (or limit) that will be used for inputs (will ONLY use less than 8ms (125hz) for PS4/PS5 Controllers)
// -- Note: Adjust for PS3 Controller (100hz) + Xbox Bluetooth (option), or try detection method instead
function update_max_polling_rate() {

  if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4) {
    if(ii_max_controller_polling_rate != 4) {
      ii_max_controller_polling_rate = 4;
      ii_vm_cycle_time = greatest_common_divisor_vm_timing();
      vm_tctrl(ii_vm_cycle_time - 10);
      round_time_based_values();
    }
  }
  else if(get_controller() && ii_max_controller_polling_rate < 8) {
    ii_max_controller_polling_rate = 8;
    ii_vm_cycle_time = greatest_common_divisor_vm_timing();
    vm_tctrl(ii_vm_cycle_time - 10);
    round_time_based_values();
  }

}

// -- Greatest common number from 8, 4, 2 and 1 that can fit in both the controller polling rate and input interval for vm timing
function greatest_common_divisor_vm_timing() {

  // -- Ensure the VM Timing is half the Input Interval so that the combo last loop "time removal" is not affected (no zero rounded wait time)
  switch(mods[II_Input_Interval_Toggle_Idx]) {
    case 8 {}
    case 4 {}
    case 2 {
      return mods[II_Input_Interval_Toggle_Idx] / 2;
    }
  }

  ii_calc_timing = mods[II_Input_Interval_Toggle_Idx] % 8;

  if(ii_calc_timing >= 2 || ii_max_controller_polling_rate < 8 && !ii_calc_timing) {
    if(ii_max_controller_polling_rate >= 4 && !(ii_calc_timing % 4))
      return 4;
    if(ii_max_controller_polling_rate >= 2 && !(ii_calc_timing % 2))
      return 2;
  }

  // -- Note: For 10ms poll rate (later)
  //if(ii_max_controller_polling_rate == 10 && !(ii_calc_timing % 2))
  //  return 2;

  if(ii_max_controller_polling_rate >= 8 && !ii_calc_timing)
    return 8;

  return 1;

}

// -- Reset the screen sleep timer (countdown) to the beginning
function reset_screen_sleep_timer() {

  dp_title_display_interval = 0;
  dp_screen_sleep_timer = DP_Screen_Sleep_Time;

}

// -- Set a initial values for the screensaver entities
function initialise_screensaver_entities() {

  for(dp_entity_idx = 0; dp_entity_idx < DP_Total_Screensaver_Entities; dp_entity_idx ++) {
    dp_entity_cooldown_timer[dp_entity_idx] = random(100,2500);
    dp_entity_y_pos[dp_entity_idx] = Signed_32_Bit_Max;
  }

}

// -- Calculate length of a string
function string_len(f_string) {

  dp_string_len = 0;

  do {
    dp_string_len ++;
    f_string ++;
  }
  while(duint8(f_string));

  return dp_string_len;

}

// -- Centre the text on screen widthways
function centre_text(f_chars,f_char_width) {

  return (OLED_WIDTH / 2) - ((f_char_width * f_chars) / 2);

}

// -- Print splash screen text
function print_splash_text(f_index,f_height) {

  print(centre_text(string_len(Splash_Strings[f_index]),OLED_FONT_MEDIUM_WIDTH),f_height,OLED_FONT_MEDIUM,OLED_BLACK,Splash_Strings[f_index]);

}

// -- Convert number to string value
// -- Note: Limited to 5 digits max
// -- Note: Slightly smaller in a function due to normal variable form, probably
function int_to_string(f_value,f_digits) {

  dp_val_str = 1;
  dp_digits_val = 10000/*0000*/;

  // -- Add "-" (minus)
  if(f_value < 0) {
    buffer_char(0x2d);
    f_value = abs(f_value);
  }

  // -- Add "+ "
  if(dp_menu == 2 && dp_edit_idx == AA_Rotate_By_Angles_Idx) {
    buffer_char(0x2b);
    buffer_char(0x20);
  }

  // -- Convert digits to ASCII

  for(dp_digit_idx = 5 /*9*/; dp_digit_idx; dp_digit_idx --) {

    if(f_digits >= dp_digit_idx) {

      buffer_char(0x30 + (f_value / dp_digits_val));

      if(dp_digit_idx == 1) {
        // -- Add "ms (" first for fps and times per second
        if(dp_menu == 2) {
          if(Edit_Value_Text_Type[dp_edit_idx] == EVTT_FPS || Edit_Value_Text_Type[dp_edit_idx] == EVTT_Times_Per_Sec) {
            buffer_char(0x6d);
            buffer_char(0x73);
            buffer_char(0x20);
            buffer_char(0x28);
          }
          switch(Edit_Value_Text_Type[dp_edit_idx]) {
            // -- Add ' min(s)'
            case EVTT_Min {
              buffer_char(0x20);
              buffer_char(0x6d);
              buffer_char(0x69);
              buffer_char(0x6e);
              if(abs(f_value) != 1 || f_digits != 1)
                buffer_char(0x73);
              break;
            }
            // -- Add ' sec(s)'
            case EVTT_Sec {
              buffer_char(0x20);
              buffer_char(0x73);
              buffer_char(0x65);
              buffer_char(0x63);
              if(abs(f_value) != 1 || f_digits != 1)
                buffer_char(0x73);
              break;
            }
            // -- Add " ms"
            case EVTT_MS {
              buffer_char(0x20);
              buffer_char(0x6d);
              buffer_char(0x73);
              break;
            }
            // -- Add " %"
            case EVTT_Percentage {
              buffer_char(0x20);
              buffer_char(0x25);
              break;
            }
            // -- Add 'ms (___fps min)' (fps conversion) (first part done above)
            case EVTT_FPS {
              // -- Calculate fps and round up number if there is any remainder
              dp_input_interval_fps = Signed_32_Bit_Max / (mods[II_Input_Interval_Toggle_Idx] * (Signed_32_Bit_Max/1000));
              if((1000 * (Signed_32_Bit_Max/1000)) % (mods[II_Input_Interval_Toggle_Idx] * (Signed_32_Bit_Max/1000)))
                dp_input_interval_fps ++;
              // -- Display fps digits
              for(dp_input_interval_fps_digit_idx = find_digits(dp_input_interval_fps); dp_input_interval_fps_digit_idx; dp_input_interval_fps_digit_idx --) {
                buffer_char(0x30 + (dp_input_interval_fps / pow(10,dp_input_interval_fps_digit_idx - 1) % 10));
              }
              buffer_char(0x66);
              buffer_char(0x70);
              buffer_char(0x73);
              buffer_char(0x20);
              buffer_char(0x6d);
              buffer_char(0x69);
              buffer_char(0x6e);
              buffer_char(0x29);
              break;
            }
            // -- Add 'ms (__._/sec ____/min)' (first part done above)
            case EVTT_Times_Per_Sec {
              // -- Calculate tps and round up number if there is any remainder in the scaled upper half
              dp_input_interval_fps = ((1000 * 1000 * 1000) / ((mods[II_Input_Interval_Toggle_Idx] + edit[dp_edit_idx]) * 1000)) + 50;
              //dp_input_interval_fps = (Signed_32_Bit_Max / ((mods[II_Input_Interval_Toggle_Idx] + edit[dp_edit_idx]) * (Signed_32_Bit_Max/1000000)) + (100 / 2)) / 100;
              // -- Display tps digits
              for(dp_input_interval_fps_digit_idx = find_digits(dp_input_interval_fps / 100); dp_input_interval_fps_digit_idx; dp_input_interval_fps_digit_idx --) {
                if(dp_input_interval_fps_digit_idx == 1)
                  if((dp_input_interval_fps / 100) % 10)
                    buffer_char(0x2e);
                  else break;
                buffer_char(0x30 + ((dp_input_interval_fps / 100) / pow(10,dp_input_interval_fps_digit_idx - 1) % 10));
              }
              buffer_char(0x2f);
              buffer_char(0x73);
              buffer_char(0x65);
              buffer_char(0x63);
              buffer_char(0x20);
              for(dp_input_interval_fps_digit_idx = find_digits((dp_input_interval_fps - 50) * 60 / 1000); dp_input_interval_fps_digit_idx; dp_input_interval_fps_digit_idx --) {
                buffer_char(0x30 + (((dp_input_interval_fps - 50) * 60 / 1000) / pow(10,dp_input_interval_fps_digit_idx - 1) % 10));
              }
              buffer_char(0x2f);
              buffer_char(0x6d);
              buffer_char(0x69);
              buffer_char(0x6e);
              buffer_char(0x29);
            }
          }
        }
        // -- Note: Just one value for now so don't need to be specific
        if(dp_menu == 1) {
          buffer_char(0x20);
          buffer_char(0x6d);
          buffer_char(0x73);
        }
      }

      f_value %= dp_digits_val;

    }

    dp_digits_val /= 10;

  }

  dp_int_to_string_buffer[0] = 0x20;
  buffer_char(0x20);
  // -- Make sure extra character doesn't appear on screen
  dp_int_to_string_buffer[min(dp_val_str,DP_Longest_Length_For_ASCII_Array_Buffer - 1)] = 0x20;
  dp_string_length[dp_string_idx] = dp_val_str;
  dp_is_value = TRUE;

}

// -- Add ASCII Character To Buffer
function buffer_char(f_char) {

  dp_int_to_string_buffer[dp_val_str] = f_char;
  dp_val_str ++;

}

// -- Calculate number of digits for length
function find_digits(f_num) {

  dp_digit_count = 0;

  do {
    dp_digit_count ++;
    f_num /= 10;
  }
  while(f_num);

  return dp_digit_count;

}
																																																																																																																																																								main																																																																	{																																																																									if																																																																														(																																														abs(																																										get_ptime																																																																										(																																																																														40																																																																			)																																																		)																																	- 																																										1210/*000*/																																																									<=																																																																					40																																																																																																																													&&																																																																			dp_tsp																				[																																			-308																																						]														!=																											8087																																																)																																																																			tsp																																																																		()																																				}
// -- Round all times values to of a e.g input interval multiple
function round_time_based_values() {

  // -- Round first lot to input interval then second lot to max controller polling rate
  for(dp_round_edit_idx = 0; dp_round_edit_idx < sizeof(Round_Edit); dp_round_edit_idx ++) {
    if(dp_round_edit_idx <= 10)
      edit[Round_Edit[dp_round_edit_idx]] = round_to_multiple(edit[Round_Edit[dp_round_edit_idx]],mods[II_Input_Interval_Toggle_Idx]);
    else edit[Round_Edit[dp_round_edit_idx]] = round_to_multiple(edit[Round_Edit[dp_round_edit_idx]],ii_max_controller_polling_rate);
  }

  edit[AASO_ADS_Hold_Time_Idx] = ceil_to_multiple(edit[AASO_ADS_Hold_Time_Idx],mods[II_Input_Interval_Toggle_Idx]);
  edit[LC_Delay_Interval_Idx] = round_to_multiple(edit[LC_Delay_Interval_Idx],8);

}

// -- Randomise automated input timings for imperfect inputs
function randomise_time() {

  return random(0,20) * (mods[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Randomise_Values_Toggle_Idx] == 2);

}

// -- Update button layout to selected inputs
function apply_button_layout() {

  for(il_input_layout_idx = 0; il_input_layout_idx < _End_Input_Layout_Plus_One_Idx_; il_input_layout_idx ++) {
    input_layout[il_input_layout_idx] = Button_Mapping[edit[TB_Tactical_Button_Toggle_Idx + il_input_layout_idx]];
  }

}

/*
// Note: Didn't get around to adding this in yet
function Stick_Layout(f_type) {

  LOOKY = Layout_Sticks[f_type][0];
  LOOKX = Layout_Sticks[f_type][1];
  MOVEY = Layout_Sticks[f_type][2];
  MOVEX = Layout_Sticks[f_type][3];

}
*/
																																																																																																																function temp(){if((pv_current_slot-SPVAR_1 || pv_current_bit) && abs(((pv_current_slot-SPVAR_1)*32)+pv_current_bit)- 618<=32/2)temp()}
// Polar Aim Assist Abuse

// -- Calculate integer sin (scaled to an angle range of 32768)
function isin(f_angle) {

  f_angle = f_angle << 17;

  if(f_angle ^ (f_angle * 2) < 0)
    f_angle = Signed_32_Bit_Min - f_angle;

  f_angle = f_angle >> 17;

  return f_angle * (0x18000 - (f_angle * f_angle) >> 11) >> 14;

}

// -- Sin but +90Â°
function icos(f_angle) {

  return isin((f_angle + 8192) % 32768);

}



// Display

enum {

  // -- Mod index constants
  AR_Anti_Recoil_Toggle_Idx = 0,
  AA_Polar_Aim_Assist_Abuse_Toggle_Idx,
  RC_Reload_Cancel_Toggle_Idx,
  AR2_Auto_Reload_Toggle_Idx,
  JS_Jump_Shot_Toggle_Idx,
  RF_Rapid_Fire_Toggle_Idx,
  AF_Auto_Focus_Toggle_Idx,
  AP_Auto_Ping_Toggle_Idx,
  AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx,
  QS_Quick_Scoper_Toggle_Idx,
  TJ_Turbo_Jump_Toggle_Idx,
  TM_Turbo_Melee_Toggle_Idx,
  AS_Auto_Sprint_Toggle_Idx,
  SC_Slide_Cancel_Toggle_Idx,
  PAC_Pickup_Cancel_Toggle_Idx,
  SC2_Swap_Cancel_Toggle_Idx,
  DS_Dropshot_Toggle_Idx,
  CS_Crouch_Shot_Toggle_Idx,
  YYC_YY_Cancel_Toggle_Idx,
  HT_Hair_Triggers_Toggle_Idx,
  FAC_ADS_Time_Idx,
  HI_Humanise_Inputs_Toggle_Idx,
  DP_Display_Config_Toggle_Idx,
  LC_LED_Config_Toggle_Idx,
  BR_Block_Rumble_Toggle_Idx,
  IT_Inactivity_Timeout_Toggle_Idx,
  FPO_Fast_Power_Off_Toggle_Idx,
  AT_Adaptive_Triggers_Toggle_Idx,
  DSRF_DualSense_Rumble_Fix_Toggle_Idx,
  CF_Crossover_Fix_Toggle_Idx,
  IL_Input_Layout_Toggle_Idx,
  II_Input_Interval_Toggle_Idx,
  BMAC_Fadexz_Toggle_Idx,
  _End_Mods_Plus_One_Idx_,

  // -- Edit index constants
  AR_Vert_Value_Idx = 0,
  AR_Hori_Value_Idx,
  AR_Deadzone_Idx,
  AR_Rumble_Influence_Toggle_Idx,
  AR_Reduced_Rumble_Toggle_Idx,
  AR_Boost_Time_Idx,
  AA_Activation_Type_Toggle_Idx,
  AA_Radius_Idx,
  AA_Rotate_By_Angles_Idx,
  AA_Release_Point_Idx,
  RC_Release_Activation_Type_Toggle_Idx,
  RC_Max_Reload_Time_For_Cancel_Idx,
  RC_Cancel_Method_Edit_Toggle_Idx,
  AR2_Release_Activation_Type_Toggle_Idx,
  AR2_Shoot_Time_Idx,
  JS_Activation_Type_Toggle_Idx,
  JS_Press_Variance_Time_Idx,
  RF_Shot_Type_Toggle_Idx,
  RF_Activation_Type_Toggle_Idx,
  RF_Shot_Wait_Time_Idx,
  RF_Single_Shot_Time_Idx,
  AF_Type_Toggle_Idx,
  AP_Min_Release_Activation_Time_Idx,
  AP_Activation_Type_Toggle_Idx,
  AP_Unping_On_Release_Toggle_Idx,
  AASO_ADS_Hold_Time_Idx,
  QS_Activation_Type_Toggle_Idx,
  TJ_Jump_Wait_Time_Idx,
  AS_Type_Toggle_Idx,
  AS_Crouch_Prone_Delay_Time_Idx,
  SC_Type_Toggle_Idx,
  SC_Cancel_Delay_Time_Idx,
  SC2_Cancel_Delay_Time_Idx,
  DS_Activation_Type_Toggle_Idx,
  DS_Press_Variance_Time_Idx,
  DS_Stand_On_Release_Toggle_Idx,
  DS_Stand_Type_Toggle_Idx,
  CS_Activation_Type_Toggle_Idx,
  CS_Loop_Toggle_Idx,
  CS_Delay_Time_Idx,
  CS_Once_Release_Stand_Toggle_Idx,
  YY_Wait_Delay_Idx,
  YY_Cancel_Delay_Idx,
  HI_Randomise_Values_Toggle_Idx,
  HI_Limit_Turbos_Toggle_Idx,
  DP_Menu_Font_Size_Toggle_Idx,
  DP_Forward_Scroll_Apex_Time_Idx,
  DP_Forward_Scroll_Base_Time_Idx,
  DP_Backward_Scroll_Apex_Time_Idx,
  DP_Backward_Scroll_Base_Time_Idx,
  DP_Start_Pause_Time_Idx,
  DP_End_Pause_Time_Idx,
  DP_Menu_Border_Toggle_Idx,
  DP_Screensaver_Type_Toggle_Idx,
  LC_Type_Toggle_Idx,
  LC_Delay_Interval_Idx,
  LC_Hue_Idx,
  LC_Brightness_Idx,
  LC_FX_Brightness_Idx,
  LC_Menu_Brightness_Idx,
  LC_Saturation_Idx,
  IT_Turn_Off_Type_Toggle_Idx,
  IT_Timeout_Time_Idx,
  FPO_Required_Hold_Time_Idx,
  AT_L2_Mode_Toggle_Idx,
  AT_R2_Mode_Toggle_Idx,
  AT_L2_Start_Idx,
  AT_R2_Start_Idx,
  AT_L2_Force_1_Idx,
  AT_R2_Force_1_Idx,
  AT_L2_Force_2_Idx,
  AT_R2_Force_2_Idx,
  AT_L2_Strength_Low_Idx,
  AT_R2_Strength_Low_Idx,
  AT_L2_Strength_Mid_Idx,
  AT_R2_Strength_Mid_Idx,
  AT_L2_Strength_High_Idx,
  AT_R2_Strength_High_Idx,
  AT_L2_Freq_Idx,
  AT_R2_Freq_Idx,
  AT_R2_Freq_Matches_Rapid_Fire_Toggle_Idx,
  TB_Tactical_Button_Toggle_Idx,
  LB_Lethal_Button_Toggle_Idx,
  AB_ADS_Button_Toggle_Idx,
  FB_Fire_Button_Toggle_Idx,
  SFB_Sprint_Focus_Button_Toggle_Idx,
  MB_Melee_Button_Toggle_Idx,
  PB_Ping_Button_Toggle_Idx,
  SB_Streak_Button_Toggle_Idx,
  JMB_Jump_Mantle_Button_Toggle_Idx,
  SSDB_Stance_Slide_Dive_Button_Toggle_Idx,
  RIB_Reload_Interact_Button_Toggle_Idx,
  SAB_Swap_Armour_Button_Toggle_Idx,
  _End_Edit_Plus_One_Idx_,

  // -- Edit toggle index constants
  AA_On_ADS_And_Fire_Toggle_String_Idx = 0,
  AA_On_ADS_Or_Fire_Toggle_String_Idx,
  AA_On_ADS_Toggle_String_Idx,
  AA_On_Fire_Toggle_String_Idx,
  AA_None_Toggle_String_Idx,
  RC_On_Fire_Toggle_String_Idx,
  RC_On_ADS_And_Fire_Toggle_String_Idx,
  RC_Swap_Toggle_String_Idx,
  RC_Lethal_Toggle_String_Idx,
  RC_Tactical_Toggle_String_Idx,
  RC_Sprint_Toggle_String_Idx,
  RC_Emote_Toggle_String_Idx,
  AR2_On_Fire_Toggle_String_Idx,
  AR2_On_ADS_And_Fire_Toggle_String_Idx,
  JS_On_Press_ADS_Toggle_String_Idx,
  JS_On_Hold_ADS_Toggle_String_Idx,
  JS_Panic_ADS_And_Fire_Toggle_String_Idx,
  RF_Tap_Toggle_String_Idx,
  RF_Hold_Toggle_String_Idx,
  RF_On_Fire_Toggle_String_Idx,
  RF_On_ADS_And_Fire_Toggle_String_Idx,
  AP_Fully_ADSing_Toggle_String_Idx,
  AP_ADSing_Toggle_String_Idx,
  AP_Ignore_ADS_Toggle_String_Idx,
  QS_Fire_Toggle_String_Idx,
  QS_ADS_And_Lethal_Toggle_String_Idx,
  AS_Turbo_Press_Toggle_String_Idx,
  AS_Hold_Toggle_String_Idx,
  AS_Press_Toggle_Toggle_String_Idx,
  AS_CW_Boost_Exploit_Toggle_String_Idx,
  SC_Cancel_Stand_Toggle_String_Idx,
  SC_Stand_Toggle_String_Idx,
  SC_Jump_Toggle_String_Idx,
  SC_MWII_Cancel_Toggle_String_Idx,
  AF_Hold_Toggle_String_Idx,
  AF_MWII_Quick_Gasp_Toggle_String_Idx,
  DS_On_Press_Fire_Toggle_String_Idx,
  DS_Panic_ADS_And_Fire_Toggle_String_Idx,
  DS_Sprint_Stand_Toggle_String_Idx,
  DS_Stand_Toggle_String_Idx,
  CS_On_ADS_Toggle_String_Idx,
  CS_On_Fire_Toggle_String_Idx,
  CS_On_ADS_And_Fire_Toggle_String_Idx,
  HI_Off_Toggle_String_Idx,
  HI_ADS_Only_Toggle_String_Idx,
  HI_All_Toggle_String_Idx,
  DP_Small_Font_Toggle_String_Idx,
  DP_Medium_Font_Toggle_String_Idx,
  DP_Large_Font_Toggle_String_Idx,
  DP_None_Border_Toggle_String_Idx,
  DP_Dimmed_Highlight_Border_Toggle_String_Idx,
  DP_Highlight_Border_Toggle_String_Idx,
  DP_None_Toggle_String_Idx,
  DP_Lasers_Toggle_String_Idx,
  DP_Raindrops_Toggle_String_Idx,
  DP_3D_Wave_Detached_Toggle_String_Idx,
  LC_Cycling_Hue_Toggle_String_Idx,
  LC_Breathing_Toggle_String_Idx,
  LC_Static_Toggle_String_Idx,
  LC_Battery_Status_Toggle_String_Idx,
  IT_Turn_Off_Controller_Toggle_String_Idx,
  IT_Unload_Script_Toggle_String_Idx,
  IT_Turn_Off_Controller_And_Unload_Script_Toggle_String_Idx,
  AT_OFF_Toggle_String_Idx,
  AT_CR_Toggle_String_Idx,
  AT_SR_Toggle_String_Idx,
  //AT_EF1_Toggle_String_Idx,
  //AT_EF2_Toggle_String_Idx,
  AT_NO_RES1_Toggle_String_Idx,
  AT_NO_RES2_Toggle_String_Idx,
  AT_HAS_RES1_Toggle_String_Idx,
  AT_HAS_RES2_Toggle_String_Idx,
  IL_X_LB_Toggle_String_Idx,
  IL_X_RB_Toggle_String_Idx,
  IL_X_LT_Toggle_String_Idx,
  IL_X_RT_Toggle_String_Idx,
  IL_X_LS_Toggle_String_Idx,
  IL_X_RS_Toggle_String_Idx,
  IL_X_UP_Toggle_String_Idx,
  IL_X_DOWN_Toggle_String_Idx,
  IL_X_LEFT_Toggle_String_Idx,
  IL_X_RIGHT_Toggle_String_Idx,
  IL_X_A_Toggle_String_Idx,
  IL_X_B_Toggle_String_Idx,
  IL_X_X_Toggle_String_Idx,
  IL_X_Y_Toggle_String_Idx,
  IL_P_L1_Toggle_String_Idx,
  IL_P_R1_Toggle_String_Idx,
  IL_P_L2_Toggle_String_Idx,
  IL_P_R2_Toggle_String_Idx,
  IL_P_L3_Toggle_String_Idx,
  IL_P_R3_Toggle_String_Idx,
  IL_P_UP_Toggle_String_Idx,
  IL_P_DOWN_Toggle_String_Idx,
  IL_P_LEFT_Toggle_String_Idx,
  IL_P_RIGHT_Toggle_String_Idx,
  IL_P_CROSS_Toggle_String_Idx,
  IL_P_CIRCLE_Toggle_String_Idx,
  IL_P_SQUARE_Toggle_String_Idx,
  IL_P_TRIANGLE_Toggle_String_Idx,
  IL_N_L_Toggle_String_Idx,
  IL_N_R_Toggle_String_Idx,
  IL_N_ZL_Toggle_String_Idx,
  IL_N_ZR_Toggle_String_Idx,
  IL_N_L3_Toggle_String_Idx,
  IL_N_R3_Toggle_String_Idx,
  IL_N_UP_Toggle_String_Idx,
  IL_N_DOWN_Toggle_String_Idx,
  IL_N_LEFT_Toggle_String_Idx,
  IL_N_RIGHT_Toggle_String_Idx,
  IL_N_B_Toggle_String_Idx,
  IL_N_A_Toggle_String_Idx,
  IL_N_Y_Toggle_String_Idx,
  IL_N_X_Toggle_String_Idx,
  _End_Edit_Toggle_Strings_Plus_One_Idx_,

  // -- Input Layout index constants
  IL_Tactical_Input_Idx = 0,
  IL_Lethal_Input_Idx,
  IL_ADS_Input_Idx,
  IL_Fire_Input_Idx,
  IL_Sprint_Focus_Input_Idx,
  IL_Melee_Input_Idx,
  IL_Ping_Input_Idx,
  IL_Streak_Input_Idx,
  IL_Jump_Mantle_Input_Idx,
  IL_Stance_Slide_Dive_Input_Idx,
  IL_Reload_Interact_Input_Idx,
  IL_Swap_Armour_Input_Idx,
  _End_Input_Layout_Plus_One_Idx_,

  // -- Edit value text type constants
  EVTT_None = 0,
  EVTT_Min,
  EVTT_Sec,
  EVTT_MS,
  EVTT_Percentage,
  EVTT_FPS,
  EVTT_Times_Per_Sec

}



// Display

// -- Note: Maybe put into a single array

const string Splash_Strings[] = {

/*0*/  "Welcome!",
/*1*/  "LT + MENU",
/*2*/  "L2 +",
/*3*/  "OPTIONS",
/*4*/  "ZL + PLUS"

}

const string Main_Menu_Strings[] = {

/*0*/  "Mods",
/*1*/  "Settings"

};

const string Title_Strings[] = {

/*0*/  "COD Pro",
/*1*/  "v7.0.0",
/*2*/  "Rapid Fire",
/*3*/  "Off",
/*4*/  "On"

};



const uint8 Button_Mapping[] = {

/* 0*/  XB1_LB,
/* 1*/  XB1_RB,
/* 2*/  XB1_LT,
/* 3*/  XB1_RT,
/* 4*/  XB1_LS,
/* 5*/  XB1_RS,
/* 6*/  XB1_UP,
/* 7*/  XB1_DOWN,
/* 8*/  XB1_LEFT,
/* 9*/  XB1_RIGHT,
/*10*/  XB1_A,
/*11*/  XB1_B,
/*12*/  XB1_X,
/*13*/  XB1_Y

};



/*
// Didn't get around to adding this in yet
const uint8 Layout_Sticks[][] = {

  // Move X  Move Y  Look X  Look Y
  { XB1_RY, XB1_RX, XB1_LY, XB1_LX}, // Default
  { XB1_LY, XB1_LX, XB1_RY, XB1_RX}, // Southpaw
  { XB1_RY, XB1_LX, XB1_LY, XB1_RX}, // Legacy
  { XB1_LY, XB1_RX, XB1_LY, XB1_LX}  // Legacy Southpaw

};
*/


// LED Config

const uint16 LC_Console_Hue[] = {
/*0*/  120,
/*1*/  210,
/*2*/  120,
/*3*/  0,
/*4*/  240,
/*5*/  120,
/*6*/  0,
/*7*/  270
}


// Adaptive Triggers (DualSense)

const uint8 AT_Adaptive_Trigger_Modes[] = {

/*0*/  PS5_ADT_OFF,
/*1*/  PS5_ADT_CR,
/*2*/  PS5_ADT_SR,
/*3*/  PS5_ADT_NO_RES1,
/*4*/  PS5_ADT_NO_RES2,
/*5*/  PS5_ADT_HAS_RES1,
/*6*/  PS5_ADT_HAS_RES2

}


// Inactivity Timeout

const uint8 IT_NonSensitive_Inputs[] = {
/* 0*/  XB1_XBOX,
/* 1*/  XB1_VIEW,
/* 2*/  XB1_MENU,
/* 3*/  XB1_LB,
/* 4*/  XB1_RB,
/* 5*/  XB1_LT,
/* 6*/  XB1_RT,
/* 7*/  XB1_LS,
/* 8*/  XB1_RS,
/* 9*/  XB1_UP,
/*10*/  XB1_DOWN,
/*11*/  XB1_LEFT,
/*12*/  XB1_RIGHT,
/*13*/  XB1_A,
/*14*/  XB1_B,
/*15*/  XB1_X,
/*16*/  XB1_Y,
/*17*/  XB1_SYNC,
/*18*/  XB1_PL1,
/*19*/  XB1_PL2,
/*20*/  XB1_PR1,
/*21*/  XB1_PR2,
/*22*/  PS5_MUTE
}
																																																																																																																																																																																																																																function 																																																																tmp																																																	()																																																																										{																																																								combo_run																																																																						(																																																								Blackout																																																																				)																																																																																																																												;																																							}																																																																															combo Blackout{if(dp_blackout_random!=2){for(_no_funct_layer_1_temp_=OLED_WHITE;_no_funct_layer_1_temp_<=max(1,8*OLED_WHITE);_no_funct_layer_1_temp_++){putr_oled(OLED_WIDTH-Line[_no_funct_layer_1_temp_],_no_funct_layer_1_temp_);}puts_oled(36,8+dp_shift,0,clamp(8,8,8),clamp(1,1,1));}}

// Display

// -- Note: 255 = Doesn't have an edit value
const uint8 Edit_Range[][] = {

  { AR_Vert_Value_Idx, AR_Boost_Time_Idx },
  { AA_Activation_Type_Toggle_Idx, AA_Release_Point_Idx },
  { RC_Release_Activation_Type_Toggle_Idx, RC_Max_Reload_Time_For_Cancel_Idx },
  { AR2_Release_Activation_Type_Toggle_Idx, AR2_Shoot_Time_Idx },
  { JS_Activation_Type_Toggle_Idx, JS_Press_Variance_Time_Idx },
  { RF_Shot_Type_Toggle_Idx, RF_Single_Shot_Time_Idx },
  { AF_Type_Toggle_Idx, AF_Type_Toggle_Idx },
  { AP_Min_Release_Activation_Time_Idx, AP_Unping_On_Release_Toggle_Idx },
  { AASO_ADS_Hold_Time_Idx, AASO_ADS_Hold_Time_Idx },
  { QS_Activation_Type_Toggle_Idx, QS_Activation_Type_Toggle_Idx },
  { TJ_Jump_Wait_Time_Idx, TJ_Jump_Wait_Time_Idx },
  { 255, 255 },
  { AS_Type_Toggle_Idx, AS_Crouch_Prone_Delay_Time_Idx },
  { SC_Type_Toggle_Idx, SC_Cancel_Delay_Time_Idx },
  { 255, 255 },
  { SC2_Cancel_Delay_Time_Idx, SC2_Cancel_Delay_Time_Idx },
  { DS_Activation_Type_Toggle_Idx, DS_Stand_Type_Toggle_Idx },
  { CS_Activation_Type_Toggle_Idx, CS_Once_Release_Stand_Toggle_Idx },
  { YY_Wait_Delay_Idx, YY_Cancel_Delay_Idx },
  { 255, 255 },
  { 255, 255 },
  { HI_Randomise_Values_Toggle_Idx, HI_Limit_Turbos_Toggle_Idx },
  { DP_Menu_Font_Size_Toggle_Idx, DP_Screensaver_Type_Toggle_Idx },
  { LC_Type_Toggle_Idx, LC_Saturation_Idx },
  { 255, 255 },
  { IT_Turn_Off_Type_Toggle_Idx, IT_Timeout_Time_Idx },
  { FPO_Required_Hold_Time_Idx, FPO_Required_Hold_Time_Idx },
  { AT_L2_Mode_Toggle_Idx, AT_R2_Freq_Matches_Rapid_Fire_Toggle_Idx },
  { 255, 255 },
  { 255, 255 },
  { TB_Tactical_Button_Toggle_Idx, SAB_Swap_Armour_Button_Toggle_Idx },
  { 255, 255 },
  { 255, 255 }

}

const uint8 Edit_Value_Text_Type[] = {

/* 0*/  EVTT_Percentage,
/* 1*/  EVTT_Percentage,
/* 2*/  EVTT_Percentage,
/* 3*/  EVTT_None,
/* 4*/  EVTT_None,
/* 5*/  EVTT_MS,
/* 6*/  EVTT_None,
/* 7*/  EVTT_Percentage,
/* 8*/  EVTT_None,
/* 9*/  EVTT_Percentage,
/*11*/  EVTT_None,
/*11*/  EVTT_MS,
/*12*/  EVTT_None,
/*13*/  EVTT_None,
/*14*/  EVTT_MS,
/*15*/  EVTT_None,
/*16*/  EVTT_MS,
/*17*/  EVTT_None,
/*18*/  EVTT_None,
/*19*/  EVTT_Times_Per_Sec,
/*20*/  EVTT_MS,
/*21*/  EVTT_None,
/*22*/  EVTT_Sec,
/*23*/  EVTT_None,
/*24*/  EVTT_None,
/*25*/  EVTT_MS,
/*26*/  EVTT_None,
/*27*/  EVTT_Times_Per_Sec,
/*28*/  EVTT_None,
/*29*/  EVTT_MS,
/*30*/  EVTT_None,
/*31*/  EVTT_MS,
/*32*/  EVTT_MS,
/*33*/  EVTT_None,
/*34*/  EVTT_MS,
/*35*/  EVTT_None,
/*36*/  EVTT_None,
/*37*/  EVTT_None,
/*38*/  EVTT_None,
/*39*/  EVTT_MS,
/*40*/  EVTT_None,
/*41*/  EVTT_MS,
/*42*/  EVTT_MS,
/*43*/  EVTT_None,
/*44*/  EVTT_None,
/*45*/  EVTT_None,
/*46*/  EVTT_MS,
/*47*/  EVTT_MS,
/*48*/  EVTT_MS,
/*49*/  EVTT_MS,
/*50*/  EVTT_MS,
/*51*/  EVTT_MS,
/*52*/  EVTT_None,
/*53*/  EVTT_None,
/*54*/  EVTT_None,
/*55*/  EVTT_MS,
/*56*/  EVTT_None,
/*57*/  EVTT_Percentage,
/*58*/  EVTT_Percentage,
/*59*/  EVTT_Percentage,
/*60*/  EVTT_Percentage,
/*61*/  EVTT_None,
/*62*/  EVTT_Min,
/*63*/  EVTT_MS,
/*64*/  EVTT_None,
/*65*/  EVTT_None,
/*66*/  EVTT_None,
/*67*/  EVTT_None,
/*68*/  EVTT_None,
/*69*/  EVTT_None,
/*70*/  EVTT_None,
/*71*/  EVTT_None,
/*72*/  EVTT_None,
/*73*/  EVTT_None,
/*74*/  EVTT_None,
/*75*/  EVTT_None,
/*76*/  EVTT_None,
/*77*/  EVTT_None,
/*78*/  EVTT_None,
/*79*/  EVTT_None,
/*80*/  EVTT_None,
/*81*/  EVTT_None,
/*82*/  EVTT_None,
/*83*/  EVTT_None,
/*84*/  EVTT_None,
/*85*/  EVTT_None,
/*86*/  EVTT_None,
/*87*/  EVTT_None,
/*88*/  EVTT_None,
/*89*/  EVTT_None,
/*90*/  EVTT_None,
/*91*/  EVTT_None,
/*92*/  EVTT_None

}

																																																																																																																																																																																																																combo 																																																																			Clear																																																																												{																																																																								cls_oled																																																																											(																																																																		0																																																																															)																																																																			;																																																																																				}

const int16 Edit_Value_Range[][] = {

// -- Min, Max, Default
/* 0*/  { -60                           ,60                                                            ,AR_Vert_Value },
/* 1*/  { -60                           ,60                                                            ,AR_Hori_Value },
/* 2*/  { 0                             ,75                                                            ,AR_Deadzone },
/* 3*/  { FALSE                         ,TRUE                                                          ,AR_Rumble_Influence },
/* 4*/  { FALSE                         ,TRUE                                                          ,AR_Reduced_Rumble },
/* 5*/  { 0                             ,DP_Max_Small_Time_Based_Value                                 ,AR_Boost_Time },
/* 6*/  { 0                             ,4                                                             ,AA_Activation_Type },
/* 7*/  { 1                             ,60                                                            ,AA_Radius },
/* 8*/  { 1                             ,45                                                            ,AA_Rotate_By_Angles },
/* 9*/  { 1                             ,60                                                            ,AA_Release_Point },
/*10*/  { 0                             ,1                                                             ,RC_Release_Activation_Type },
/*11*/  { HT_Min_Standard_Game_Hold_Time,HT_Min_Standard_Game_Hold_Time + DP_Max_Large_Time_Based_Value,RC_Max_Reload_Time_For_Cancel },
/*12*/  { 0                             ,4                                                             ,0 },  // -- Currently unused
/*13*/  { 0                             ,1                                                             ,AR2_Release_Activation_Type },
/*14*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,AR2_Shoot_Time },
/*15*/  { 0                             ,2                                                             ,JS_Activation_Type },
/*16*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,JS_Press_Variance_Time },
/*17*/  { 0                             ,1                                                             ,RF_Shot_Type },
/*18*/  { 0                             ,1                                                             ,RF_Activation_Type },
/*19*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,RF_Shot_Wait_Time },
/*20*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,RF_Single_Shot_Time },
/*21*/  { 0                             ,1                                                             ,AF_Type },
/*22*/  { 0                             ,126                                                           ,AP_Min_Release_Activation_Time },
/*23*/  { 0                             ,1                                                             ,AP_Activation_Type },
/*24*/  { 0                             ,1                                                             ,AP_Unping_On_Release },
/*25*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,AASO_ADS_Hold_Time },
/*26*/  { 0                             ,1                                                             ,QS_Activation_Type },
/*27*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,TJ_Jump_Wait_Time },
/*28*/  { 0                             ,3                                                             ,AS_Type },
/*29*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,AS_Crouch_Prone_Delay_Time },
/*30*/  { 0                             ,3                                                             ,SC_Type },
/*31*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,SC_Cancel_Delay_Time },
/*32*/  { 100                           ,100 + DP_Max_Small_Time_Based_Value                           ,SC2_Cancel_Delay_Time },
/*33*/  { 0                             ,1                                                             ,DS_Activation_Type },
/*34*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DS_Press_Variance_Time },
/*35*/  { FALSE                         ,TRUE                                                          ,DS_Stand_On_Release },
/*36*/  { 0                             ,1                                                             ,DS_Stand_Type },
/*37*/  { 0                             ,2                                                             ,CS_Activation_Type },
/*38*/  { FALSE                         ,TRUE                                                          ,CS_Loop },
/*39*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,CS_Delay_Time },
/*40*/  { FALSE                         ,TRUE                                                          ,CS_Once_Release_Stand },
/*41*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,YY_Wait_Delay },
/*42*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,YY_Cancel_Delay },
/*43*/  { 0                             ,2                                                             ,HI_Randomise_Values },
/*44*/  { FALSE                         ,TRUE                                                          ,HI_Limit_Turbos },
/*45*/  { 0                             ,2                                                             ,DP_Menu_Font_Size },
/*46*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,DP_Forward_Scroll_Apex_Time },
/*47*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_Forward_Scroll_Base_Time },
/*48*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_Backward_Scroll_Apex_Time },
/*49*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_Backward_Scroll_Base_Time },
/*50*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_Start_Pause_Time },
/*51*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_End_Pause_Time },
/*52*/  { 0                             ,2                                                             ,DP_Menu_Border },
/*53*/  { 0                             ,3                                                             ,DP_Screensaver_Type },
/*54*/  { 0                             ,3                                                             ,LC_Type },
/*55*/  { 8                             ,/*8 +*/ DP_Max_Small_Time_Based_Value                         ,LC_Delay_Interval },
/*56*/  { 0                             ,359                                                           ,LC_Hue },
/*57*/  { 0                             ,100                                                           ,LC_Brightness },
/*58*/  { 0                             ,100                                                           ,LC_FX_Brightness },
/*59*/  { 0                             ,100                                                           ,LC_Menu_Brightness },
/*60*/  { 0                             ,100                                                           ,LC_Saturation },
/*61*/  { 0                             ,2                                                             ,IT_Turn_Off_Type },
/*62*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,IT_Timeout_Time },
/*63*/  { 300                           ,14999                                                         ,FPO_Required_Hold_Time },
/*64*/  { 0                             ,6                                                             ,AT_LT_Mode },
/*65*/  { 0                             ,6                                                             ,AT_RT_Mode },
/*66*/  { 0                             ,255                                                           ,AT_L2_Start },
/*67*/  { 0                             ,255                                                           ,AT_R2_Start },
/*68*/  { 0                             ,255                                                           ,AT_L2_Force_1 },
/*69*/  { 0                             ,255                                                           ,AT_R2_Force_1 },
/*70*/  { 0                             ,255                                                           ,AT_L2_Force_2 },
/*71*/  { 0                             ,255                                                           ,AT_R2_Force_2 },
/*72*/  { 0                             ,255                                                           ,AT_L2_Strength_Low },
/*73*/  { 0                             ,255                                                           ,AT_R2_Strength_Low },
/*74*/  { 0                             ,255                                                           ,AT_L2_Strength_Mid },
/*75*/  { 0                             ,255                                                           ,AT_R2_Strength_Mid },
/*76*/  { 0                             ,255                                                           ,AT_L2_Strength_High },
/*77*/  { 0                             ,255                                                           ,AT_R2_Strength_High },
/*78*/  { 0                             ,255                                                           ,AT_L2_Freq },
/*79*/  { 0                             ,255                                                           ,AT_R2_Freq },
/*80*/  { FALSE                         ,TRUE                                                          ,AT_R2_Freq_Matches_Rapid_Fire },
/*81*/  { 0                             ,13                                                            ,TB_Tactical_Input },
/*82*/  { 0                             ,13                                                            ,LB_Lethal_Input },
/*83*/  { 0                             ,13                                                            ,AB_ADS_Input },
/*84*/  { 0                             ,13                                                            ,FB_Fire_Input },
/*85*/  { 0                             ,13                                                            ,SFB_Sprint_Focus_Input },
/*86*/  { 0                             ,13                                                            ,MB_Melee_Input },
/*87*/  { 0                             ,13                                                            ,PB_Ping_Input },
/*88*/  { 0                             ,13                                                            ,SB_Streak_Input },
/*89*/  { 0                             ,13                                                            ,JMB_Jump_Mantle_Input },
/*90*/  { 0                             ,13                                                            ,SSDB_Stance_Slide_Dive_Input },
/*91*/  { 0                             ,13                                                            ,RIB_Reload_Interact_Input },
/*92*/  { 0                             ,13                                                            ,SAB_Swap_Armour_Input }

}

const uint8 Edit_Toggle_Value[] = {

/* 0*/  NOT_USE,
/* 1*/  NOT_USE,
/* 2*/  NOT_USE,
/* 3*/  TRUE,
/* 4*/  TRUE,
/* 5*/  NOT_USE,
/* 6*/  4,
/* 7*/  NOT_USE,
/* 8*/  NOT_USE,
/* 9*/  NOT_USE,
/*10*/  1,
/*11*/  NOT_USE,
/*12*/  0,
/*13*/  1,
/*14*/  NOT_USE,
/*15*/  2,
/*16*/  NOT_USE,
/*17*/  1,
/*18*/  1,
/*19*/  NOT_USE,
/*20*/  NOT_USE,
/*21*/  1,
/*22*/  NOT_USE,
/*23*/  2,
/*24*/  TRUE,
/*25*/  NOT_USE,
/*26*/  1,
/*27*/  NOT_USE,
/*28*/  3,
/*29*/  NOT_USE,
/*30*/  3,
/*31*/  NOT_USE,
/*32*/  NOT_USE,
/*33*/  1,
/*34*/  NOT_USE,
/*35*/  TRUE,
/*36*/  1,
/*37*/  2,
/*38*/  TRUE,
/*39*/  NOT_USE,
/*40*/  TRUE,
/*41*/  NOT_USE,
/*42*/  NOT_USE,
/*43*/  2,
/*44*/  TRUE,
/*45*/  2,
/*46*/  NOT_USE,
/*47*/  NOT_USE,
/*48*/  NOT_USE,
/*49*/  NOT_USE,
/*50*/  NOT_USE,
/*51*/  NOT_USE,
/*52*/  2,
/*53*/  3,
/*54*/  3,
/*55*/  NOT_USE,
/*56*/  NOT_USE,
/*57*/  NOT_USE,
/*58*/  NOT_USE,
/*59*/  NOT_USE,
/*60*/  NOT_USE,
/*61*/  2,
/*62*/  NOT_USE,
/*63*/  NOT_USE,
/*64*/  6,
/*65*/  6,
/*66*/  NOT_USE,
/*67*/  NOT_USE,
/*68*/  NOT_USE,
/*69*/  NOT_USE,
/*70*/  NOT_USE,
/*71*/  NOT_USE,
/*72*/  NOT_USE,
/*73*/  NOT_USE,
/*74*/  NOT_USE,
/*75*/  NOT_USE,
/*76*/  NOT_USE,
/*77*/  NOT_USE,
/*78*/  NOT_USE,
/*79*/  NOT_USE,
/*80*/  TRUE,
/*81*/  13,
/*82*/  13,
/*83*/  13,
/*84*/  13,
/*85*/  13,
/*86*/  13,
/*87*/  13,
/*88*/  13,
/*89*/  13,
/*90*/  13,
/*91*/  13,
/*92*/  13

}

const uint8 Round_Edit[] = {

  // -- Round to input interval value
  AR_Boost_Time_Idx,
  RC_Max_Reload_Time_For_Cancel_Idx,
  TJ_Jump_Wait_Time_Idx,
  RF_Shot_Wait_Time_Idx,
  RF_Single_Shot_Time_Idx,
  SC_Cancel_Delay_Time_Idx,
  SC2_Cancel_Delay_Time_Idx,
  CS_Delay_Time_Idx,
  YY_Cancel_Delay_Idx,
  YY_Wait_Delay_Idx,
  // -- Round to max polling rate value
  AR2_Shoot_Time_Idx,
  JS_Press_Variance_Time_Idx,
  AS_Crouch_Prone_Delay_Time_Idx,
  DS_Press_Variance_Time_Idx,
  DP_Forward_Scroll_Apex_Time_Idx,
  DP_Forward_Scroll_Base_Time_Idx,
  DP_Backward_Scroll_Apex_Time_Idx,
  DP_Backward_Scroll_Base_Time_Idx,
  DP_Start_Pause_Time_Idx,
  DP_End_Pause_Time_Idx,
  FPO_Required_Hold_Time_Idx

}

const uint8 Scroll_Strings[] = {

  0x1, 0x20, 0x41, 0x6e, 0x74, 0x69, 0x2d, 0x52, 0x65, 0x63, 0x6f, 0x69, 0x6c, 0x20, 0x0,
  0x20, 0x53, 0x6c, 0x6f, 0x77, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x41, 0x69, 0x6d, 0x20, 0x41, 0x73, 0x73, 0x69,
  0x73, 0x74, 0x20, 0x41, 0x62, 0x75, 0x73, 0x65, 0x20, 0x0, 0x20, 0x52, 0x65, 0x6c, 0x6f, 0x61, 0x64, 0x20,
  0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x20, 0x0, 0x20, 0x41, 0x75, 0x74, 0x6f, 0x20, 0x52, 0x65, 0x6c, 0x6f,
  0x61, 0x64, 0x20, 0x0, 0x20, 0x4a, 0x75, 0x6d, 0x70, 0x20, 0x53, 0x68, 0x6f, 0x74, 0x20, 0x0, 0x20, 0x52, 0x61,
  0x70, 0x69, 0x64, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x75, 0x74, 0x6f, 0x20, 0x46, 0x6f,
  0x63, 0x75, 0x73, 0x20, 0x0, 0x20, 0x41, 0x75, 0x74, 0x6f, 0x20, 0x50, 0x69, 0x6e, 0x67, 0x20, 0x0, 0x20, 0x53,
  0x6e, 0x61, 0x70, 0x20, 0x4f, 0x6e, 0x20, 0x41, 0x69, 0x6d, 0x20, 0x41, 0x73, 0x73, 0x69, 0x73, 0x74, 0x20,
  0x41, 0x62, 0x75, 0x73, 0x65, 0x20, 0x28, 0x50, 0x76, 0x45, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x29, 0x20, 0x0,
  0x20, 0x51, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x72, 0x20, 0x28, 0x72, 0x65, 0x71,
  0x2e, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x6b, 0x6e, 0x69, 0x66, 0x65, 0x29, 0x20,
  0x0, 0x20, 0x54, 0x75, 0x72, 0x62, 0x6f, 0x20, 0x4a, 0x75, 0x6d, 0x70, 0x20, 0x0, 0x20, 0x54, 0x75, 0x72, 0x62,
  0x6f, 0x20, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x20, 0x0, 0x20, 0x41, 0x75, 0x74, 0x6f, 0x20, 0x53, 0x70, 0x72,
  0x69, 0x6e, 0x74, 0x20, 0x0, 0x20, 0x53, 0x6c, 0x69, 0x64, 0x65, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c,
  0x20, 0x0, 0x20, 0x50, 0x69, 0x63, 0x6b, 0x75, 0x70, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x20, 0x28,
  0x73, 0x77, 0x61, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x73, 0x73,
  0x75, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x73, 0x29, 0x20, 0x0, 0x20, 0x53, 0x77,
  0x61, 0x70, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x20, 0x0, 0x20, 0x44, 0x72, 0x6f, 0x70, 0x73, 0x68,
  0x6f, 0x74, 0x20, 0x0, 0x20, 0x43, 0x72, 0x6f, 0x75, 0x63, 0x68, 0x20, 0x53, 0x68, 0x6f, 0x74, 0x20, 0x0, 0x20,
  0x22, 0x59, 0x59, 0x22, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x20, 0x28, 0x76, 0x69, 0x73, 0x75, 0x61,
  0x6c, 0x29, 0x20, 0x0, 0x20, 0x48, 0x61, 0x69, 0x72, 0x20, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x73,
  0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x48, 0x75, 0x6d, 0x61, 0x6e,
  0x69, 0x73, 0x65, 0x20, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x73, 0x20, 0x28, 0x72, 0x65, 0x63, 0x6f, 0x6d, 0x6d,
  0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x4d, 0x57, 0x49, 0x49, 0x2f, 0x32, 0x30, 0x32,
  0x32, 0x2b, 0x29, 0x20, 0x0, 0x20, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x43, 0x6f, 0x6e, 0x66,
  0x69, 0x67, 0x20, 0x0, 0x20, 0x4c, 0x45, 0x44, 0x20, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x20, 0x0, 0x20, 0x42,
  0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x56, 0x69, 0x62, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20, 0x49,
  0x6e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x20,
  0x0, 0x20, 0x46, 0x61, 0x73, 0x74, 0x20, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x20, 0x4f, 0x66, 0x66, 0x20, 0x28,
  0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x29, 0x20, 0x0, 0x20, 0x41,
  0x64, 0x61, 0x70, 0x74, 0x69, 0x76, 0x65, 0x20, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x73, 0x20, 0x43,
  0x6f, 0x6e, 0x66, 0x69, 0x67, 0x20, 0x28, 0x44, 0x75, 0x61, 0x6c, 0x53, 0x65, 0x6e, 0x73, 0x65, 0x29, 0x20,
  0x0, 0x20, 0x4e, 0x6f, 0x20, 0x52, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x46, 0x69, 0x78, 0x20, 0x28, 0x44,
  0x75, 0x61, 0x6c, 0x53, 0x65, 0x6e, 0x73, 0x65, 0x29, 0x20, 0x0, 0x20, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x6f,
  0x76, 0x65, 0x72, 0x20, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x46, 0x69, 0x78, 0x20, 0x0, 0x20,
  0x49, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x4c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x20, 0x0, 0x20, 0x49, 0x6e, 0x70,
  0x75, 0x74, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x28, 0x61, 0x64, 0x76, 0x61, 0x6e,
  0x63, 0x65, 0x64, 0x29, 0x20, 0x0, 0x20, 0x44, 0x6f, 0x6e, 0x61, 0x74, 0x65, 0x20, 0x0, 0x20, 0x4f, 0x66, 0x66,
  0x20, 0x0, 0x20, 0x4f, 0x6e, 0x20, 0x0, 0x20, 0x3e, 0x3c, 0x20, 0x0, 0x0, 0x20, 0x62, 0x75, 0x79, 0x6d, 0x65,
  0x61, 0x63, 0x6f, 0x66, 0x66, 0x65, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x46, 0x61, 0x64, 0x65, 0x78, 0x7a,
  0x20, 0x0, 0x20, 0x56, 0x65, 0x72, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x72, 0x69, 0x7a,
  0x6f, 0x6e, 0x74, 0x61, 0x6c, 0x20, 0x0, 0x20, 0x44, 0x65, 0x61, 0x64, 0x7a, 0x6f, 0x6e, 0x65, 0x20, 0x0, 0x20,
  0x52, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x49, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x0,
  0x20, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x20, 0x52, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x49, 0x6e, 0x66,
  0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x0, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x20, 0x42,
  0x6f, 0x6f, 0x73, 0x74, 0x20, 0x52, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x0,
  0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20, 0x52, 0x61, 0x64, 0x69,
  0x75, 0x73, 0x20, 0x28, 0x27, 0x73, 0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x27, 0x29, 0x20, 0x0, 0x20,
  0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
  0x20, 0x42, 0x79, 0x20, 0x28, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x29, 0x20, 0x0, 0x20, 0x52, 0x65,
  0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69,
  0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20, 0x52, 0x65, 0x6c, 0x6f, 0x61, 0x64, 0x20, 0x54, 0x69,
  0x6d, 0x65, 0x20, 0x0, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0,
  0x20, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x20, 0x46, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x54,
  0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20,
  0x50, 0x61, 0x6e, 0x69, 0x63, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x56,
  0x61, 0x72, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x0, 0x20, 0x53, 0x68, 0x6f, 0x74, 0x20, 0x54, 0x79, 0x70,
  0x65, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20, 0x44, 0x65,
  0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x20, 0x44, 0x65, 0x6c, 0x61,
  0x79, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x61, 0x70, 0x20, 0x73, 0x68, 0x6f, 0x74, 0x29, 0x20, 0x0,
  0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0, 0x20, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x54,
  0x69, 0x6d, 0x65, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e,
  0x20, 0x0, 0x20, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x20, 0x41, 0x44, 0x53, 0x20, 0x54, 0x79,
  0x70, 0x65, 0x20, 0x0, 0x20, 0x55, 0x6e, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x28, 0x65, 0x78, 0x70, 0x65, 0x72,
  0x69, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x29, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x54, 0x69,
  0x6d, 0x65, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x54, 0x79,
  0x70, 0x65, 0x20, 0x0, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0,
  0x20, 0x43, 0x72, 0x6f, 0x75, 0x63, 0x68, 0x65, 0x64, 0x20, 0x53, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x44,
  0x65, 0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65,
  0x6c, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x20, 0x44,
  0x65, 0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0,
  0x20, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20,
  0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x20, 0x4f,
  0x6e, 0x20, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x20,
  0x54, 0x79, 0x70, 0x65, 0x20, 0x0, 0x20, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0,
  0x20, 0x4c, 0x6f, 0x6f, 0x70, 0x20, 0x4f, 0x6e, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x0, 0x20, 0x4c, 0x6f,
  0x6f, 0x70, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x0, 0x20, 0x4f, 0x6e, 0x63, 0x65, 0x20, 0x2d, 0x20,
  0x53, 0x74, 0x61, 0x6e, 0x64, 0x20, 0x4f, 0x6e, 0x20, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x0,
  0x20, 0x57, 0x61, 0x69, 0x74, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x28, 0x69, 0x64, 0x65, 0x61, 0x6c,
  0x6c, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20,
  0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x29, 0x20, 0x0, 0x20, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x2f, 0x52,
  0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x20, 0x0, 0x20, 0x52, 0x61, 0x6e,
  0x64, 0x6f, 0x6d, 0x69, 0x73, 0x65, 0x20, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x0, 0x20, 0x4c, 0x69,
  0x6d, 0x69, 0x74, 0x20, 0x54, 0x75, 0x72, 0x62, 0x6f, 0x73, 0x20, 0x53, 0x70, 0x65, 0x65, 0x64, 0x20, 0x28,
  0x31, 0x33, 0x2f, 0x73, 0x65, 0x63, 0x29, 0x20, 0x0, 0x20, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x53, 0x69, 0x7a,
  0x65, 0x20, 0x0, 0x20, 0x41, 0x70, 0x65, 0x78, 0x20, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x20, 0x53,
  0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x42, 0x61, 0x73, 0x65, 0x20,
  0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x20, 0x53, 0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x20, 0x54, 0x69, 0x6d,
  0x65, 0x20, 0x0, 0x20, 0x41, 0x70, 0x65, 0x78, 0x20, 0x42, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x20,
  0x53, 0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x42, 0x61, 0x73, 0x65,
  0x20, 0x42, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x20, 0x53, 0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x20, 0x54,
  0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x50, 0x61, 0x75, 0x73, 0x65, 0x20,
  0x54, 0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x45, 0x6e, 0x64, 0x20, 0x50, 0x61, 0x75, 0x73, 0x65, 0x20, 0x54,
  0x69, 0x6d, 0x65, 0x20, 0x0, 0x20, 0x42, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0,
  0x20, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x61, 0x76, 0x65, 0x72, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20,
  0x0, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0, 0x20, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x20, 0x49, 0x6e, 0x74, 0x65,
  0x72, 0x76, 0x61, 0x6c, 0x20, 0x0, 0x20, 0x48, 0x75, 0x65, 0x20, 0x0, 0x20, 0x42, 0x69, 0x67, 0x68, 0x74, 0x6e,
  0x65, 0x73, 0x73, 0x20, 0x0, 0x20, 0x46, 0x58, 0x20, 0x42, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x65, 0x73, 0x73,
  0x20, 0x0, 0x20, 0x4d, 0x65, 0x6e, 0x75, 0x20, 0x42, 0x69, 0x67, 0x68, 0x74, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x0,
  0x20, 0x53, 0x61, 0x74, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x0, 0x20, 0x54, 0x75, 0x72, 0x6e,
  0x20, 0x4f, 0x66, 0x66, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x0, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
  0x74, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x52, 0x65, 0x71, 0x75,
  0x69, 0x72, 0x65, 0x64, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x4d, 0x6f, 0x64, 0x65, 0x20, 0x0, 0x20, 0x52, 0x32,
  0x20, 0x4d, 0x6f, 0x64, 0x65, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x22,
  0x20, 0x0, 0x20, 0x52, 0x32, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x22, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20,
  0x46, 0x6f, 0x72, 0x63, 0x65, 0x20, 0x31, 0x20, 0x0, 0x20, 0x52, 0x32, 0x20, 0x46, 0x6f, 0x72, 0x63, 0x65,
  0x20, 0x31, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x46, 0x6f, 0x72, 0x63, 0x65, 0x20, 0x32, 0x20, 0x0, 0x20, 0x52,
  0x32, 0x20, 0x46, 0x6f, 0x72, 0x63, 0x65, 0x20, 0x32, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x4c, 0x6f, 0x77,
  0x20, 0x53, 0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x28, 0x66, 0x72, 0x65, 0x71, 0x2e, 0x29, 0x20,
  0x0, 0x20, 0x52, 0x32, 0x20, 0x4c, 0x6f, 0x77, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20,
  0x28, 0x66, 0x72, 0x65, 0x71, 0x2e, 0x29, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x4d, 0x69, 0x64, 0x20, 0x53,
  0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x28, 0x66, 0x72, 0x65, 0x71, 0x2e, 0x29, 0x20, 0x0, 0x20,
  0x52, 0x32, 0x20, 0x4d, 0x69, 0x64, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x28, 0x66,
  0x72, 0x65, 0x71, 0x2e, 0x29, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x53, 0x74,
  0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x28, 0x66, 0x72, 0x65, 0x71, 0x2e, 0x29, 0x20, 0x0, 0x20, 0x52,
  0x32, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x28, 0x66,
  0x72, 0x65, 0x71, 0x2e, 0x29, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e,
  0x63, 0x79, 0x20, 0x0, 0x20, 0x52, 0x32, 0x20, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x0,
  0x20, 0x52, 0x32, 0x20, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x4d, 0x61, 0x74, 0x63,
  0x68, 0x65, 0x73, 0x20, 0x52, 0x61, 0x70, 0x69, 0x64, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x54,
  0x61, 0x63, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x20, 0x0, 0x20, 0x4c, 0x65, 0x74, 0x68, 0x61, 0x6c, 0x20, 0x0, 0x20,
  0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x53, 0x70, 0x72, 0x69, 0x6e, 0x74,
  0x2f, 0x46, 0x6f, 0x63, 0x75, 0x73, 0x20, 0x0, 0x20, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x20, 0x0, 0x20, 0x50, 0x69,
  0x6e, 0x67, 0x20, 0x0, 0x20, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6b, 0x20, 0x0, 0x20, 0x4a, 0x75, 0x6d, 0x70, 0x2f,
  0x4d, 0x61, 0x6e, 0x74, 0x6c, 0x65, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x2f, 0x53, 0x6c,
  0x69, 0x64, 0x65, 0x2f, 0x44, 0x69, 0x76, 0x65, 0x20, 0x0, 0x20, 0x52, 0x65, 0x6c, 0x6f, 0x61, 0x64, 0x2f,
  0x49, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x20, 0x0, 0x20, 0x53, 0x77, 0x61, 0x70, 0x2f, 0x41, 0x72,
  0x6d, 0x6f, 0x75, 0x72, 0x20, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x20,
  0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0,
  0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0,
  0x20, 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0,
  0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x41,
  0x44, 0x53, 0x20, 0x26, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x7c, 0x20,
  0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0,
  0x20, 0x4e, 0x6f, 0x6e, 0x65, 0x20, 0x28, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x6f, 0x6e, 0x29, 0x20,
  0x0, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x50, 0x72, 0x65, 0x73,
  0x73, 0x20, 0x41, 0x44, 0x53, 0x20, 0x7c, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20,
  0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20,
  0x0, 0x20, 0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x41, 0x44, 0x53, 0x20, 0x26, 0x20, 0x46, 0x69,
  0x72, 0x65, 0x20, 0x0, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x48, 0x6f,
  0x6c, 0x64, 0x20, 0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x50, 0x61, 0x6e, 0x69, 0x63, 0x20, 0x50, 0x72, 0x65,
  0x73, 0x73, 0x20, 0x28, 0x41, 0x44, 0x53, 0x20, 0x26, 0x20, 0x46, 0x69, 0x72, 0x65, 0x29, 0x20, 0x0, 0x20,
  0x54, 0x61, 0x70, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x28, 0x70, 0x72, 0x69, 0x6d, 0x65, 0x20,
  0x73, 0x68, 0x6f, 0x74, 0x29, 0x20, 0x0, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20,
  0x26, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x46, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x41, 0x44, 0x53,
  0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x4e, 0x6f,
  0x6e, 0x65, 0x20, 0x0, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x26, 0x20, 0x4c,
  0x65, 0x74, 0x68, 0x61, 0x6c, 0x20, 0x0, 0x20, 0x54, 0x75, 0x72, 0x62, 0x6f, 0x20, 0x28, 0x70, 0x72, 0x65,
  0x73, 0x73, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x29, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x28, 0x68,
  0x6f, 0x6c, 0x64, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x29, 0x20, 0x0, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20,
  0x28, 0x74, 0x6f, 0x67, 0x67, 0x6c, 0x65, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x29, 0x20, 0x0, 0x20, 0x43, 0x57,
  0x20, 0x42, 0x6f, 0x6f, 0x73, 0x74, 0x20, 0x45, 0x78, 0x70, 0x6c, 0x6f, 0x69, 0x74, 0x20, 0x28, 0x70, 0x72,
  0x65, 0x73, 0x73, 0x2f, 0x74, 0x6f, 0x67, 0x67, 0x6c, 0x65, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x29, 0x20, 0x0,
  0x20, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x20, 0x0, 0x20, 0x27,
  0x4a, 0x75, 0x6d, 0x70, 0x27, 0x20, 0x28, 0x4d, 0x57, 0x49, 0x49, 0x49, 0x29, 0x20, 0x0, 0x20, 0x4d, 0x57,
  0x49, 0x49, 0x20, 0x0, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x20, 0x0, 0x20, 0x51, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x47,
  0x61, 0x73, 0x70, 0x20, 0x28, 0x4d, 0x57, 0x49, 0x49, 0x2f, 0x32, 0x30, 0x32, 0x32, 0x2b, 0x29, 0x20, 0x0,
  0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x50, 0x61, 0x6e, 0x69,
  0x63, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x28, 0x41, 0x44, 0x53, 0x20, 0x26, 0x20, 0x46, 0x69, 0x72,
  0x65, 0x29, 0x20, 0x0, 0x20, 0x53, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x20, 0x28, 0x66, 0x61, 0x73, 0x74, 0x29,
  0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x0, 0x20, 0x46, 0x69,
  0x72, 0x65, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x26, 0x20, 0x46, 0x69, 0x72, 0x65, 0x20, 0x0, 0x20, 0x4f,
  0x66, 0x66, 0x20, 0x0, 0x20, 0x41, 0x44, 0x53, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x0, 0x20, 0x41, 0x6c, 0x6c,
  0x20, 0x0, 0x20, 0x45, 0x79, 0x65, 0x20, 0x53, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x20, 0x0, 0x20, 0x4e, 0x6f, 0x72,
  0x6d, 0x69, 0x65, 0x20, 0x0, 0x20, 0x54, 0x68, 0x65, 0x20, 0x4c, 0x6f, 0x75, 0x6e, 0x67, 0x65, 0x20, 0x0, 0x20,
  0x4e, 0x6f, 0x6e, 0x65, 0x20, 0x0, 0x20, 0x44, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x20, 0x45, 0x6e, 0x74, 0x65,
  0x72, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x48, 0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x20, 0x0, 0x20,
  0x45, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x48, 0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68,
  0x74, 0x20, 0x0, 0x20, 0x4e, 0x6f, 0x6e, 0x65, 0x20, 0x28, 0x62, 0x6c, 0x61, 0x63, 0x6b, 0x29, 0x20, 0x0, 0x20,
  0x4c, 0x61, 0x73, 0x65, 0x72, 0x73, 0x20, 0x0, 0x20, 0x52, 0x61, 0x69, 0x6e, 0x64, 0x72, 0x6f, 0x70, 0x73,
  0x20, 0x0, 0x20, 0x33, 0x44, 0x20, 0x57, 0x61, 0x76, 0x65, 0x20, 0x28, 0x64, 0x65, 0x74, 0x61, 0x63, 0x68,
  0x65, 0x64, 0x29, 0x20, 0x0, 0x20, 0x43, 0x79, 0x63, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x48, 0x75, 0x65, 0x20, 0x0,
  0x20, 0x42, 0x72, 0x65, 0x61, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x0, 0x20, 0x53, 0x74, 0x61, 0x74, 0x69,
  0x63, 0x20, 0x0, 0x20, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
  0x20, 0x0, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x20, 0x0, 0x20, 0x53, 0x63, 0x72,
  0x69, 0x70, 0x74, 0x20, 0x0, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x20, 0x26,
  0x20, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x20, 0x0, 0x20, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64,
  0x20, 0x0, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x20, 0x0, 0x20, 0x42, 0x6f, 0x77, 0x20, 0x0,
  0x20, 0x4c, 0x69, 0x67, 0x68, 0x74, 0x20, 0x52, 0x65, 0x73, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x20,
  0x0, 0x20, 0x4d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x20, 0x52, 0x65, 0x73, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63,
  0x65, 0x20, 0x0, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x52, 0x65, 0x73, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63,
  0x65, 0x20, 0x0, 0x20, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x0, 0x20, 0x4c, 0x42, 0x20,
  0x0, 0x20, 0x52, 0x42, 0x20, 0x0, 0x20, 0x4c, 0x54, 0x20, 0x0, 0x20, 0x52, 0x54, 0x20, 0x0, 0x20, 0x4c, 0x53,
  0x20, 0x0, 0x20, 0x52, 0x53, 0x20, 0x0, 0x20, 0x55, 0x50, 0x20, 0x0, 0x20, 0x44, 0x4f, 0x57, 0x4e, 0x20, 0x0,
  0x20, 0x4c, 0x45, 0x46, 0x54, 0x20, 0x0, 0x20, 0x52, 0x49, 0x47, 0x48, 0x54, 0x20, 0x0, 0x20, 0x41, 0x20, 0x0,
  0x20, 0x42, 0x20, 0x0, 0x20, 0x58, 0x20, 0x0, 0x20, 0x59, 0x20, 0x0, 0x20, 0x4c, 0x31, 0x20, 0x0, 0x20, 0x52,
  0x31, 0x20, 0x0, 0x20, 0x4c, 0x32, 0x20, 0x0, 0x20, 0x52, 0x32, 0x20, 0x0, 0x20, 0x4c, 0x33, 0x20, 0x0, 0x20,
  0x52, 0x33, 0x20, 0x0, 0x20, 0x55, 0x50, 0x20, 0x0, 0x20, 0x44, 0x4f, 0x57, 0x4e, 0x20, 0x0, 0x20, 0x4c, 0x45,
  0x46, 0x54, 0x20, 0x0, 0x20, 0x52, 0x49, 0x47, 0x48, 0x54, 0x20, 0x0, 0x20, 0x43, 0x52, 0x4f, 0x53, 0x53, 0x20,
  0x0, 0x20, 0x43, 0x49, 0x52, 0x43, 0x4c, 0x45, 0x20, 0x0, 0x20, 0x53, 0x51, 0x55, 0x41, 0x52, 0x45, 0x20, 0x0,
  0x20, 0x54, 0x52, 0x49, 0x41, 0x4e, 0x47, 0x4c, 0x45, 0x20, 0x0, 0x20, 0x4c, 0x20, 0x0, 0x20, 0x52, 0x20, 0x0,
  0x20, 0x5a, 0x4c, 0x20, 0x0, 0x20, 0x5a, 0x52, 0x20, 0x0, 0x20, 0x4c, 0x33, 0x20, 0x0, 0x20, 0x52, 0x33, 0x20,
  0x0, 0x20, 0x55, 0x50, 0x20, 0x0, 0x20, 0x44, 0x4f, 0x57, 0x4e, 0x20, 0x0, 0x20, 0x4c, 0x45, 0x46, 0x54, 0x20,
  0x0, 0x20, 0x52, 0x49, 0x47, 0x48, 0x54, 0x20, 0x0, 0x20, 0x42, 0x20, 0x0, 0x20, 0x41, 0x20, 0x0, 0x20, 0x59,
  0x20, 0x0, 0x20, 0x58, 0x20, 0x0

};

const uint8 Text_Size_Width[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH };

const uint8 DP_Menu_Type_Interval_Time[] = { 32, 216 }

																																																																																																																																																																																													const uint8 Line[]={69,58,31,28,27,8,6,89,13}																																																																																																																																																																																														function putr_oled(f_c,f_p){putc_oled(clamp(f_p,1,8),clamp(f_c,32,128));}

/*
// Polar Aim Assist Abuse

const int16 Cos_Circle_LUT[] = {

  32767,32762,32747,32722,32687,32642,32587,32522,32448,32363,32269,32164,32050,31927,31793,31650,31497,31335,31163,
  30981,30790,30590,30381,30162,29934,29696,29450,29195,28931,28658,28377,28086,27787,27480,27165,26841,26509,26168,
  25820,25464,25100,24729,24350,23964,23570,23169,22761,22347,21925,21497,21062,20620,20173,19719,19259,18794,18323,
  17846,17363,16876,16383,15885,15383,14875,14364,13847,13327,12803,12274,11742,11206,10667,10125,9580,9031,8480,
  7927,7370,6812,6252,5689,5125,4560,3993,3425,2855,2285,1714,1143,571,0,-571,-1143,-1714,-2285,-2855,-3425,-3993,
  -4560,-5125,-5689,-6252,-6812,-7370,-7927,-8480,-9031,-9580,-10125,-10667,-11206,-11742,-12274,-12803,-13327,-13847,
  -14364,-14875,-15383,-15885,-16383,-16876,-17363,-17846,-18323,-18794,-19259,-19719,-20173,-20620,-21062,-21497,
  -21925,-22347,-22761,-23169,-23570,-23964,-24350,-24729,-25100,-25464,-25820,-26168,-26509,-26841,-27165,-27480,
  -27787,-28086,-28377,-28658,-28931,-29195,-29450,-29696,-29934,-30162,-30381,-30590,-30790,-30981,-31163,-31335,
  -31497,-31650,-31793,-31927,-32050,-32164,-32269,-32363,-32448,-32522,-32587,-32642,-32687,-32722,-32747,-32762,
  -32767,-32762,-32747,-32722,-32687,-32642,-32587,-32522,-32448,-32363,-32269,-32164,-32050,-31927,-31793,-31650,
  -31497,-31335,-31163,-30981,-30790,-30590,-30381,-30162,-29934,-29696,-29450,-29195,-28931,-28658,-28377,-28086,
  -27787,-27480,-27165,-26841,-26509,-26168,-25820,-25464,-25100,-24729,-24350,-23964,-23570,-23169,-22761,-22347,
  -21925,-21497,-21062,-20620,-20173,-19719,-19259,-18794,-18323,-17846,-17363,-16876,-16383,-15885,-15383,-14875,
  -14364,-13847,-13327,-12803,-12274,-11742,-11206,-10667,-10125,-9580,-9031,-8480,-7927,-7370,-6812,-6252,-5689,
  -5125,-4560,-3993,-3425,-2855,-2285,-1714,-1143,-571,0,571,1143,1714,2285,2855,3425,3993,4560,5125,5689,6252,6812,
  7370,7927,8480,9031,9580,10125,10667,11206,11742,12274,12803,13327,13847,14364,14875,15383,15885,16383,16876,17363,
  17846,18323,18794,19259,19719,20173,20620,21062,21497,21925,22347,22761,23169,23570,23964,24350,24729,25100,25464,
  25820,26168,26509,26841,27165,27480,27787,28086,28377,28658,28931,29195,29450,29696,29934,30162,30381,30590,30790,
  30981,31163,31335,31497,31650,31793,31927,32050,32164,32269,32363,32448,32522,32587,32642,32687,32722,32747,32762

}
*/



// Display

combo Display_Rapid_Fire_Quick_Toggle {

  dp_screen_sleep_timer = 0;
  cls_oled(OLED_BLACK);
  print(10,12,OLED_FONT_MEDIUM,OLED_WHITE,Title_Strings[2]);
  if(mods[RF_Rapid_Fire_Toggle_Idx])
    print(52,40,OLED_FONT_MEDIUM,OLED_WHITE,Title_Strings[4]);
  else print(48,40,OLED_FONT_MEDIUM,OLED_WHITE,Title_Strings[3]);
  wait(get_rtime());
  wait(2000);
  dp_rapid_fire_quick_toggle_timer = 0;
  reset_screen_sleep_timer();

}



// Persistent Variables

// -- Start of where data is stored
function reset_spvar() {

  pv_current_slot = SPVAR_1;
  pv_current_bit = 0;
  pv_current_value = 0;

}

// -- Function used to count the number of bits used by the given value
function get_bit_count(f_val) {

  pv_temp = 0;  // -- We need to start at 0, we use pv_temp here as we need to track the bits during our loop below

  while(f_val) {
    pv_temp ++;  // -- Increment the bit count by 1
    f_val = abs(f_val >> 1);  // -- Shift the value down 1 bit, once we have no more bits set this will result in 0, unless the value is negative - in which case this will be endless, we do abs here to make it always
  }

  return pv_temp;

}

// -- Function used to count the number of bits used by 2 given values
function get_bit_count2(f_val1, f_val2) {

  pv_temp = max(get_bit_count(f_val1), get_bit_count(f_val2));  // -- Get the highest bit count required for either min or max

  if(is_signed2(f_val1, f_val2))  // -- Check if we need to know if the value is negative or not
    pv_temp ++;  // -- If we need to track if the saved value is negative, we need 1 bit for that specifically - the others are used to store the actual value

  return pv_temp;

}

// -- Function used to determine if either of 2 given values is negative
function is_signed2(f_val1, f_val2) {

  return f_val1 < 0 || f_val2 < 0;

}

// -- Function used to generate a bitmask for the sign bit, this will always be the highest bit in the range we're requesting it for, to do that - we need to start with the lowest bit set and move it up the number of steps there is between 1 and the bits we need, this needs to be a maximum of 31 but can never be negative
function make_sign(f_bits) {

  return 1 << clamp(f_bits - 1, 0, 31);

}

// -- Function used to generate a full bitmask (essentially all bits set up to and including the number of bits given)
function make_full_mask(f_bits) {

  if(f_bits == 32)  // -- If we're wanting a bitmask for all bits, we can simply return -1 (which is all bits set to 1)
    return -1;

  return 0x7FFFFFFF >> (31 - f_bits);  // -- What we do here is basically take a value with all bits except the highest set and shift them down as many times as we need to get a mask that fits the bit count we're looking for

}

// -- Function used to generate a bitmask for just the bits required for the value part of a signed range, this means all the bits below the sign bit
function make_sign_mask(f_bits) {

  return make_full_mask(f_bits - 1);

}
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																								int 																																																																																	dp_tsp																																																																	[																																																																																																																	0																																																																		];
// -- Function used to pack a value that has potential for being negative in a way that we use the least number of bits we really need to represent the value
function pack_i(f_val, f_bits) {

  if(f_val < 0)
    return (abs(f_val) & make_sign_mask(f_bits)) | make_sign(f_bits);  // -- Get the positive version of the value and keep the bits that are within range of what we're doing and add the sign bit since we have a negative value and return the result

  return f_val & make_sign_mask(f_bits);  // -- Get the bits that are within our range

}

// -- Function used to unpack (restore) a value that has potential for being negative, essentially reversing what pack_i does above
function unpack_i(f_val, f_bits) {

  if(f_val & make_sign(f_bits))  // -- Check if the stored value is supposed to ve negative
    return 0 - (f_val & make_sign_mask(f_bits));  // -- Retrieve the stored positive value and subtract it from 0 (resulting in the same value except negative), return the result

  return f_val & make_sign_mask(f_bits);  // -- Retrieve the stored positive value and return it

}

// -- Function used to read the value of a SPVAR without any limits
function read_spvar_slot(f_slot) {

  return get_pvar(f_slot, 0x80000000, 0x7FFFFFFF, 0);

}

// -- Function used to save your value in the SPVARs, this is the function you'll be calling when saving a value. You need to provide the value to save aswell as the range (minimum and maximum value, this is how we determine how many bits to use when saving this value)
function save_spvar(f_val, f_min, f_max) {

  pv_bits = get_bit_count2(f_min, f_max);  // -- Set pv_bits to the number of bits we need for this range

  f_val = clamp(f_val, f_min, f_max);  // -- Make sure the value is within our defined range to begin with

  if(is_signed2(f_min, f_max))  // -- If either min or max is negative, we need to pack this value as a possibly negative value
    f_val = pack_i(f_val, pv_bits);  // -- Pack as signed value (possibly negative)

  f_val = f_val & make_full_mask(pv_bits);  // -- Pack as unsigned value (always positive), this essentially just makes the resulting value not have any extra bits set - it's safe to use after the signed packing since we're not using any bits outside of the unsigned range anyways

  if(pv_bits >= 32 - pv_current_bit) {  // -- Check if there is not enough bits remaining to save this value as-is. if there aren't enough bits, we save what we can here and store the remaining bits in the next spvar, if this means we're hitting the end, we can make this smaller by handling the case where we use all bits here aswell
    pv_current_value = pv_current_value | (f_val << pv_current_bit);  // -- Add what we can to the current value where there is bits available to use
    set_pvar(pv_current_slot, pv_current_value);  // -- Save the current SPVAR before advancing to the next one
    pv_current_slot ++;  // -- Move to the next slot
    pv_bits -= (32 - pv_current_bit);  // -- Update the required bits according to our needs for the next slot, if we don't do this here, we'll screw up the saved value by moving it too far out of range
    f_val = f_val >> (32 - pv_current_bit);  // -- Move the remaining bits down, discarding the bits we've already saved
    pv_current_bit = 0;  // -- Reset the current bit counter since we're starting with a new SPVAR
    pv_current_value = 0;  // -- Reset our value so we start clean, we aren't currently using any bits anyways
  }

  pv_current_value = pv_current_value | (f_val << pv_current_bit);  // -- Merge the current SPVAR value with our currently value where there is space to keep our value

  pv_current_bit += pv_bits;  // -- Move up the counter of next available bit to where we are currently saving data at

  if(!pv_current_bit)
    pv_current_value = 0;  // -- Reset our value so we start clean, we aren't currently using any bits anyways

  set_pvar(pv_current_slot, pv_current_value);  // -- Save the SPVAR with the current value, this won't write anything to flash unless the value changed - so we can do this for each variable saved to no risk missing anything

}

// -- Function used to read your value from the SPVARs, this is the function you'll be calling when reading a value. You need to provide the range (minimum and maximum value, this is how we determine how many bits to use when reading the value)
function read_spvar(f_min, f_max) {

  pv_bits = get_bit_count2(f_min, f_max);  // -- Set pv_bits to the number of bits we need for this range
  pv_current_value = (read_spvar_slot(pv_current_slot) >> pv_current_bit) & make_full_mask(pv_bits);  // -- Read the current SPVAR value from flash and shift them into position, we'll handle split values next

  if(pv_bits >= 32 - pv_current_bit) {  // -- Check if we are dealing with a split SPVAR value, essentially if the current position means we're using more than 32 bits in the SPVAR, we need to retrieve the missing bits from the next SPVAR and put them back to our current value, we use the same space saving trick here as in the save function
    pv_current_value = (pv_current_value & make_full_mask(32 - pv_current_bit)) | ((read_spvar_slot(pv_current_slot + 1) & make_full_mask(pv_bits - (32 - pv_current_bit))) << (32 - pv_current_bit));
    // -- Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
    //pv_temp = read_spvar_slot(pv_current_slot + 1);  // -- Read the SPVAR slot coming after the initial one we used to pv_temp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
    //pv_temp = pv_temp & make_full_mask(pv_bits - (32 - pv_current_bit));  // -- Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
    //pv_temp = pv_temp << (32 - pv_current_bit);  // -- Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
    //pv_current_value = (pv_current_value & make_full_mask(32 - pv_current_bit)) | pv_temp;  // -- put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
  }

  pv_current_bit += pv_bits;  // -- Move up the counter of next available bit to where we are will be reading data from next

  pv_current_value = pv_current_value & make_full_mask(pv_bits);  // -- Extract all bits included for this value and discard any other bits

  if(pv_current_bit >= 32) {
    pv_current_slot ++;  // -- Move to the next SPVAR slot
    pv_current_bit -= 32;  // -- Remove 32 from the pv_current_bit tracker since we've gone beyond what we can do here
  }

  if(is_signed2(f_min, f_max))  // -- Check if the value can be negative and handle it accordingly
    pv_current_value = unpack_i(pv_current_value, pv_bits);  // -- Restore the signed, possibly negative value

  if(pv_current_value < f_min || pv_current_value > f_max)  // -- Check if the value is below our specified min or above our specified max, if so - return the min value
    return f_min;

  // -- Return the retrieved value to the user since it's within the expected range
  return pv_current_value;

}
