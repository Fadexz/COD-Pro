/*




    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ”€  â–ˆâ–ˆâ–ˆâ–ˆâ”€     â–ˆâ–ˆâ–ˆâ–ˆâ”€ â–ˆâ–ˆâ–ˆâ–ˆâ”€    â–ˆâ–ˆâ–ˆâ”€â”€
    â–ˆâ”€     â–ˆâ”€  â–ˆ  â–ˆ   â–ˆâ”€    â–ˆ  â–ˆ  â–ˆ   â–ˆ   â–ˆâ”€  â–ˆ
    â–ˆ      â–ˆ   â–ˆ  â–ˆâ”€  â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€  â–ˆ   â–ˆ
    â–ˆ      â–ˆ   â–ˆ  â–ˆ   â–ˆ     â–ˆâ”€â”€   â–ˆâ”€â”€ â–ˆ   â–ˆ   â–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€  â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€    â–ˆ     â–ˆ   â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ


    v6.0.0 â€” Sep 2023

    By Fadexz




    Features:
    â–ˆ Anti-Recoil (compensates recoil while using rumble/vibration to increase the amount on shots)
    â–ˆ Aim Assist 'Slowdown' Abuse (gives aim assist slowdown while not looking around with stick)
    â–ˆ Steady Aim (reduce aim angles to possibly decrease shaking and increase your accuracy)
    â–ˆ Reload Cancel (automatically cancel reload on 'AIM' and/or 'FIRE')
    â–ˆ Auto Reload (automatically reload after shooting)
    â–ˆ Jump Shot (jump when pressing 'AIM' and 'FIRE' at similar times, or has aim based modes)
    â–ˆ Rapid Fire (turbo for non-auto weapons)
    â–ˆ Auto Focus (automatically focuses / holds breath while aiming)
    â–ˆ Auto Ping (ping when firing, on a specified time of no firing cooldown)
    â–ˆ Aim Assist Snap On Abuse (for ZM/CP aka PvE modes, don't use on PvP modes)
    â–ˆ Quick Scoper (instantly unscopes and removes shot recoil to make quick scoping feel nicer, requires a throwing knife)
    â–ˆ Turbo Jump (spam on hold)
    â–ˆ Turbo Melee (spam on hold)
    â–ˆ Auto Sprint (has press, toggle, and hold options) + Boosted Auto Sprint Mode (exploit for Black Ops Cold War) (these also make the walk area larger by making the sprint area a little tighter than in-game Auto Sprint, requires auto sprint in-game disabled and preferably use hold mode to allow the script to stop the sprinting)
    â–ˆ Slide Cancel (Quickly cancels your slide midway and stands immediately)
    â–ˆ Pickup Cancel (Cancels out the animation of picking up a weapon to almost instantly start being able to use it)
    â–ˆ Swap Cancel (Cancels out the animation of swapping a weapon as soon as the weapon has been swapped, best when both weapons have similar swap times)
    â–ˆ Dropshot (automatically drops to prone when firing then immediately stands afterwards)
    â–ˆ Crouch Shot (automatically crouches when firing)
    â–ˆ "YY" Cancel (fun feature, cancel the swap animation constantly to jitter the animation for a visual effect, may cause delayed aim)
    â–ˆ Hair Triggers (removed trigger deadzone â€” any press is 100% input)
    â–ˆ Crossover Mapping (proper mapping for unmatching controllers and consoles)
    â–ˆ Block Vibration (stop vibration to the controller but allow rumble-based features to still work)
    â–ˆ Cycling Hue LED (customised smoothly cycling through all hues (colours) on the LED)
    â–ˆ Game Button Layout Customisation (map the script to your in-game button layout)
    â–ˆ All other features with combos (or automated input sequences) have the "Input Interval" and "Dynamic VM Timing" to ensure you get faster combos with no added "input delay" (aka normally running at 100hz or 10ms intervals, currently always ensures a 125hz/8ms or 250hz/4ms polling rate regardless of input interval used)



    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€
    â–ˆâ–ˆâ–ˆ Menu â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Enter Menu              >  Fully Hold 'AIM' & Press 'MENU' (Default: LT/L2 & MENU/OPTIONS)     â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Enter Next Menu         >  Press A/CROSS (edit menu - on an adjustable selection)              â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€â”€
    â–ˆ  Exit Current Menu       >  Press B/CIRCLE (saves values to memory when exiting the main menu)  â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Exit Menu               >  Press 'MENU' (Default: MENU/OPTIONS) (won't save to memory)      â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Change Selected Option  >  Press LEFT (previous) or Press RIGHT (next)                         â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Change Selected Value   >  Press UP (increase) or Press DOWN (decrease)                        â–ˆâ”€
    â–ˆ                                                                                                 â–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆ Quick Toggles â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆ                                                                                                 â–ˆ
    â–ˆ  Toggle Rapid Fire       >  Hold 'SCOREBOARD' & Press 'STREAK' (Default: VIEW/TOUCH & RIGHT)    â–ˆâ”€â”€
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆ  Disable Turbo features  >  Hold 'UNUSED' (Default: DOWN) (active while holding)                â–ˆ
    â–ˆ                                                                                                 â–ˆâ”€
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ



    Notes:
    â–ˆ [ Pickup Cancel ]
    â–ˆ With this feature on you may have issues with hold interacting with things, you should not use this feature in modes
    â–ˆ that you need to hold to interact in or if you intend on using them while you play
    â–ˆ
    â–ˆ [ Swap Cancel ]
    â–ˆ This feature doesn't won't benefit weapons that are brought out faster than cancelling the animation would be. For
    â–ˆ this feature, I recommend both weapons being around the same time to swap to or both being not slow as you will need
    â–ˆ to use a speed for the slowest one
    â–ˆ
    â–ˆ [ Potential Conflicts ]
    â–ˆ Currently mostly shot mods that activate when you fire may conflict as it is possible to enable multiple at once,
    â–ˆ Just keep in mind that if they sound like they might interfere with each other they probably will
    â–ˆ (i.e Dropshot, Crouch Shot, Jump Shot, etc.)
    â–ˆ 
    â–ˆ [ LED Brightness ]
    â–ˆ I suggest you lower the brightness level of "Dual Shock 4 Light Bar Brightness" in the Device tab of Zen Studio so
    â–ˆ you don't have to be blind by the Zen's LED (I use 25%), otherwise you can change it further through the menu just
    â–ˆ for this script
    â–ˆ
    â–ˆ [ Defaults ]
    â–ˆ The features selected below under this large comment are what will be enabled or disabled by default, you can change
    â–ˆ them there if you wish, otherwise you can change them later through the menu on the Zen's Screen which will be
    â–ˆ saved to the memory for later use
    â–ˆ
    â–ˆ [ > 60fps ]
    â–ˆ Mainly if on PC and you understand this then be sure to adjust in the menu (under 'Hair Triggers') to whatever your
    â–ˆ max frametime is plus one (e.g (1000ms/100fps) = 10ms, rounded up to even), your frame time or frame rate should not
    â–ˆ drop past this number ever, mainly intended to be changed for higher framerates for faster completion of combo inputs
    â–ˆ If you decide to use this on Modern Warfare / Warzone make sure you use 'PS Remote Play' mode in the Device tab to
    â–ˆ allow for minimum delay between inputs, this will allow you to use 14ms input interval minimum instead of roughly
    â–ˆ 18ms or 20ms that Xbox will allow without inputs being missed
    â–ˆ You may test it to see how low you can get it but the game is strangely inconsistent or slower with some buttons
    â–ˆ (just don't use faster than the game is running at)
    â–ˆ Important: If you experience missed inputs from combos (automated inputs) you should increase this number until it
    â–ˆ stops missing them (like keeping it at 18ms)
    â–ˆ
    â–ˆ [ Cold War ]
    â–ˆ Boosted Auto Sprint is ~3.5% faster than normal sprinting, however I haven't tested in normal gameplay if it still
    â–ˆ has as much of a worthy benefit or if it can be better (might be more of an annoyance than useful)



    Congrats, you now know everything you would need to know about the script, have fun! ðŸ˜œ



    â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”   â€”



    Donate:
    â–ˆ Feel free to support me for the countless hours put into this script, for the few people that do it does help
	â–ˆ motivate me to put more work into scripts and makes my day ðŸ˜Š
    â–ˆ https://www.buymeacoffee.com/Fadexz
    â–ˆ https://paypal.me/Fadexz



    Additonal Notes:
    â–ˆ Please ignore any compile 'empty case' or 'switch' warnings, they are intended
    â–ˆ This script will eventually come to a "complete" state with time, so expect slow but constant updates ðŸ˜Ž
    â–ˆ Please report any issues or suggestions to me, I rarely get any but it would help me improve
    â–ˆ the script with things I couldn't think of!



    Contact me:
    â–ˆ https://discord.com/users/291872132898619392 (fadexz)
    â–ˆ https://forums.cronusmax.com/members/fadexz.356349



    Additional Credits:
    â–ˆ Batts          >  Base value displaying functionality
    â–ˆ DoNotAtMe      >  Aim Assist "Slowdown" Abuse + Steady Aim
    â–ˆ Swizzy         >  Bit-packed spvar saving
    â–ˆ Taylordrift21  >  Based menu from + Anti-Recoil



    To Do (for me):
    â–ˆ Vibration + LED menu only options FX Toggle
    â–ˆ Auto Sprint for Sprint Cancels Reload
    â–ˆ Ez Equipment Cancel??
    â–ˆ Block all output in menu option
    â–ˆ Ez Cook Frag (Tap & Tap To Release) + Suicide Prevention (Throw | Swap)
    â–ˆ Stance Detection
    â–ˆ Notify quick toggle states on screen
    â–ˆ Polar AA disable on fire option
    â–ˆ Akimbo Sync + Akimbo Rapid Fire
    â–ˆ Burst Fire
    â–ˆ Anti-AFK Kick
    â–ˆ Strafe AA
    â–ˆ Quick Reload??
    â–ˆ Mod record time mode
    â–ˆ "Faster" Rapid Fire
    â–ˆ Slot number on start
    â–ˆ Button swap
    â–ˆ Diamond and Star Shape "Aim Assist Abuse"
    â–ˆ Actual Controller Polling Rate Detection
    â–ˆ Display battery level
    â–ˆ Weapon Pickup Mode
    â–ˆ Mouse & Keyboard Menu Support
    â–ˆ Preset Value Loadouts



*/



// -- Declear constants

define

// -- You can change any of the default values below IF you wish the script to start with these values before saving

// Anti-Recoil
AR_Vert_Value = 16,
AR_Hori_Value = 0,
AR_Deadzone = 16,
AR_Rumble_Influence = TRUE,
AR_Reduced_Rumble = FALSE,
AR_Boost_Time = 80,
// Polar Aim Assist Slowdown Abuse
// -- [ 0 = Aim & Fire | 1 = 'Aim | Fire' | 2 = Aim | 3 = Fire | 4 = None ]
AA_Activation_Type = 0,
// -- Line Strength (outer)
AA_Radius = 20,
// -- Line Speed (amount of angles/values skipped through each "vm interval")
AA_Rotate_By_Angles = 18,
AA_Release_Point = 16,
// Steady Aim
// -- Reduce to amount of aim angles (divided) [Range: 2~17]
SA_Angles_Divided = 4,
// Reload Cancel
// -- [ 0 = On Release Aim | 1 = On Release Aim & Fire ]
RC_Release_Activation_Type = 0,
// -- Feel free to set this to ~6000ms for even LMGs, but can't guarantee it won't cause issues with shorter reloads (at max should be a quick YY before aiming or shooting)
RC_Max_Reload_Time_For_Cancel = 1180,
// Auto Reload
// -- [ 0 = On Release Fire | 1 = On Release Fire or Aim ]
AR2_Release_Activation_Type = 1,
AR2_Shoot_Time = 2999,
// Turbo Jump
TJ_Jump_Wait_Time = 0,
// Rapid Fire
// -- [ 0 = On Fire | 1 = On Aim + Fire ]
RF_Activation_Type = 0,
RF_Shot_Wait_Time = 0,
RF_Single_Shot_Time = 100,
// Input Interval
// -- Setting this correctly (mostly for PC) will result in faster input of combos (setting this up incorrectly can cause
// -- missed inputs from the script)
// -- Input Wait Interval Calculation Examples: (1000ms Ã· 60fps) = 18ms (rounded up to even) | (1000/120) = 10ms (rounded
// -- up to even)
// -- If you don't want to calculate, simply use '36' for 29+fps, '18' for 57+fps, '12' for 85+fps, '10' for 101+fps, or
// -- '8' for 126+fps (ensure the game fps is *always* above this minimum fps listed for inputs to not be missed)
// -- Note: 1ms vm time shouldn't be used otherwise it'll add 1ms to the end of combos (last "action" will be 2ms long)
// -- which will slightly slow them down (if the combo only has "two actions" it will take longer 1+1+(1-1)=3, 0 wait time
// -- rounds to 1 which results in the last/second action being repeated twice as long, check combos to understand)
// -- If you wish to use 1ms intervals through the menu then change 'II_Min_Runtime_Interval_Step' above to '1', this will
// -- mean the device will update every 1ms on odd numbers and could be more unstable with higher CPU Usage but this is
// -- done to not add "input delay" as 1 is the only number that is divisible (of 1, 2, 4, or 8)
// -- I personally use '10' for this, I play with 144fps however it is not 100% stable (> 125fps or < 8ms always) so I
// -- just need above 100fps (aka < 10ms frame times) at all times
// -- Note: Changing this could mess up the initial value rounding to this interval
II_Input_Interval = 20,
// Auto Focus
// -- [ 0 = Hold | 1 = MWII Quick Gasp ]
AF_Type = 1,
// Fully Aiming Check
// -- Some weapons can be up to ~450ms
FAC_ADS_Time = 349,
// Rainbow LED
RL_Delay_Interval = 190,
RL_Brightness = 90,
RL_FX_Brightness = 100,
RL_Mod_Menu_Brightness = 70,
RL_Saturation = 100,
// Aim Assist Snap On Abuse
AASO_Aim_Hold_Time = 1490,
// Auto Sprint
// -- [ 0 = Turbo (Press Mode) | 1 = Hold (Hold Mode) | 2 = Press (Toggle/Press Mode) | 3 = BOCW Boosted (Press/Toggle Mode) ]
AS_Type = 0,
// -- Time to disable Auto Sprint after pressing 'STANCE_SLIDE_DIVE' button
AS_Crouch_Prone_Delay_Time = 0,
// Jump Shot
// -- [ 0 = On Press (Aim) | 1 = On Hold (Aim) | 2 = Panic (Aim & Fire) ]
JS_Activation_Type = 2,
// -- Max time between AIM and FIRE presses to activate
JS_Press_Variance_Time = 24,
// Auto Ping
// -- Minimum time (seconds) of not firing for Auto Ping to activate
AP_Min_Release_Activation_Time = 18,
// -- [ 0 = Fully Aiming | 1 = Aiming | 2 = Ignore Aim ]
AP_Activation_Type = 1,
AP_Unping_On_Release = FALSE,
// Slide Cancel
// -- [ 0 = Jump Sprint_Stand Cancel | 1 = Jump | 2 = Sprint_Stand | 3 = MWII Cancel ]
SC_Type = 3,
SC_Cancel_Delay_Time = 150,
// Swap Cancel
SC2_Cancel_Delay_Time = 701,
// Dropshot
// -- [ 0 = On Fire | 1 = Panic (Aim & Fire) ]
DS_Activation_Type = 1,
// -- Max time between AIM and FIRE presses to activate
DS_Press_Variance_Time = 130,
DS_Stand_On_Release = TRUE,
// -- [ 0 = Sprint (Fast) | 1 = Stand ]
DS_Stand_Type = 0,
// Crouch Shot
// -- [ 0 = On AIM | 1 = On FIRE | 2 = On AIM & FIRE ]
CS_Activation_Type = 0,
CS_Loop = TRUE,
CS_Delay_Time = 200,
CS_Once_Release_Stand = TRUE,
// YY Cancel
// -- Delay until ready to cancel again (should be longer than the "Cancel Delay")
YY_Wait_Delay = 100,
// -- Delay between YY inputs
YY_Cancel_Delay = 50,
// Humanise Inputs
// -- [ 0 = Off | 1 = Aim Only | 2 = Everything ]
HI_Randomise_Values = 2,
HI_Limit_Turbos = TRUE,
// Display
// -- [ OLED_FONT_SMALL (0) | OLED_FONT_MEDIUM (1) | OLED_FONT_LARGE (2)
DP_Menu_Font_Size = OLED_FONT_MEDIUM,
// -- Scroll transition speed apex
DP_Forward_Scroll_Time = 3000,
DP_Backward_Scroll_Time = 140,

// -- You can find extra settings here IF you need to change which are not in the menu

// Input Interval
// -- (ADVANCED!) [ 1ms | 2ms | 4ms ] Minimum allowed and step value used for input interval, changing this may in some cases affect CPU usage
II_Min_Runtime_Interval_Step = 2,
// Required Hold Time
// -- Minimum standard time that is counted as a hold in-game, for feature activations
HT_Min_Standard_Game_Hold_Time = 450,
HT_Min_Short_Game_Hold_Time = 150,
// Display
// -- Total lasers on title screen
DP_Amount_Of_Lasers = 10,
// -- Wouldn't recommend lower than '5000' (5 secs) and higher than '120000' (2 mins) to prevent screen burn-in
DP_Screen_Sleep_Time = 60000,
// -- < 1023ms or > 32767ms not recommended (Default: signed 15-bit max (16383))
DP_Max_Large_Time_Based_Value = (1<<14) - 1,
// -- < 511ms or > 16383ms not recommended (Default: signed 12-bit max (2047))
DP_Max_Small_Time_Based_Value = (1<<11) - 1,
// -- Vibration and LED effect activation time
DP_FX_Time = 100,

// Game Button Layout
// -- Stick to Xbox One Button Identifiers (constants) for layout consistency and to not mess up the crossover support (some buttons are not actual equivalents in other layouts)
// -- You should mostly only change the stick axes here if needed
SCOREBOARD = XB1_VIEW,
MENU       = XB1_MENU,
MOVEX      = POLAR_LX,
MOVEY      = POLAR_LY,
LOOKX      = POLAR_RX,
LOOKY      = POLAR_RY,
UNUSED     = XB1_DOWN;  // -- Used for temporarily disabling turbo features (hold to disable them to allow holding of those buttons)



// -- Declear integer variables

int

// -- Adjustable Values
mod[_End_Mod_Plus_One_Idx_],
edit[_End_Edit_Plus_One_Idx_],

// Fully Aiming Check
fac_ads_timer,

// Anti-Recoil
ar_smart_rumble,
ar_strength,
ar_boost_timer,

// Auto Reload
ar2_shoot_timer,

// Polar Aim Assist Abuse
aa_angle,
aa_cos_angle,
aa_sin_angle,
//aa_current_magnitude,
//aa_max_magnitude,

// Steady Aim
sa_angles,
sa_direction,
sa_angle_out,

// Reload Cancel
rc_reloading,
rc_reloading_time,
rc_ar2_did_shoot_before_reload,

// Auto Sprint
as_sc_yyc_in_sprint_area,

// Slide Cancel
sc_stand_btn,

// Auto Ping
ap_can_unping,

// Dropshot
ds_did_dropshot,

// Crouch Shot
cs_crouched,

// YY Cancel
yyc_sprinting,

// Rainbow LED
rl_hue = 120,
rl_timer,

// Crossover Mapping
cf_swap_xb1_share_sync,

// Input Interval
ii_max_controller_polling_rate = 1,
ii_vm_cycle_time,
ii_calc_timing,

// Display
dp_int_to_string_buffer[19],  // -- Note: Should be the length of the longest value string to not overflow into variables after
dp_title = TRUE,
dp_screen_sleep_timer,
dp_display_menu,
dp_menu,
dp_block_options,
dp_main_title_idx,
dp_mod_title_idx,
dp_edit_title_idx,
dp_edit_idx_step,
dp_val_str,
dp_digit_idx,
dp_digits_val,
dp_digit_count_idx,
dp_string_len,
dp_step_timer,
dp_blackout_random,
dp_shift,
dp_laser_x_pos[DP_Amount_Of_Lasers],
dp_laser_y_pos[DP_Amount_Of_Lasers],
dp_laser_speed[DP_Amount_Of_Lasers],
dp_laser_length[DP_Amount_Of_Lasers],
dp_laser_cooldown_timer[DP_Amount_Of_Lasers],
dp_title_display_interval,
dp_input_interval_fps,
dp_input_interval_fps_digit_idx,
dp_round_edit_idx,
dp_selected_string_idx[2],
dp_scroll_timer[2],
dp_scroll_pause_time[2],
dp_text_offset[2],
dp_char_idx,
dp_reverse_offset[2],
dp_text_display_length,
dp_text_size_y_offset,
dp_text_size_width,
dp_string_idx,
dp_cur_array_idx,
dp_cur_string_idx,
dp_string_start_idx[2],
dp_string_length[2],
dp_scroll[2],
dp_is_value,

// Persistent Variables
pv_current_bit,
pv_current_slot,
pv_current_value,
pv_temp,
pv_bits,

// -- Temp Variables
_no_funct_layer_1_temp_,
_no_funct_layer_2_temp_,

// Button Mappings
Input_Layout[_End_Input_Layout_Plus_One_Idx_],
il_input_layout_idx;



// -- Initialise values

init {


  // -- If any Spvar contains a value then load from Spvars
  for(_no_funct_layer_1_temp_ = 64; _no_funct_layer_1_temp_; _no_funct_layer_1_temp_ --) {
    if(get_pvar(SPVAR_64 - (_no_funct_layer_1_temp_ - 1),-1 << 31,(1 << 31) - 1,0)) {
      reset_spvar();
      // -- Load Mod Values (persistent memory)
      for(_no_funct_layer_2_temp_ = 0; _no_funct_layer_2_temp_ < _End_Mod_Plus_One_Idx_; _no_funct_layer_2_temp_ ++) {
        if(_no_funct_layer_2_temp_ < TB_Tactical_Button_Toggle_Idx) {
          if(_no_funct_layer_2_temp_ != DP_Menu_Options_Toggle_Idx)  // -- Unused, skip
            mod[_no_funct_layer_2_temp_] = read_spvar(FALSE,TRUE);
        }
        else mod[_no_funct_layer_2_temp_] = read_spvar(0,13);
      }
      // -- Load Edit Values (persistent memory)
      for(_no_funct_layer_2_temp_ = 0; _no_funct_layer_2_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_2_temp_ ++) {
        if(_no_funct_layer_2_temp_ != RC_Cancel_Method_Edit_Toggle_Idx)  // -- Unused for now, skip
          edit[_no_funct_layer_2_temp_] = read_spvar(Edit_Value_Range[_no_funct_layer_2_temp_][0],Edit_Value_Range[_no_funct_layer_2_temp_][1]);
      }
      reset_screen_sleep_timer();
      // -- [DEBUG] Spvars used
      set_val(TRACE_4,(pv_current_slot - SPVAR_1) + (pv_current_bit > 0));
      set_val(TRACE_5,((pv_current_slot - SPVAR_1) * 32) + pv_current_bit);
      set_val(TRACE_6,pv_current_bit);
      break;
    }
  }
  // -- If it made it to the end (nothing saved / first load)
  if(!_no_funct_layer_1_temp_) {
    // -- Initial enabled mods (only uncomment these if you want these mods to be initially enabled)
    // -- Note: Try put this in an array... or not
    //mod[AR_Anti_Recoil_Toggle_Idx] = TRUE;
    //mod[AA_Polar_Aim_Assist_Abuse_Toggle_Idx] = TRUE;
    //mod[SA_Steady_Aim_Toggle_Idx] = TRUE;
    mod[RC_Reload_Cancel_Toggle_Idx] = TRUE;
    //mod[AR2_Auto_Reload_Toggle_Idx] = TRUE;
    //mod[JS_Jump_Shot_Toggle_Idx] = TRUE;
    //mod[RF_Rapid_Fire_Toggle_Idx] = TRUE;
    //mod[AF_Auto_Focus_Toggle_Idx] = TRUE;
    //mod[AP_Auto_Ping_Toggle_Idx] = TRUE;
    //mod[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx] = TRUE;
    //mod[QS_Quick_Scoper_Toggle_Idx] = TRUE;
    mod[TJ_Turbo_Jump_Toggle_Idx] = TRUE;
    mod[TM_Turbo_Melee_Toggle_Idx] = TRUE;
    //mod[AS_Precise_Auto_Sprint_Toggle_Idx] = TRUE;
    //mod[SC_Slide_Cancel_Toggle_Idx] = TRUE;
    //mod[PAC_Pickup_Cancel_Toggle_Idx] = TRUE;
    //mod[SC2_Swap_Cancel_Toggle_Idx] = TRUE;
    //mod[DS_Dropshot_Toggle_Idx] = TRUE;
    //mod[CS_Crouch_Shot_Toggle_Idx] = TRUE;
    //mod[YYC_YY_Cancel_Toggle_Idx] = TRUE;
    mod[HT_Hair_Triggers_Toggle_Idx] = TRUE;
    mod[HI_Humanise_Inputs_Toggle_Idx] = TRUE;
    mod[CF_Crossover_Fix_Toggle_Idx] = TRUE;
    //mod[BR_Block_Rumble_Toggle_Idx] = TRUE;
    mod[RL_Rainbow_Led_Toggle_Idx] = TRUE;
    // -- Note: When changing these make sure to keep them the same format (only Xbox One inputs)
    // -- Inputs: LB, RB, LT, RT, LS, RS, UP, DOWN, LEFT, RIGHT, A, B, X, Y
    mod[TB_Tactical_Button_Toggle_Idx]            = BTI_LB;
    mod[LB_Lethal_Button_Toggle_Idx]              = BTI_RB;
    mod[AB_Aim_Button_Toggle_Idx]                 = BTI_LT;
    mod[FB_Fire_Button_Toggle_Idx]                = BTI_RT;
    mod[SFB_Sprint_Focus_Button_Toggle_Idx]       = BTI_LS;
    mod[MB_Melee_Button_Toggle_Idx]               = BTI_RS;
    mod[PB_Ping_Button_Toggle_Idx]                = BTI_UP;
    mod[SB_Streak_Button_Toggle_Idx]              = BTI_RIGHT;
    mod[JMB_Jump_Mantle_Button_Toggle_Idx]        = BTI_A;
    mod[SSDB_Stance_Slide_Dive_Button_Toggle_Idx] = BTI_B;
    mod[RIB_Reload_Interact_Button_Toggle_Idx]    = BTI_X;
    mod[SAB_Swap_Armour_Button_Toggle_Idx]        = BTI_Y;
    // -- Set initial edit values
    for(_no_funct_layer_2_temp_ = 0; _no_funct_layer_2_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_2_temp_ ++) {
      edit[_no_funct_layer_2_temp_] = Edit_Value_Range[_no_funct_layer_2_temp_][2];
    }
    // -- Run the first time splash screen
    combo_run(Display_Splash);
  }

  // -- Update max polling rate for current controller
  update_max_polling_rate();
  // -- Get VM Interval Time for timing calculations
  ii_vm_cycle_time = greatest_common_divisor_vm_timing();
  // -- Set VM Interval Time
  vm_tctrl(ii_vm_cycle_time - 10);
  // -- Initialise values
  apply_button_layout();
  sa_angles = 360 / edit[SA_Angles_Divided_Idx];
  // -- Enforce limit on Turbo Jump Time
  if(mod[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx])
    edit[TJ_Jump_Wait_Time_Idx] = max(100 - edit[II_Input_Interval_Idx],edit[II_Input_Interval_Idx]);
  // -- Round initial time-based values
  round_time_based_values();
  // -- Start LED on output ('console') based hue
  switch(get_console()) {
    case PIO_PS3 {}
    case PIO_PS4 {}
    case PIO_PS5 {
      rl_hue = 240;
      // -- Detect mobile LED colour
      if(get_console() == PIO_PS4 && get_led(LED_1) == 2 && get_led(LED_2) == 22 && get_led(LED_3) == 8 && !get_led(LED_4))
        rl_hue = 28;
      break;
    }
    case PIO_SWITCH {
      rl_hue = 0;
    }
  }
  // -- Set a initial delay for lasers
  for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ <= DP_Amount_Of_Lasers; _no_funct_layer_1_temp_ ++) {
    dp_laser_cooldown_timer[_no_funct_layer_1_temp_] = random(104,2504);
  }


}



main {


  // -- Adjust for PS4 Controller Max Polling Rate (4ms/250hz)
  update_max_polling_rate();


  // Display + Persistent Variables

  // -- On Title Screen (outside menu)
  if(dp_title) {

  
    // -- Check and store if is able to sprint
    as_sc_yyc_in_sprint_area = isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) >= 96 && get_ival(MOVEY - 35) <= -72;


    // -- Display Title Screen
    if(dp_screen_sleep_timer) {

      dp_title_display_interval += get_rtime();

      if(dp_title_display_interval >= 8) {

        cls_oled(OLED_BLACK);

        dp_blackout_random = random(0,500);

        if(!random(0,127))
          dp_shift = random(0,2);

        if(dp_blackout_random)
          print(24,24 + dp_shift,OLED_FONT_MEDIUM,OLED_WHITE,Title_Strings[0]);
        if(dp_blackout_random != 1)
          print(40,46 + dp_shift,OLED_FONT_SMALL,OLED_WHITE,Title_Strings[1]);

        if(dp_blackout_random != 2) {
          for(_no_funct_layer_1_temp_ = 1; _no_funct_layer_1_temp_ <= 8; _no_funct_layer_1_temp_ ++) {
            putc_oled(_no_funct_layer_1_temp_,OLED_WIDTH - Line[_no_funct_layer_1_temp_]);
          }
          puts_oled(36,8 + dp_shift,0,8,1);
        }

        for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ <= DP_Amount_Of_Lasers; _no_funct_layer_1_temp_ ++) {
          dp_laser_cooldown_timer[_no_funct_layer_1_temp_] = max(0,dp_laser_cooldown_timer[_no_funct_layer_1_temp_] - get_rtime());
          if(!dp_laser_cooldown_timer[_no_funct_layer_1_temp_]) {
            if(!dp_laser_x_pos[_no_funct_layer_1_temp_]) {
              dp_laser_speed[_no_funct_layer_1_temp_] = 3 + (random(1,7) >= 7);
              dp_laser_y_pos[_no_funct_layer_1_temp_] = random(0,OLED_HEIGHT - 1);
              dp_laser_length[_no_funct_layer_1_temp_] = random(3,12);
            }
            rect_oled(dp_laser_x_pos[_no_funct_layer_1_temp_],dp_laser_y_pos[_no_funct_layer_1_temp_],dp_laser_length[_no_funct_layer_1_temp_],1,OLED_BLACK,OLED_WHITE);
            dp_laser_x_pos[_no_funct_layer_1_temp_] += dp_laser_speed[_no_funct_layer_1_temp_];
            if(dp_laser_x_pos[_no_funct_layer_1_temp_] >= OLED_WIDTH - 1) {
              dp_laser_cooldown_timer[_no_funct_layer_1_temp_] = random(8,2500);
              dp_laser_x_pos[_no_funct_layer_1_temp_] = 0;
            }
          }
        }

        dp_title_display_interval = 0;

      }

    }


    // Hair Triggers

    if(mod[HT_Hair_Triggers_Toggle_Idx])
      deadzone(Input_Layout[IL_Aim_Button_Idx],Input_Layout[IL_Fire_Button_Idx],99,99);


    // Block Rumble (Vibration)

    // -- Note: This needs to be disabled with reset_rumble() but the menu rumble does this anyway, conveniently...
    if(mod[BR_Block_Rumble_Toggle_Idx])
      block_rumble();


    // Auto Focus

    if(mod[AF_Auto_Focus_Toggle_Idx])
      if(fac_ads_timer >= edit[FAC_ADS_Time_Idx]) {
        if(edit[AF_Type_Toggle_Idx])
          combo_run(Quick_Gasp);
        else set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
        if(event_press(Input_Layout[IL_Sprint_Focus_Button_Idx]))
          combo_run(Zoom);
      }
      else {
        combo_stop(Quick_Gasp);
        combo_stop(Zoom);
      }


    // Steady Aim

    if(mod[SA_Steady_Aim_Toggle_Idx]) {
      sa_direction = angle_atan2(get_ival(POLAR_RX),get_ival(POLAR_RY));
      if(get_ival(POLAR_RY) > 0)
        sa_direction = map(0,sa_angles,0,179,(sa_direction * sa_angles) / 180);
      else sa_direction = map(0,sa_angles,179,359,(((sa_direction - 180) * sa_angles) / 180));
      //if(sa_direction < 0)
      //  sa_direction += 360;
      set_val(POLAR_RX,clamp(((icos(sa_direction * 32768/360) * isqrt(pow(get_ival(LOOKX),2) + pow(get_ival(LOOKY),2))) / 32767) + ((mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] >= 1) * random(-130,130)),-32768,32767));
      set_val(POLAR_RY,clamp(((isin(sa_direction * 32768/360) * isqrt(pow(get_ival(LOOKX),2) + pow(get_ival(LOOKY),2))) / 32767) + ((mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] >= 1) * random(-130,130)),-32768,32767));
    }


    // Auto Reload + Reload Cancel

    if((mod[AR2_Auto_Reload_Toggle_Idx] || mod[RC_Reload_Cancel_Toggle_Idx] || mod[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx]) && !get_ival(Input_Layout[IL_Streak_Button_Idx]) && get_brtime(Input_Layout[IL_Streak_Button_Idx]) >= 3000) {
      if(event_press(Input_Layout[IL_Fire_Button_Idx]))
        rc_ar2_did_shoot_before_reload = TRUE;
      if(rc_ar2_did_shoot_before_reload && event_press(Input_Layout[IL_Reload_Interact_Button_Idx])) {
        rc_reloading = TRUE;
        rc_ar2_did_shoot_before_reload = FALSE;
      }
    }


    // Reload Cancel

    if(mod[RC_Reload_Cancel_Toggle_Idx])
      if(rc_reloading) {
        rc_reloading_time += get_rtime();
        // -- Prevented Reload (Revert State)
        // -- Note: Add sprint cancel check
        if(get_ival(Input_Layout[IL_Reload_Interact_Button_Idx]) && get_ptime(Input_Layout[IL_Reload_Interact_Button_Idx]) == ceil_to_multiple(HT_Min_Short_Game_Hold_Time + ii_vm_cycle_time,ii_vm_cycle_time) || event_press(Input_Layout[IL_Swap_Armour_Button_Idx]) || event_press(Input_Layout[IL_Tactical_Button_Idx]) || event_press(Input_Layout[IL_Lethal_Button_Idx]) || event_press(Input_Layout[IL_Streak_Button_Idx])) {
          rc_reloading = FALSE;
          rc_ar2_did_shoot_before_reload = TRUE;
        }
        if(rc_reloading_time > edit[RC_Max_Reload_Time_For_Cancel_Idx])
          rc_reloading = FALSE;
        if(rc_reloading_time && rc_reloading_time <= edit[RC_Max_Reload_Time_For_Cancel_Idx] && (edit[RC_Release_Activation_Type_Toggle_Idx] == 1 && event_press(Input_Layout[IL_Aim_Button_Idx]) || event_press(Input_Layout[IL_Fire_Button_Idx])))
          combo_run(Reload_Cancel);
      }
      else rc_reloading_time = 0;


    // Auto Reload

    if(mod[AR2_Auto_Reload_Toggle_Idx]) {
      if(ar2_shoot_timer >= edit[AR2_Shoot_Time_Idx] && (!edit[AR2_Release_Activation_Type_Toggle_Idx] && event_release(Input_Layout[IL_Fire_Button_Idx])
      || edit[AR2_Release_Activation_Type_Toggle_Idx] == 1 && (rc_ar2_did_shoot_before_reload && !get_ival(Input_Layout[IL_Fire_Button_Idx]) && event_release(Input_Layout[IL_Aim_Button_Idx]) || !get_ival(Input_Layout[IL_Aim_Button_Idx]) && event_release(Input_Layout[IL_Fire_Button_Idx])) && get_brtime(Input_Layout[IL_Streak_Button_Idx]) >= 3000)) {
        combo_run(Auto_Reload);
        ar2_shoot_timer = 0;
        // -- Note: Best to delay this until after 'RELOAD' as been pressed
        //if(mod[RC_Reload_Cancel_Toggle_Idx])
        rc_reloading = TRUE;
      }
      if(get_ival(Input_Layout[IL_Fire_Button_Idx]) && get_brtime(Input_Layout[IL_Streak_Button_Idx]) >= 3000 && !(get_ival(Input_Layout[IL_Tactical_Button_Idx]) || get_ival(Input_Layout[IL_Lethal_Button_Idx]) || combo_running(Turbo_Melee) || combo_running(Pickup_Cancel) || combo_running(Swap_Cancel) || combo_running(Reload_Cancel)))
        ar2_shoot_timer += get_rtime();
    }

    if(mod[RC_Reload_Cancel_Toggle_Idx] && (rc_reloading_time >= edit[RC_Max_Reload_Time_For_Cancel_Idx] || combo_running(Reload_Cancel)) || !mod[RC_Reload_Cancel_Toggle_Idx] && event_press(Input_Layout[IL_Reload_Interact_Button_Idx]))
      ar2_shoot_timer = 0;


    // Quick Scoper

    if(mod[QS_Quick_Scoper_Toggle_Idx])
      if(event_press(Input_Layout[IL_Fire_Button_Idx]) && !(get_ival(Input_Layout[IL_Tactical_Button_Idx]) || get_ival(Input_Layout[IL_Lethal_Button_Idx])))
        combo_run(Quick_Scoper);


    // Auto Ping

    if(mod[AP_Auto_Ping_Toggle_Idx]) {
      if(event_press(Input_Layout[IL_Fire_Button_Idx]) && get_brtime(Input_Layout[IL_Fire_Button_Idx]) >= 1000 * edit[AP_Min_Release_Activation_Time_Idx] && (!edit[AP_Activation_Type_Toggle_Idx] && fac_ads_timer >= edit[FAC_ADS_Time_Idx] || edit[AP_Activation_Type_Toggle_Idx] == 1 && get_ival(Input_Layout[IL_Aim_Button_Idx]) || edit[AP_Activation_Type_Toggle_Idx] == 2))
        combo_run(Auto_Ping);
      if(ap_can_unping) {
        if(isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) >= 16)
          ap_can_unping = FALSE;
        if(rc_ar2_did_shoot_before_reload && event_release(Input_Layout[IL_Fire_Button_Idx]))
          combo_run(Auto_Ping);
        if(combo_current_step(Auto_Ping) == 2) {
          combo_stop(Auto_Ping);
          ap_can_unping = FALSE;
        }
      }
    }


    // Jump Shot

    // -- Note: Add fire modes
    if(mod[JS_Jump_Shot_Toggle_Idx])
      if(!edit[JS_Activation_Type_Toggle_Idx] && event_press(Input_Layout[IL_Aim_Button_Idx]) ||
      edit[JS_Activation_Type_Toggle_Idx] == 1 && get_ival(Input_Layout[IL_Aim_Button_Idx]) ||
      edit[JS_Activation_Type_Toggle_Idx] == 2 && (get_ival(Input_Layout[IL_Aim_Button_Idx]) && get_ptime(Input_Layout[IL_Aim_Button_Idx]) <= edit[JS_Press_Variance_Time_Idx] && event_press(Input_Layout[IL_Fire_Button_Idx]) || get_ival(Input_Layout[IL_Fire_Button_Idx]) && get_ptime(Input_Layout[IL_Fire_Button_Idx]) <= edit[JS_Press_Variance_Time_Idx] && event_press(Input_Layout[IL_Aim_Button_Idx])))
        combo_run(Jump_Shot);


    // Auto Sprint

    // -- Note: Need to improve this disable on crouch method for actual detection
    if(mod[AS_Precise_Auto_Sprint_Toggle_Idx]) {
      if(!(get_ival(Input_Layout[IL_Aim_Button_Idx]) || get_ival(Input_Layout[IL_Stance_Slide_Dive_Button_Idx])) && (get_ptime(Input_Layout[IL_Stance_Slide_Dive_Button_Idx]) >= edit[AS_Crouch_Prone_Delay_Time_Idx] || get_ival(Input_Layout[IL_Sprint_Focus_Button_Idx])) && as_sc_yyc_in_sprint_area && !(combo_running(Cancel_Stand_Slide_Cancel) || combo_running(Stand_Slide_Cancel))) {
        switch(edit[AS_Type_Toggle_Idx]) {
          case 0 {
            combo_run(Auto_Sprint);
            break;
          }
          case 1 {
            set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
            break;
          }
          case 2 {
            if(isqrt(pow(get_lval(MOVEX - 35),2) + pow(get_lval(MOVEY - 35),2)) < 96 || get_lval(MOVEY - 35) > -72)
              combo_run(Auto_Sprint);
            break;
          }
          case 3 {
            combo_run(Boosted_Auto_Sprint);
          }
        }
      }
      else {
        combo_stop(Auto_Sprint);
        combo_stop(Boosted_Auto_Sprint);
      }
    }


    // Turbo Jump

    if(mod[TJ_Turbo_Jump_Toggle_Idx])
      if(turbo_hold(Input_Layout[IL_Jump_Mantle_Button_Idx]))
        combo_run(Turbo_Jump);


    // Turbo Melee

    if(mod[TM_Turbo_Melee_Toggle_Idx])
      if(turbo_hold(Input_Layout[IL_Melee_Button_Idx]))
        combo_run(Turbo_Melee);


    // Slide Cancel

    if(mod[SC_Slide_Cancel_Toggle_Idx]) {
      if(event_press(Input_Layout[IL_Stance_Slide_Dive_Button_Idx]) && as_sc_yyc_in_sprint_area) {
        switch(edit[SC_Type_Toggle_Idx]) {
          case 0 {
            combo_run(Cancel_Stand_Slide_Cancel);
            break;
          }
          case 1 {
            sc_stand_btn = Input_Layout[IL_Stance_Slide_Dive_Button_Idx];
            combo_run(Stand_Slide_Cancel);
            break;
          }
          case 2 {
            sc_stand_btn = Input_Layout[IL_Jump_Mantle_Button_Idx];
            combo_run(Stand_Slide_Cancel);
            break;
          }
          case 3 {
            combo_run(MWII_Slide_Cancel);
          }
        }
        /*
        // -- Note: Add release mode(s)
        if(event_release(Input_Layout[IL_Stance_Slide_Dive_Button_Idx]) && get_ptime(Input_Layout[IL_Stance_Slide_Dive_Button_Idx]) >= HT_Min_Standard_Game_Hold_Time && mod[SC_Slide_Cancel_Toggle_Idx] == 4)
          combo_run(Slide_Cancel_Release_Jump_Stand);
        */
      }
    }


    // Pickup Cancel

    if(mod[PAC_Pickup_Cancel_Toggle_Idx])
      if(get_ival(Input_Layout[IL_Reload_Interact_Button_Idx]) && get_ptime(Input_Layout[IL_Reload_Interact_Button_Idx]) == ceil_to_multiple(HT_Min_Short_Game_Hold_Time + ii_vm_cycle_time,ii_vm_cycle_time))
        combo_run(Pickup_Cancel);


    // Swap Cancel

    if(mod[SC2_Swap_Cancel_Toggle_Idx])
      if(event_release(Input_Layout[IL_Swap_Armour_Button_Idx]) && get_ptime(Input_Layout[IL_Swap_Armour_Button_Idx]) < HT_Min_Standard_Game_Hold_Time && !(get_ival(Input_Layout[IL_Tactical_Button_Idx]) || get_ival(Input_Layout[IL_Lethal_Button_Idx])))
        combo_run(Swap_Cancel);


    // "YY" Cancel
    // -- Note: Maybe this needs to be later or have input in a combo??

    if(mod[YYC_YY_Cancel_Toggle_Idx]) {
      if(!(get_ival(Input_Layout[IL_Aim_Button_Idx]) || get_ival(Input_Layout[IL_Fire_Button_Idx])) && as_sc_yyc_in_sprint_area && (mod[AS_Precise_Auto_Sprint_Toggle_Idx] || event_press(Input_Layout[IL_Sprint_Focus_Button_Idx])))
        yyc_sprinting = TRUE;
      if(yyc_sprinting) {
        if(!as_sc_yyc_in_sprint_area || event_press(Input_Layout[IL_Jump_Mantle_Button_Idx]) || event_press(Input_Layout[IL_Stance_Slide_Dive_Button_Idx]) || event_press(Input_Layout[IL_Reload_Interact_Button_Idx]) || event_press(Input_Layout[IL_Swap_Armour_Button_Idx]) || event_press(Input_Layout[IL_Aim_Button_Idx]) || event_press(Input_Layout[IL_Fire_Button_Idx]) || event_press(Input_Layout[IL_Melee_Button_Idx]) || event_press(Input_Layout[IL_Tactical_Button_Idx]) || event_press(Input_Layout[IL_Lethal_Button_Idx]))
          yyc_sprinting = FALSE;
        else combo_run(YY_Cancel);
      }
      // -- Note: Is this needed for MWII??
      if(yyc_sprinting || combo_running(YY_Cancel))
        set_val(Input_Layout[IL_Aim_Button_Idx],0);
    }


    // Dropshot

    if(mod[DS_Dropshot_Toggle_Idx]) {
      if(!(get_ival(Input_Layout[IL_Tactical_Button_Idx]) || get_ival(Input_Layout[IL_Lethal_Button_Idx])) && (!edit[DS_Activation_Type_Toggle_Idx] && event_press(Input_Layout[IL_Fire_Button_Idx])) ||
      (edit[DS_Activation_Type_Toggle_Idx] && get_ival(Input_Layout[IL_Aim_Button_Idx]) && get_ptime(Input_Layout[IL_Aim_Button_Idx]) <= edit[DS_Press_Variance_Time_Idx] && event_press(Input_Layout[IL_Fire_Button_Idx]) || get_ival(Input_Layout[IL_Fire_Button_Idx]) && get_ptime(Input_Layout[IL_Fire_Button_Idx]) <= edit[DS_Press_Variance_Time_Idx] && event_press(Input_Layout[IL_Aim_Button_Idx]))) {
        combo_run(Dropshot);
        ds_did_dropshot = TRUE;
      }
      // -- Note: Add release aim and fire version
      if(ds_did_dropshot && edit[DS_Stand_On_Release_Toggle_Idx] && event_release(Input_Layout[IL_Fire_Button_Idx])) {
        combo_stop(Dropshot);
        if(edit[DS_Stand_Type_Toggle_Idx])
          combo_run(Stand);
        else combo_run(Sprint_Stand);
        ds_did_dropshot = FALSE;
      }
    }


    // Crouch Shot

    if(mod[CS_Crouch_Shot_Toggle_Idx]) {
      if((!(get_ival(Input_Layout[IL_Tactical_Button_Idx]) || get_ival(Input_Layout[IL_Lethal_Button_Idx])) && (!edit[CS_Activation_Type_Toggle_Idx] && (!edit[CS_Loop_Toggle_Idx] && event_press(Input_Layout[IL_Aim_Button_Idx]) || edit[CS_Loop_Toggle_Idx] && get_ival(Input_Layout[IL_Aim_Button_Idx]))
      || edit[CS_Activation_Type_Toggle_Idx] == 1 && (!edit[CS_Loop_Toggle_Idx] && event_press(Input_Layout[IL_Fire_Button_Idx]) || edit[CS_Loop_Toggle_Idx] && get_ival(Input_Layout[IL_Fire_Button_Idx]))
      || edit[CS_Activation_Type_Toggle_Idx] == 2 && (!edit[CS_Loop_Toggle_Idx] && (get_ival(Input_Layout[IL_Aim_Button_Idx]) && event_press(Input_Layout[IL_Fire_Button_Idx]) || get_ival(Input_Layout[IL_Fire_Button_Idx]) && event_press(Input_Layout[IL_Aim_Button_Idx])) || edit[CS_Loop_Toggle_Idx] && get_ival(Input_Layout[IL_Aim_Button_Idx]) && get_ival(Input_Layout[IL_Fire_Button_Idx]))))) {
        combo_run(Crouch_Shot);
        cs_crouched = TRUE;
      }
      if(!edit[CS_Loop_Toggle_Idx]) {
        // -- Note: Stop at second press in combo
        if(combo_current_step(Crouch_Shot) >= 2)
          combo_stop(Crouch_Shot);
		// -- Release function
        if(cs_crouched && (!edit[CS_Activation_Type_Toggle_Idx] && event_release(Input_Layout[IL_Aim_Button_Idx]) ||
        edit[CS_Activation_Type_Toggle_Idx] == 1 && event_release(Input_Layout[IL_Fire_Button_Idx])) ||
        edit[CS_Activation_Type_Toggle_Idx] == 2 && (!get_ival(Input_Layout[IL_Aim_Button_Idx]) && event_release(Input_Layout[IL_Fire_Button_Idx]) || !get_ival(Input_Layout[IL_Fire_Button_Idx]) && event_release(Input_Layout[IL_Aim_Button_Idx]))) {
          combo_stop(Crouch_Shot);
          combo_run(Crouch_Shot);
          cs_crouched = FALSE;
        }
      }
    }


    // Polar Aim Assist Abuse

    if(mod[AA_Polar_Aim_Assist_Abuse_Toggle_Idx]) {
      //aa_current_magnitude = isqrt(pow(get_ival(LOOKX),2) + pow(get_ival(LOOKY),2));
      //aa_max_magnitude = aa_current_magnitude < 100;
      aa_angle += edit[AA_Rotate_By_Angles_Idx];
      aa_angle %= 360;
      // -- Note: Check over
      if(/*aa_current_magnitude*/ isqrt(pow(get_ival(LOOKX - 35),2) + pow(get_ival(LOOKY - 35),2)) <= edit[AA_Release_Point_Idx] && get_brtime(Input_Layout[IL_Streak_Button_Idx]) >= 3000 &&
      (!edit[AA_Activation_Type_Toggle_Idx] && fac_ads_timer >= edit[FAC_ADS_Time_Idx] && get_ival(Input_Layout[IL_Fire_Button_Idx]) ||
      edit[AA_Activation_Type_Toggle_Idx] == 1 && (fac_ads_timer >= edit[FAC_ADS_Time_Idx] || get_ival(Input_Layout[IL_Fire_Button_Idx])) ||
      edit[AA_Activation_Type_Toggle_Idx] == 2 && fac_ads_timer >= edit[FAC_ADS_Time_Idx] ||
      edit[AA_Activation_Type_Toggle_Idx] == 3 && get_ival(Input_Layout[IL_Fire_Button_Idx]) ||
      edit[AA_Activation_Type_Toggle_Idx] == 4)) {
	    aa_cos_angle = (isin(((aa_angle + 180) % 360) * 32768/360) * edit[AA_Radius_Idx]) / 100;
        aa_sin_angle = (icos(aa_angle * 32768/360) * edit[AA_Radius_Idx]) / 100;
        /*if(aa_current_magnitude <= aa_radius) {*/
          aa_sin_angle -= get_ival(LOOKY);
          aa_cos_angle -= get_ival(LOOKX);
        /*}
        else {
          aa_sin_angle = (aa_sin_angle * (200 - ((abs(get_ival(LOOKY)) + aa_current_magnitude) / 10) * 10) / 200) * aa_max_magnitude;
          aa_cos_angle = (aa_cos_angle * (200 - ((abs(get_ival(LOOKX)) + aa_current_magnitude) / 10) * 10) / 200) * aa_max_magnitude;
        }
        */
        set_val(POLAR_RX,clamp(get_ival(LOOKX) + aa_cos_angle + ((mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] >= 1) * random(-130,130)),-32768,32767));
        set_val(POLAR_RY,clamp(get_ival(LOOKY) + aa_sin_angle + ((mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] >= 1) * random(-130,130)),-32768,32767));
      }
    }


    // Aim Assist Snap On Abuse

    if(mod[AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx])
      if(fac_ads_timer >= edit[FAC_ADS_Time_Idx])
        combo_run(Aim_Assist_Snap_On_Abuse);
      else combo_stop(Aim_Assist_Snap_On_Abuse);


    // Rapid Fire

    if(get_ival(SCOREBOARD)) {
      if(event_press(Input_Layout[IL_Streak_Button_Idx])) {
        mod[RF_Rapid_Fire_Toggle_Idx] = !mod[RF_Rapid_Fire_Toggle_Idx];
        combo_run(Menu_Press_FX);
      }
      set_val(Input_Layout[IL_Streak_Button_Idx],0);
    }

    if(mod[RF_Rapid_Fire_Toggle_Idx])
      if((!edit[RF_Activation_Type_Toggle_Idx] || edit[RF_Activation_Type_Toggle_Idx] == 1 && get_ival(Input_Layout[IL_Aim_Button_Idx])) && get_ival(Input_Layout[IL_Fire_Button_Idx]) && get_ptime(Input_Layout[IL_Fire_Button_Idx]) > edit[RF_Single_Shot_Time_Idx])
        combo_run(Rapid_Fire);


    // Anti-Recoil

    if(mod[AR_Anti_Recoil_Toggle_Idx]) {

      // -- Note: Experiment with fully aimming
      if(/*get_ival(Input_Layout[IL_Aim_Button_Idx])*/ fac_ads_timer >= edit[FAC_ADS_Time_Idx] && get_ival(Input_Layout[IL_Fire_Button_Idx])) {

        if(edit[AR_Rumble_Influence_Toggle_Idx]) {

          if(get_rumble(RUMBLE_B) != 100 && (get_rumble(RUMBLE_A) == 100 || get_rumble(RUMBLE_A) < get_rumble(RUMBLE_B)))
            ar_smart_rumble = get_rumble(RUMBLE_B);
          else ar_smart_rumble = get_rumble(RUMBLE_A);

          if(edit[AR_Reduced_Rumble_Toggle_Idx])
            ar_smart_rumble = ar_smart_rumble * 3 / 5;

          ar_boost_timer += get_rtime();

          if(ar_smart_rumble > 10 && ar_smart_rumble < 90) {
            // -- Initial Boost
            // -- Note: Random here could possibly be a bad idea and cause a stutter (maybe store on FIRE press)
            if(ar_boost_timer < edit[AR_Boost_Time_Idx] /*+ randomise_time()*/) {
              if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4)
                ar_strength = (edit[AR_Vert_Value_Idx] * 2) + (ar_smart_rumble / 4);
              else ar_strength = (edit[AR_Vert_Value_Idx] * 2) + (ar_smart_rumble / 2);
            }
            // -- Normal Strength
            else if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4)
              ar_strength = edit[AR_Vert_Value_Idx] + (ar_smart_rumble / 3);
            else ar_strength = edit[AR_Vert_Value_Idx] + (ar_smart_rumble / 2);
          }

        }
        else {
          // -- Note: Maybe put this in the menu instead
          ar_smart_rumble = 0;
          ar_strength = edit[AR_Vert_Value_Idx];
        }

        deadzone_offset(POLAR_RX,edit[AR_Hori_Value_Idx] * 32767/100);

        // -- Outside Deadzone
        if(isqrt(pow(get_ival(MOVEX - 35),2) + pow(get_ival(MOVEY - 35),2)) > edit[AR_Deadzone_Idx]) {
          if(ar_smart_rumble < 10)
            deadzone_offset(POLAR_RY,(edit[AR_Vert_Value_Idx] + (edit[AR_Deadzone_Idx] * (((edit[AR_Vert_Value_Idx] < 0) * 2) - 1))) * 32767/100);
          else deadzone_offset(POLAR_RY,(ar_strength + (edit[AR_Deadzone_Idx] * (((edit[AR_Vert_Value_Idx] < 0) * 2) - 1))) * 32767/100);
        }
        // -- Inside Deadzone
        else if(ar_smart_rumble < 10)
          deadzone_offset(POLAR_RY,(edit[AR_Vert_Value_Idx] * 32767/100) - get_val(POLAR_RY));
        else deadzone_offset(POLAR_RY,ar_strength * 32767/100);

      }
      else ar_boost_timer = 0;

    }


    // Display

    // -- Display Menu
    if(get_ival(Input_Layout[IL_Aim_Button_Idx]) >= 75) {
      if(event_press(MENU)) {
        combo_stop(Display_Splash);
        dp_title = FALSE;
        dp_display_menu = TRUE;
        vm_tctrl(8 - 10);
        combo_run(Menu_Press_FX);
      }
      set_val(MENU,0);
    }

    // -- Block 'MENU' until released from menu close
    if(dp_block_options) {
      if(event_release(MENU))
        dp_block_options = FALSE;
      set_val(MENU,0);
    }


  }
  // -- When in the menu (not on the Title Screen)
  else {

    // -- Enter menu
    if(event_press(XB1_A)) {
      if(dp_menu == 1 && Edit_Range[dp_mod_title_idx][0] < 255) {
        dp_edit_title_idx = (1 << 31) - 1;
        dp_menu ++;
        dp_display_menu = TRUE;
      }
      if(!dp_menu) {
        dp_mod_title_idx = (1 << 31) - 1;
        dp_menu ++;
        dp_display_menu = TRUE;
      }
    }

    // -- On Main Menu
    switch(dp_menu) {
      case 0 {
        // -- Main Menu Navigation
        if(hold_step(XB1_UP,192) || hold_step(XB1_DOWN,192)) {
          dp_main_title_idx = !dp_main_title_idx;
          dp_display_menu = TRUE;
        }
        dp_main_title_idx = menu_nav(dp_main_title_idx,0,1);
        // -- Exit Menu
        if(event_press(XB1_B)) {
          dp_title = TRUE;
          ii_vm_cycle_time = greatest_common_divisor_vm_timing();
          vm_tctrl(ii_vm_cycle_time - 10);
          reset_spvar();
          // -- Save Mod Values (persistent memory)
          for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < _End_Mod_Plus_One_Idx_; _no_funct_layer_1_temp_ ++) {
            if(_no_funct_layer_1_temp_ < TB_Tactical_Button_Toggle_Idx) {
              if(_no_funct_layer_1_temp_ != DP_Menu_Options_Toggle_Idx)  // -- Unused, skip
                save_spvar(mod[_no_funct_layer_1_temp_],FALSE,TRUE);
            }
            else save_spvar(mod[_no_funct_layer_1_temp_],0,13);
          }
          // -- Save Edit Values (persistent memory)
          for(_no_funct_layer_1_temp_ = 0; _no_funct_layer_1_temp_ < _End_Edit_Plus_One_Idx_; _no_funct_layer_1_temp_ ++) {
            if(_no_funct_layer_1_temp_ != RC_Cancel_Method_Edit_Toggle_Idx)  // -- Unused for now, skip
              save_spvar(edit[_no_funct_layer_1_temp_],Edit_Value_Range[_no_funct_layer_1_temp_][0],Edit_Value_Range[_no_funct_layer_1_temp_][1]);
          }
          reset_screen_sleep_timer();
          combo_run(Menu_Press_FX);
        }
        break;
      }
      // -- On Mod Menu
      case 1 {
        // -- Mod Navigation
        if(dp_main_title_idx)
          dp_mod_title_idx = menu_nav(dp_mod_title_idx,HI_Humanise_Inputs_Toggle_Idx,_End_Mod_Plus_One_Idx_ - 1);
        else dp_mod_title_idx = menu_nav(dp_mod_title_idx,0,HI_Humanise_Inputs_Toggle_Idx - 1);
        // -- Increase Mod Toggle Value
        if(hold_step(XB1_UP,216)) {
          mod[dp_mod_title_idx] ++;
          dp_display_menu = TRUE;
        }
        // -- Decrease Mod Toggle Value
        if(hold_step(XB1_DOWN,216)) {
          mod[dp_mod_title_idx] --;
          dp_display_menu = TRUE;
        }
        if((event_press(XB1_UP) || event_press(XB1_DOWN)) && dp_mod_title_idx != DP_Menu_Options_Toggle_Idx)  // -- Ignore unused mod
          combo_run(Menu_Press_FX);
        // -- Adjust max based on mod
        if(dp_mod_title_idx < TB_Tactical_Button_Toggle_Idx)
          mod[dp_mod_title_idx] = cycle(mod[dp_mod_title_idx],FALSE,TRUE,1);
        else {
          mod[dp_mod_title_idx] = cycle(mod[dp_mod_title_idx],0,13,1);
          // -- Mapping Mods
          /*
          switch(get_controller()) {
            case PIO_XB360 {}
            case PIO_XB1 {
              mod_toggle_print(Xbox_Button_Strings[mod[dp_mod_title_idx]]);
              break;
            }
            case PIO_PS3 {}
            case PIO_PS4 {}
            case PIO_PS5 {
              mod_toggle_print(Playstation_Button_Strings[mod[dp_mod_title_idx]]);
              break;
            }
            case PIO_WII {}
            case PIO_SWITCH {
              mod_toggle_print(Nintendo_Button_Strings[mod[dp_mod_title_idx]]);
              break;
            }
            default {
              switch(get_console()) {
                case PIO_PS3 {}
                case PIO_PS4 {}
                case PIO_PS5 {
                  mod_toggle_print(Playstation_Button_Strings[mod[dp_mod_title_idx]]);
                  break;
                }
                case PIO_SWITCH {
                  mod_toggle_print(Nintendo_Button_Strings[mod[dp_mod_title_idx]]);
                  break;
                }
                default { mod_toggle_print(Xbox_Button_Strings[mod[dp_mod_title_idx]]); }
              }
            }
          }
          */
          apply_button_layout();
        }
        break;
      }
      // -- On Edit Menu
      case 2 {
        // -- Edit Mod Navigation
        dp_edit_title_idx = menu_nav(dp_edit_title_idx,Edit_Range[dp_mod_title_idx][0],Edit_Range[dp_mod_title_idx][1]);
        // -- Step value
        switch(dp_edit_title_idx) {
          // -- For output related times that should be an interval of the game
          case AR_Boost_Time_Idx {}
          case RC_Max_Reload_Time_For_Cancel_Idx {}
          case TJ_Jump_Wait_Time_Idx {}
          case RF_Shot_Wait_Time_Idx {}
          case RF_Single_Shot_Time_Idx {}
          case FAC_ADS_Time_Idx {}
          case AASO_Aim_Hold_Time_Idx {}
          case AS_Crouch_Prone_Delay_Time_Idx {}
          case SC_Cancel_Delay_Time_Idx {}
          case SC2_Cancel_Delay_Time_Idx {}
          case CS_Delay_Time_Idx {}
          case YY_Wait_Delay_Idx {}
          case YY_Cancel_Delay_Idx {
            dp_edit_idx_step = edit[II_Input_Interval_Idx];
            break;
          }
          // -- For controller or non-output related times
          case AR2_Shoot_Time_Idx {}
          case JS_Press_Variance_Time_Idx {}
          case DS_Press_Variance_Time_Idx {}
          case DP_Forward_Scroll_Time_Idx {}
          case DP_Backward_Scroll_Time_Idx {
            dp_edit_idx_step = ii_max_controller_polling_rate;
            break;
          }
          // -- Limit to interval (match interval for runnning in menu)
          case RL_Delay_Interval_Idx {
            dp_edit_idx_step = 8;
            break;
          }
          // -- To step interval of polling rate
          case II_Input_Interval_Idx {
            dp_edit_idx_step = II_Min_Runtime_Interval_Step;
            break;
          }
          default { dp_edit_idx_step = 1; }
        }
        if(hold_step(XB1_UP,DP_Menu_Type_Interval_Time[Edit_Toggle_Value[dp_edit_title_idx]])) {
          edit[dp_edit_title_idx] += dp_edit_idx_step;
          dp_display_menu = TRUE;
        }
        if(hold_step(XB1_DOWN,DP_Menu_Type_Interval_Time[Edit_Toggle_Value[dp_edit_title_idx]])) {
          edit[dp_edit_title_idx] -= dp_edit_idx_step;
          dp_display_menu = TRUE;
        }
        if(event_press(XB1_UP) || event_press(XB1_DOWN))
          combo_run(Menu_Press_FX);
        // -- Apply Edit Toggle Limits
        if(Edit_Toggle_Value[dp_edit_title_idx])
          edit[dp_edit_title_idx] = cycle(edit[dp_edit_title_idx],0,Edit_Toggle_Value[dp_edit_title_idx],1);
        // -- Apply Edit Value Limits
        else {
          if(dp_edit_title_idx == TJ_Jump_Wait_Time_Idx && mod[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx])
            edit[TJ_Jump_Wait_Time_Idx] = cycle(edit[TJ_Jump_Wait_Time_Idx],100 - edit[II_Input_Interval_Idx],Edit_Value_Range[TJ_Jump_Wait_Time_Idx][1],dp_edit_idx_step);
          else edit[dp_edit_title_idx] = cycle(edit[dp_edit_title_idx],Edit_Value_Range[dp_edit_title_idx][0],Edit_Value_Range[dp_edit_title_idx][1],dp_edit_idx_step);
        }
      }

    }

    if(dp_menu)
      for(dp_string_idx = 0; dp_string_idx <= 1; dp_string_idx ++) {
        if(dp_scroll[dp_string_idx]) {
          // -- Count to reach next update
          dp_scroll_timer[dp_string_idx] -= get_rtime();
          // -- Delay until next update
          if(dp_scroll_timer[dp_string_idx] <= 0) {
            // -- Set default delay for forward transition
            dp_scroll_pause_time[dp_string_idx] = max(104,edit[DP_Forward_Scroll_Time_Idx] / dp_string_length[dp_string_idx]);
            // -- Decrement string offset back to 0 (go back to start)
            if(dp_reverse_offset[dp_string_idx]) {
              dp_scroll_pause_time[dp_string_idx] = max(16,edit[DP_Backward_Scroll_Time_Idx] / (dp_string_length[dp_string_idx] / 2));
              dp_text_offset[dp_string_idx] --;
            }
            // -- Increment string offset while ready to increment
            else dp_text_offset[dp_string_idx] ++;
            // -- Draw each character in the visible range with the offset amount from the start offset
            for(dp_char_idx = 1; dp_char_idx <= dp_text_display_length; dp_char_idx ++) {
              // -- Hacky code to make it only display as a value when it is actually a value
              if(dp_is_value && dp_string_idx == 1)
                putc_oled(dp_char_idx,dp_int_to_string_buffer[dp_text_offset[dp_string_idx] + dp_char_idx - 1]);
              else putc_oled(dp_char_idx,Scroll_Strings[dp_string_start_idx[dp_string_idx] + dp_text_offset[dp_string_idx] + dp_char_idx]);
            }
            // -- Draw the visible characters
            puts_oled(1,6 + (dp_string_idx * 26) + dp_text_size_y_offset,edit[DP_Menu_Font_Size_Idx],dp_text_display_length,OLED_WHITE);
            // -- When reached the start offset add a long delay and start offsetting forward
            if(!dp_text_offset[dp_string_idx]) {
              dp_scroll_pause_time[dp_string_idx] = 800;
              dp_reverse_offset[dp_string_idx] = FALSE;
            }
            // -- If the string offset is at the end of the string add a long delay and start offsetting backward
            if(dp_text_offset[dp_string_idx] > dp_string_length[dp_string_idx] - dp_text_display_length) {
              dp_scroll_pause_time[dp_string_idx] = 600;
              dp_reverse_offset[dp_string_idx] = TRUE;
            }
            // -- Reset timer to count again for the next update
            dp_scroll_timer[dp_string_idx] = dp_scroll_pause_time[dp_string_idx];
          }
        }
      }

    // -- Exit menu
    if(event_press(XB1_B) && dp_menu) {
      round_time_based_values();  // -- Adjust time-based values to the current "input interval" multiple when exiting
      // -- Set updated amount of angles (Steady Aim)
      sa_angles = 360 / edit[SA_Angles_Divided_Idx];
      // -- Apply turbo limit if needed
      if(mod[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx])
        edit[TJ_Jump_Wait_Time_Idx] = max(100 - edit[II_Input_Interval_Idx],edit[II_Input_Interval_Idx]);
      dp_menu --;
      dp_display_menu = TRUE;
    }

    if(dp_display_menu) {
      // -- Display Menu Formatting
      cls_oled(OLED_BLACK);
      rect_oled(0,0,OLED_WIDTH,OLED_HEIGHT,OLED_BLACK,OLED_WHITE);
      switch(dp_menu) {
        case 1 {
          dp_selected_string_idx[0] = dp_mod_title_idx;
          if(dp_mod_title_idx < TB_Tactical_Button_Toggle_Idx) {
            if(dp_mod_title_idx != DP_Menu_Options_Toggle_Idx)
              dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + mod[dp_mod_title_idx];
            else dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + 2
          }
          else dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + 2 + 1 + mod[dp_mod_title_idx];
          break;
        }
        case 2 {
          dp_selected_string_idx[0] = _End_Mod_Plus_One_Idx_ + 2 + 1 + 14 + dp_edit_title_idx;
          // -- Note: Maybe check if it is smaller in an array
          switch(dp_edit_title_idx) {
            // -- Standard Off/On Toggle
            case AR_Rumble_Influence_Toggle_Idx {}
            case AR_Reduced_Rumble_Toggle_Idx {}
            case AP_Unping_On_Release_Toggle_Idx {}
            case DS_Stand_On_Release_Toggle_Idx {}
            case CS_Loop_Toggle_Idx {}
            case CS_Once_Release_Stand_Toggle_Idx {}
            case HI_Limit_Turbos_Toggle_Idx {
              dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + edit[dp_edit_title_idx];
              break;
            }
            case AA_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AA_On_Aim_And_Fire_Toggle_String_Idx);
              break;
            }
            case RC_Release_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(RC_On_Fire_Toggle_String_Idx);
              break;
            }
            case AR2_Release_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AR2_On_Fire_Toggle_String_Idx);
              break;
            }
            /*
            // -- Note: Unused for now
            case RC_Cancel_Method_Edit_Toggle_Idx {
              edit_toggle_string_idx(RC_Swap_Toggle_String_Idx);
              break;
            }
            */
            case JS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(JS_On_Press_Aim_Toggle_String_Idx);
              break;
            }
            case RF_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(RF_On_Fire_Toggle_String_Idx);
              break;
            }
            case AP_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(AP_Fully_Aiming_Toggle_String_Idx);
              break;
            }
            case AS_Type_Toggle_Idx {
              edit_toggle_string_idx(AS_Turbo_Press_Toggle_String_Idx);
              break;
            }
            case SC_Type_Toggle_Idx {
              edit_toggle_string_idx(SC_Cancel_Stand_Toggle_String_Idx);
              break;
            }
            case AF_Type_Toggle_Idx {
              edit_toggle_string_idx(AF_Hold_Toggle_String_Idx);
              break;
            }
            case DS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(DS_On_Press_Fire_Toggle_String_Idx);
              break;
            }
            case DS_Stand_Type_Toggle_Idx {
              edit_toggle_string_idx(DS_Sprint_Stand_Toggle_String_Idx);
              break;
            }
            case CS_Activation_Type_Toggle_Idx {
              edit_toggle_string_idx(CS_On_Aim_Toggle_String_Idx);
              break;
            }
            case DP_Menu_Font_Size_Idx {
              edit_toggle_string_idx(DP_Small_Font_Toggle_String_Idx);
              break;
            }
            case HI_Randomise_Values_Toggle_Idx {
              edit_toggle_string_idx(HI_Off_Toggle_String_Idx);
              break;
            }
            default { dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + 2 + 1 + 14 + _End_Edit_Plus_One_Idx_ + dp_edit_title_idx; }
          }
        }
      }
      if(dp_menu) {
        dp_text_size_y_offset = 8 - (4 * edit[DP_Menu_Font_Size_Idx]);
        dp_text_display_length = 8 + (10 * !edit[DP_Menu_Font_Size_Idx]) + (4 * (edit[DP_Menu_Font_Size_Idx] == OLED_FONT_MEDIUM));
        dp_text_size_width = 16 - (9 * !edit[DP_Menu_Font_Size_Idx]) - (5 * (edit[DP_Menu_Font_Size_Idx] == OLED_FONT_MEDIUM));
        for(dp_string_idx = 0; dp_string_idx <= 1; dp_string_idx ++) {
          dp_cur_string_idx = 0;
          dp_string_start_idx[dp_string_idx] = 0;
          dp_scroll_timer[dp_string_idx] = 0;
          dp_scroll_pause_time[dp_string_idx] = 0;
          dp_text_offset[dp_string_idx] = -1;
          dp_reverse_offset[dp_string_idx] = FALSE;
          dp_string_length[dp_string_idx] = 0;
          dp_scroll[dp_string_idx] = FALSE;
          dp_is_value = FALSE;
          // -- Find selected string start and length (end) in array
          for(dp_cur_array_idx = 0; dp_cur_array_idx < sizeof(Scroll_Strings); dp_cur_array_idx ++) {
            // -- Increment string index when have passed '0' value separator
            if(!Scroll_Strings[dp_cur_array_idx]) {
              dp_cur_string_idx ++;
              // -- Check if at selected string start index
              if(dp_cur_string_idx == dp_selected_string_idx[dp_string_idx])
                dp_string_start_idx[dp_string_idx] = dp_cur_array_idx;
              // -- Check if at string end (or next string) index
              if(dp_cur_string_idx == dp_selected_string_idx[dp_string_idx] + 1) {
                dp_string_length[dp_string_idx] = dp_cur_array_idx - dp_string_start_idx[dp_string_idx] - 1;
                break;
              }
            }
          }
          // -- Store Value to ASCII Array (string) for zero length string in array (only for edit menu)
          if(!dp_string_length[dp_string_idx])
            // -- Note: Is more efficient in a function due to referencing a simpler variable
            int_to_string(edit[dp_edit_title_idx],find_digits(edit[dp_edit_title_idx]));
          // -- Display type (dp_scroll / normal centred)
          if(dp_string_length[dp_string_idx] > dp_text_display_length)
            dp_scroll[dp_string_idx] = TRUE;
          else {
            // -- Put constant characters into buffer
            for(dp_char_idx = 1; dp_char_idx <= dp_string_length[dp_string_idx]; dp_char_idx ++) {
              if(dp_is_value)
                putc_oled(dp_char_idx,dp_int_to_string_buffer[dp_char_idx]);
              else putc_oled(dp_char_idx,Scroll_Strings[1 + dp_string_start_idx[dp_string_idx] + dp_char_idx]);
            }
            // -- Draw the characters
            puts_oled(center_text(dp_string_length[dp_string_idx] - 2,dp_text_size_width),6 + (26 * dp_string_idx) + dp_text_size_y_offset,edit[DP_Menu_Font_Size_Idx],dp_string_length[dp_string_idx] - 1,OLED_WHITE);
          }
        }
      }
      // -- Display Main Menu Option Text (just prints over top of above)
      if(!dp_menu) {
        print(center_text(string_len(Main_Menu_Strings[0]),OLED_FONT_MEDIUM_WIDTH),10,OLED_FONT_MEDIUM,dp_main_title_idx,Main_Menu_Strings[0]);
        print(center_text(string_len(Main_Menu_Strings[1]),OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,!dp_main_title_idx,Main_Menu_Strings[1]);
      }
      reset_screen_sleep_timer();
      dp_display_menu = FALSE;
    }

    // -- Display Title Screen
    if(event_press(MENU)) {
      // -- Set updated amount of angles (Steady Aim)
      sa_angles = 360 / edit[SA_Angles_Divided_Idx];
      // -- Apply turbo limit if needed
      if(mod[HI_Humanise_Inputs_Toggle_Idx] && edit[HI_Limit_Turbos_Toggle_Idx])
        edit[TJ_Jump_Wait_Time_Idx] = max(100 - edit[II_Input_Interval_Idx],edit[II_Input_Interval_Idx]);
      // -- Update time-based values to the current interval multiple when exiting the 'input interval' edit menu
      ii_vm_cycle_time = greatest_common_divisor_vm_timing();
      round_time_based_values();
      vm_tctrl(ii_vm_cycle_time - 10);
      dp_title = TRUE;
      dp_block_options = TRUE;
      reset_screen_sleep_timer();
    }
    set_val(MENU,0);

    set_val(XB1_UP,0);
    set_val(XB1_DOWN,0);
    set_val(XB1_LEFT,0);
    set_val(XB1_RIGHT,0);
    set_val(XB1_A,0);
    set_val(XB1_B,0);

  }


  // 'PS4_TOUCH' and 'XB1_VIEW' + 'XB1_SHARE' and 'XB1_SYNC' + 'SWI_CAPTURE' Fix
  // -- (proper support for all controllers - mostly untested, doesn't appear to have any mistakes though ðŸ˜›)
  // -- Note: 'WII_A' and 'WII_B' are swapped from Switch - Check if they perform the same actions or should be swapped for Wii Controller
  if(mod[CF_Crossover_Fix_Toggle_Idx])
    // -- PS4 Controller not on PS4 Output (console)
    if(get_console() != PIO_PS5 && get_console() != PIO_PS4) {
      if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4) {
        swap(PS4_TOUCH,XB1_VIEW);
        // -- Remap 'PS4_SHARE' (now 'PS4_TOUCH') to 'XB1_SHARE' (Button 27) only on Xbox One (output), other consoles/output 'PS4_SHARE' will be left unmapped
        switch(get_console()) {
          case PIO_XB1 {
            swap(PS4_TOUCH,XB1_SHARE);
            break;
          }
          case PIO_SWITCH {
            swap(PS4_TOUCH,SWI_CAPTURE);
          }
        }
      }
    }
    // -- PS4 Output (console) but not using a PS4 Controller
    else {
      if(get_controller() != PIO_PS5 && get_controller() != PIO_PS4)
        swap(PS4_TOUCH,PS4_SHARE);
      if(get_controller() == PIO_SWITCH)
        swap(PS4_TOUCH,SWI_CAPTURE);
      if(get_controller() == PIO_XB1) {
        // -- Enable remap if the SHARE button is used (Series X|S Controller)
        if(event_press(XB1_SHARE))
          cf_swap_xb1_share_sync = TRUE;
        // -- Swap `PS4_SHARE` (now `PS4_TOUCH`) to `XB1_SHARE` (button 27) when on Xbox One (output)
        if(cf_swap_xb1_share_sync) {
          swap(PS4_TOUCH,XB1_SHARE);
          // -- Block input to accelerometer x-axis for other consoles
          set_val(XB1_SYNC,0);
        }
      }
      else cf_swap_xb1_share_sync = FALSE;
    }


  // Fully Aiming Check

  // -- Note: Test - Reset aim state when detected is reloading or swapping
  if((mod[RC_Reload_Cancel_Toggle_Idx] && rc_reloading) || combo_running(Reload_Cancel) || get_brtime(Input_Layout[IL_Swap_Armour_Button_Idx]) < edit[FAC_ADS_Time_Idx])
    fac_ads_timer = 0;
  else {
    if(get_ival(Input_Layout[IL_Aim_Button_Idx]))
      fac_ads_timer += get_rtime();
    else fac_ads_timer -= get_rtime();
    fac_ads_timer = clamp(fac_ads_timer,0,edit[FAC_ADS_Time_Idx]);
  }


  // Rainbow LED

  // -- Note: Add default (reset) mode and do console pulsate ðŸ˜Ž
  // -- Note: Maybe look into reducing CPU

  if(mod[RL_Rainbow_Led_Toggle_Idx]) {
    rl_timer += get_rtime();
    if(rl_timer >= edit[RL_Delay_Interval_Idx]) {
      rl_hue ++;
      if(rl_hue >= 360)
        rl_hue = 0;
      rl_timer = 0;
    }
    if(dp_title)
      set_hsb(rl_hue,edit[RL_Saturation_Idx],edit[RL_Brightness_Idx]);
    else {
      set_hsb(rl_hue,edit[RL_Saturation_Idx],edit[RL_Mod_Menu_Brightness_Idx]);
      // -- Note: This better off in the edit function??
      if(dp_menu == 2)
        switch(dp_edit_title_idx) {
          case RL_Brightness_Idx {
            set_hsb(rl_hue,edit[RL_Saturation_Idx],edit[RL_Brightness_Idx]);
            break;
          }
          case RL_FX_Brightness_Idx {
            set_hsb(rl_hue,edit[RL_Saturation_Idx],edit[RL_FX_Brightness_Idx]);
          }
        }
    }
  }
  else set_led(LED_1,0);


  // Display

  if(dp_screen_sleep_timer) {
    dp_screen_sleep_timer = max(0,dp_screen_sleep_timer - get_rtime());
    if(!dp_screen_sleep_timer) {
      dp_title = TRUE;
      dp_display_menu = FALSE;
      cls_oled(OLED_BLACK);
      ii_vm_cycle_time = greatest_common_divisor_vm_timing();
      vm_tctrl(ii_vm_cycle_time - 10);
    }
  }


  // -- [DEBUG]
  //set_val(TRACE_3,fac_ads_timer);
  //get_info(CPU_USAGE);

}



// Reload Cancel

combo Reload_Cancel {

  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(max(24,edit[II_Input_Interval_Idx]) + randomise_time());
  wait(max(24,edit[II_Input_Interval_Idx]) + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(max(24,edit[II_Input_Interval_Idx]) + randomise_time());
  // -- Fixed??
  rc_reloading = FALSE;
  wait(get_rtime());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Auto Reload

combo Auto_Reload {

  set_val(Input_Layout[IL_Reload_Interact_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  // -- Note: This line may be causing a bug with 'Reload Cancel'
  // -- Fixed or kinda shiet??
  rc_ar2_did_shoot_before_reload = FALSE;
  wait(get_rtime());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Quick Scoper

combo Quick_Scoper {

  set_val(Input_Layout[IL_Lethal_Button_Idx],100);
  wait(110 + randomise_time());
  set_val(Input_Layout[IL_Lethal_Button_Idx],100);
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(max(36,edit[II_Input_Interval_Idx]) + randomise_time());
  wait(300 + randomise_time());
  set_val(Input_Layout[IL_Aim_Button_Idx],100);
  wait(max(36,edit[II_Input_Interval_Idx]) + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Auto Ping

combo Auto_Ping {

  set_val(Input_Layout[IL_Ping_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Ping_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  if(edit[AP_Unping_On_Release_Toggle_Idx])
    ap_can_unping = TRUE;
  wait(get_rtime());
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());

}



// Jump Shot

combo Jump_Shot {

  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());

}



// Auto Focus

combo Quick_Gasp {

  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
  wait(floor_to_multiple(2998,edit[II_Input_Interval_Idx]) - randomise_time());
  wait(950 + randomise_time() - get_rtime());

}

combo Zoom {

  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],0);
  wait(max(18,edit[II_Input_Interval_Idx]) + randomise_time());
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
  wait(max(18,edit[II_Input_Interval_Idx]) + randomise_time());
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],0);
  wait(max(18,edit[II_Input_Interval_Idx]) + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],0);

}



// Auto Sprint

combo Auto_Sprint {

  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
  wait(max(20,edit[II_Input_Interval_Idx]) + randomise_time());  // -- Note: Fix for MW/WZ
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],0);
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],0);

}

combo Boosted_Auto_Sprint {

  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(1000 + randomise_time());
  set_val(MOVEY,0);
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());
  set_val(MOVEY,0);

}



// Turbo Jump

combo Turbo_Jump {

  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],get_ival(Input_Layout[IL_Jump_Mantle_Button_Idx]));
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],0);
  wait(edit[TJ_Jump_Wait_Time_Idx] + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],0);

}



// Pickup Cancel

combo Pickup_Cancel {

  wait(260);
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Swap Cancel

combo Swap_Cancel {

  wait(edit[SC2_Cancel_Delay_Time_Idx] + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// YY Cancel

combo YY_Cancel {

  wait(YY_Wait_Delay + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(YY_Cancel_Delay + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());

}



// Dropshot

combo Dropshot {

  set_val(MOVEY,0);
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(HT_Min_Standard_Game_Hold_Time + 100 + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}

combo Sprint_Stand {

  set_val(Input_Layout[IL_Aim_Button_Idx],0);
  set_val(Input_Layout[IL_Fire_Button_Idx],0);
  set_val(MOVEY,-100);
  set_val(Input_Layout[IL_Sprint_Focus_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}

combo Stand {

  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Crouch Shot

combo Crouch_Shot {

  if(edit[CS_Activation_Type_Toggle_Idx] == 1)
    set_val(MOVEY,0);
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  if(edit[CS_Activation_Type_Toggle_Idx] == 1)
    set_val(MOVEY,0);
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[CS_Delay_Time_Idx] + randomise_time() - get_rtime());

}



// Turbo Melee

combo Turbo_Melee {

  set_val(Input_Layout[IL_Melee_Button_Idx],get_ival(Input_Layout[IL_Melee_Button_Idx]));
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Melee_Button_Idx],0);
  wait(edit[II_Input_Interval_Idx] + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Melee_Button_Idx],0);

}



// Aim Assist Snap On Abuse

combo Aim_Assist_Snap_On_Abuse {

  set_val(Input_Layout[IL_Aim_Button_Idx],0);
  wait(edit[II_Input_Interval_Idx]/* * 2*/ + randomise_time());
  set_val(Input_Layout[IL_Aim_Button_Idx],100);
  wait(edit[AASO_Aim_Hold_Time_Idx] + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Aim_Button_Idx],100);

}



// Slide Cancel

combo Cancel_Stand_Slide_Cancel {

  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(HT_Min_Short_Game_Hold_Time + randomise_time());
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],0);
  wait(edit[CS_Delay_Time_Idx] + randomise_time());
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(max(36,edit[II_Input_Interval_Idx]) + randomise_time());  // -- Note: Extra time for BOCW (fix)
  set_val(Input_Layout[IL_Jump_Mantle_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}

combo Stand_Slide_Cancel {

  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(HT_Min_Short_Game_Hold_Time + randomise_time());
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],0);
  wait(edit[CS_Delay_Time_Idx] + randomise_time());
  set_val(sc_stand_btn,100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}

combo MWII_Slide_Cancel {

  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(HT_Min_Short_Game_Hold_Time + randomise_time());
  wait(edit[CS_Delay_Time_Idx] + randomise_time());
  set_val(Input_Layout[IL_Aim_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Swap_Armour_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(920 - edit[CS_Delay_Time_Idx] - (edit[II_Input_Interval_Idx] * 4) + randomise_time());
  set_val(Input_Layout[IL_Stance_Slide_Dive_Button_Idx],100);
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  wait(edit[II_Input_Interval_Idx] - get_rtime());

}



// Rapid Fire

combo Rapid_Fire {

  set_val(Input_Layout[IL_Fire_Button_Idx],get_ival(Input_Layout[IL_Fire_Button_Idx]));
  wait(edit[II_Input_Interval_Idx] + randomise_time());
  set_val(Input_Layout[IL_Fire_Button_Idx],0);
  wait(edit[RF_Shot_Wait_Time_Idx] + randomise_time() - get_rtime());
  set_val(Input_Layout[IL_Fire_Button_Idx],0);

}



// Display

combo Menu_Press_FX {

  set_rumble(RUMBLE_B,100);
  set_rumble(RUMBLE_LT,5);
  set_rumble(RUMBLE_RT,5);
  if(mod[RL_Rainbow_Led_Toggle_Idx])
    set_hsb(rl_hue,edit[RL_Saturation_Idx],edit[RL_FX_Brightness_Idx]);
  wait(DP_FX_Time);
  reset_rumble();
  // -- Note: Need for switching to default LED later
  //reset_leds();

}

combo Display_Splash {

  cls_oled(OLED_WHITE);
  print_splash_text(0,24);
  wait(get_rtime());
  wait(1400);

  // -- Note: Buttons are hardcoded, which should be fine
  cls_oled(OLED_WHITE);
  switch(get_controller()) {
    case PIO_XB360 {}
    case PIO_XB1 {
      print_splash_text(1,24);
      break;
    }
    case PIO_PS3 {}
    case PIO_PS4 {}
    case PIO_PS5 {
      print_splash_text(2,14);
      print_splash_text(3,34);
      break;
    }
    case PIO_WII {}
    case PIO_SWITCH {
      print_splash_text(4,24);
      break;
    }
    default {
      switch(get_console()) {
        case PIO_PS3 {}
        case PIO_PS4 {}
        case PIO_PS5 {
          print_splash_text(2,14);
          print_splash_text(3,34);
          break;
        }
        case PIO_SWITCH {
          print_splash_text(4,24);
          break;
        }
        default { print_splash_text(1,24); }
      }
    }
  }
  wait(get_rtime());
  wait(2600);
  
  reset_screen_sleep_timer();

}



// Anti-Recoil

function deadzone_offset(f_stick,f_value) {

  set_val(f_stick, clamp((f_value + ((mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] >= 1) * random(-130,130))) * (32767 - abs(get_val(f_stick))) / 32767 + get_val(f_stick), -32768, 32767));

}



// Steady Aim

// -- Calculate current angle (with 360 angles and high accuracy)
function angle_atan2(f_x,f_y) {

  if(f_x >= 0 && f_y > 0)
    sa_angle_out = -90000;
  else if(f_x < 0 && f_y >= 0)
    sa_angle_out = 90000;
  else if(f_x <= 0 && f_y < 0)
    sa_angle_out = -270000;
  else sa_angle_out = 270000;

  f_x = abs(f_x);
  f_y = abs(f_y);

  if(f_x < f_y)
    sa_angle_out += (f_x * 45000 / f_y);
  else if(f_x > f_y)
    sa_angle_out += 90000 - (f_y * 45000 / f_x);
  else sa_angle_out += 45000;

  return abs(sa_angle_out) / 1000;

}

// -- Scale range
function map(f_in_min,f_in_max,f_out_min,f_out_max,f_x) {

  return (f_x - f_in_min) * (f_out_max - f_out_min) / (f_in_max - f_in_min) + f_out_min;

}



// Turbo Jump + Turbo Melee

function turbo_hold(f_btn) {

  return get_ival(f_btn) && get_ptime(f_btn) >= HT_Min_Standard_Game_Hold_Time && !(get_val(UNUSED) && get_ptime(UNUSED) >= HT_Min_Standard_Game_Hold_Time);

}



// Display

function edit_toggle_string_idx(f_string_offset) {

  dp_selected_string_idx[1] = _End_Mod_Plus_One_Idx_ + 2 + 1 + 14 + _End_Edit_Plus_One_Idx_ + _End_Edit_Plus_One_Idx_ + f_string_offset + edit[dp_edit_title_idx];

}

function menu_nav(f_index,f_min,f_max) {

  // -- Previous value
  if(hold_step(XB1_LEFT,72)) {
    f_index --;
    dp_display_menu = TRUE;
  }
  // -- Next value
  if(hold_step(XB1_RIGHT,72)) {
    f_index ++;
    dp_display_menu = TRUE;
  }

  return cycle(f_index,f_min,f_max,1);

}

// -- Button hold repeat interval
// -- Note: Optimise
function hold_step(f_btn,f_step_interval) {

  if(event_press(f_btn)) {
    dp_step_timer = 0;
    return TRUE;
  }

  if(get_ival(f_btn) && get_ptime(f_btn) >= 350) {
    dp_step_timer += get_rtime();
    if(get_ptime(f_btn) < 4000) {
      if(dp_step_timer >= f_step_interval) {
        dp_step_timer = 0;
        return TRUE;
      }
    }
    else if(dp_step_timer >= f_step_interval / (2 + (f_step_interval <= 64))) {
      dp_step_timer = 0;
      return TRUE;
    }
  }

  // -- Note: Check if need to reset the timer
  return FALSE;

}

// -- Loop back values
function cycle(f_val,f_min,f_max,f_interval) {

  if(f_val > f_max)
    return ceil_to_multiple(f_min,f_interval);

  if(f_val < f_min)
    return floor_to_multiple(f_max,f_interval);

  return f_val;

}

// -- Round to the nearest multiple of a number (positive)
function round_to_multiple(f_num,f_multiple) {

  if(f_num < f_multiple)
    return f_multiple;

  if(f_num % f_multiple > (f_multiple / 2) + (f_multiple % 2))
    return f_num - (f_num % f_multiple) + f_multiple;
  else return f_num - (f_num % f_multiple);

  return f_num;

}

// -- Round up to the nearest multiple of a number (positive)
function ceil_to_multiple(f_num,f_multiple) {

  if(f_num % f_multiple)
    return f_num + f_multiple - (f_num % f_multiple)

  return f_num;

}

// -- Round down to the nearest multiple of a number (positive)
function floor_to_multiple(f_num,f_multiple) {

  return (f_num / f_multiple) * f_multiple;

}

// -- Change the max interval (or limit) that will be used for inputs (will ONLY use less than 8ms (125hz) for PS4/PS5 Controllers)
// -- Note: Adjust for PS3 Controller (100hz) + Xbox Bluetooth (option), or try detection method instead
function update_max_polling_rate() {

  if(get_controller() == PIO_PS5 || get_controller() == PIO_PS4) {
    if(ii_max_controller_polling_rate != 4) {
      ii_max_controller_polling_rate = 4;
      round_time_based_values();
    }
  }
  else if(get_controller() && ii_max_controller_polling_rate < 8) {
    ii_max_controller_polling_rate = 8;
    round_time_based_values();
  }

}

// -- Greatest common number from 8, 4, 2 and 1 that can fit in both the controller polling rate and input interval for vm timing
function greatest_common_divisor_vm_timing() {

  // -- Ensure the VM Timing is half the Input Interval so that the combo last loop "time removal" is not affected (no zero rounded wait time)
  switch(edit[II_Input_Interval_Idx]) {
    case 8 {}
    case 4 {}
    case 2 {
      return edit[II_Input_Interval_Idx] / 2;
    }
  }

  ii_calc_timing = edit[II_Input_Interval_Idx] % 8;

  if(ii_calc_timing >= 2 || ii_max_controller_polling_rate < 8 && !ii_calc_timing) {
    if(ii_max_controller_polling_rate >= 4 && !(ii_calc_timing % 4))
      return 4;
    if(ii_max_controller_polling_rate >= 2 && !(ii_calc_timing % 2))
      return 2;
  }

  if(ii_max_controller_polling_rate >= 8 && !ii_calc_timing)
    return 8;

  return 1;

}

// -- Reset the screen sleep timer (countdown) to the beginning
function reset_screen_sleep_timer() {

  dp_screen_sleep_timer = DP_Screen_Sleep_Time;

}

// -- Calculate length of a string
function string_len(f_index) {

  dp_string_len = 0;

  do {
    dp_string_len ++;
    f_index ++;
  }
  while(duint8(f_index));

  return dp_string_len;

}

// -- Center the text on screen widthways
function center_text(f_chars,f_char_width) {

  return (OLED_WIDTH / 2) - ((f_char_width * f_chars) / 2);

}

// -- Print splash screen text
function print_splash_text(f_index,f_height) {

  print(center_text(string_len(Splash_Strings[f_index]),OLED_FONT_MEDIUM_WIDTH),f_height,OLED_FONT_MEDIUM,OLED_BLACK,Splash_Strings[f_index]);

}

// -- Convert number to string value
// -- Note: Limited to 5 digits max
function int_to_string(f_value,f_digits) {

  dp_val_str = 1;
  dp_digits_val = 10000/*0000*/;

  // -- Add "-" (minus)
  if(f_value < 0) {
    buffer_char(ASCII_MINUS);
    f_value = abs(f_value);
  }

  switch(dp_edit_title_idx) {
    // -- Add "+ "
    case AA_Rotate_By_Angles_Idx {
      buffer_char(ASCII_PLUS);
      buffer_char(ASCII_SPACE);
      break;
    }
    // -- Add "/ "
    case SA_Angles_Divided_Idx {
      buffer_char(ASCII_DIGIT3);
      buffer_char(ASCII_DIGIT6);
      buffer_char(ASCII_DIGIT0);
      buffer_char(ASCII_SPACE);
      buffer_char(ASCII_SLASH);
      buffer_char(ASCII_SPACE);
    }
  }

  // -- Convert digits to ASCII

  for(dp_digit_idx = 5 /*9*/; dp_digit_idx; dp_digit_idx --) {

    if(f_digits >= dp_digit_idx) {

      buffer_char(ASCII_DIGIT0 + (f_value / dp_digits_val));

      if(dp_digit_idx == 1) {
        switch(Edit_Value_Text_Type[dp_edit_title_idx]) {
          // -- Add " sec"
          case EVTT_Sec {
            buffer_char(ASCII_SPACE);
            buffer_char(ASCII_LOWER_S);
            buffer_char(ASCII_LOWER_E);
            buffer_char(ASCII_LOWER_C);
            if(abs(f_value) != 1 || f_digits != 1)
              buffer_char(ASCII_LOWER_S);
            break;
          }
          // -- Add " ms"
          case EVTT_MS {
            buffer_char(ASCII_SPACE);
            buffer_char(ASCII_LOWER_M);
            buffer_char(ASCII_LOWER_S);
            break;
          }
          // -- Add fps conversion ('ms (___fps min)')
          case EVTT_FPS {
            buffer_char(ASCII_LOWER_M);
            buffer_char(ASCII_LOWER_S);
            buffer_char(ASCII_SPACE);
            buffer_char(ASCII_OPEN_PARENTHESIS);
            // -- Calculate fps and round up number if there is any remainder
            dp_input_interval_fps = (1000 * 2147483) / (edit[II_Input_Interval_Idx] * 2147483);
            if((1000 * 2147483) % (edit[II_Input_Interval_Idx] * 2147483))
              dp_input_interval_fps ++;
            // -- Display fps digits
            for(dp_input_interval_fps_digit_idx = find_digits(dp_input_interval_fps); dp_input_interval_fps_digit_idx; dp_input_interval_fps_digit_idx --) {
              buffer_char(ASCII_DIGIT0 + (dp_input_interval_fps / pow(10,dp_input_interval_fps_digit_idx - 1) % 10));
            }
            buffer_char(ASCII_LOWER_F);
            buffer_char(ASCII_LOWER_P);
            buffer_char(ASCII_LOWER_S);
            buffer_char(ASCII_SPACE);
            buffer_char(ASCII_LOWER_M);
            buffer_char(ASCII_LOWER_I);
            buffer_char(ASCII_LOWER_N);
            buffer_char(ASCII_CLOSE_PARENTHESIS);
            break;
          }
          // -- Add " %"
          case EVTT_Percentage {
            buffer_char(ASCII_SPACE);
            buffer_char(ASCII_PERCENT);
          }
        }
      }

      f_value %= dp_digits_val;

    }

    dp_digits_val /= 10;

  }

  dp_int_to_string_buffer[0] = ASCII_SPACE;
  dp_int_to_string_buffer[dp_val_str] = ASCII_SPACE;
  dp_string_length[dp_string_idx] = dp_val_str + 1;
  dp_is_value = TRUE;

}

// -- Add ASCII Character To Buffer
function buffer_char(f_char) {

  dp_int_to_string_buffer[dp_val_str] = f_char;
  dp_val_str ++;

}

// -- Calculate number of digits for length
// -- Note: Used once, remove function??
function find_digits(f_num) {

  dp_digit_count_idx = 0;

  do {
    dp_digit_count_idx ++;
    f_num /= 10;
  }
  while(f_num);

  return dp_digit_count_idx;

}

// -- Round all times values to of a e.g input interval multiple
function round_time_based_values() {

  // -- Round first lot to input interval then second lot to max controller polling rate
  for(dp_round_edit_idx = 0; dp_round_edit_idx < sizeof(Round_Edit); dp_round_edit_idx ++) {
    if(dp_round_edit_idx < sizeof(Round_Edit) - 4)
      edit[Round_Edit[dp_round_edit_idx]] = round_to_multiple(edit[Round_Edit[dp_round_edit_idx]],edit[II_Input_Interval_Idx]);
    else edit[Round_Edit[dp_round_edit_idx]] = round_to_multiple(edit[Round_Edit[dp_round_edit_idx]],ii_max_controller_polling_rate);
  }

  edit[AASO_Aim_Hold_Time_Idx] = ceil_to_multiple(edit[AASO_Aim_Hold_Time_Idx],edit[II_Input_Interval_Idx]);
  edit[RL_Delay_Interval_Idx]  = round_to_multiple(edit[RL_Delay_Interval_Idx],8);

}

// -- Randomise automated input timings for imperfect inputs
function randomise_time() {

  return mod[HI_Humanise_Inputs_Toggle_Idx] * edit[HI_Randomise_Values_Toggle_Idx] == 2 * random(0,40);

}

// -- Update button layout to selected inputs
function apply_button_layout() {

  for(il_input_layout_idx = 0; il_input_layout_idx < _End_Input_Layout_Plus_One_Idx_; il_input_layout_idx ++) {
    Input_Layout[il_input_layout_idx] = Button_Mapping[mod[TB_Tactical_Button_Toggle_Idx + il_input_layout_idx]];
  }

}

/*
// Note: Didn't get around to adding this in yet
function Stick_Layout(f_type) {

  LOOKY = Layout_Sticks[f_type][0];
  LOOKX = Layout_Sticks[f_type][1];
  MOVEY = Layout_Sticks[f_type][2];
  MOVEX = Layout_Sticks[f_type][3];

}
*/



// Polar Aim Assist Abuse + Steady Aim

// -- Calculate integer sin (scaled to an angle range of 32768)
function isin(f_angle) {

  f_angle = f_angle << 17;
  if(f_angle ^ (f_angle * 2) < 0)
    f_angle = (-1 << 31) - f_angle;
  f_angle = f_angle >> 17;
  return f_angle * (0x18000 - (f_angle * f_angle) >> 11) >> 14;

}

// -- Sin but +90Â°
function icos(f_angle) {

  return (isin((f_angle + 8192) % 32768));

}



// Display

enum {

  // -- Mod index constants
  AR_Anti_Recoil_Toggle_Idx = 0,
  AA_Polar_Aim_Assist_Abuse_Toggle_Idx,
  SA_Steady_Aim_Toggle_Idx,
  RC_Reload_Cancel_Toggle_Idx,
  AR2_Auto_Reload_Toggle_Idx,
  JS_Jump_Shot_Toggle_Idx,
  RF_Rapid_Fire_Toggle_Idx,
  AF_Auto_Focus_Toggle_Idx,
  AP_Auto_Ping_Toggle_Idx,
  AASO_Aim_Assist_Snap_On_Abuse_Toggle_Idx,
  QS_Quick_Scoper_Toggle_Idx,
  TJ_Turbo_Jump_Toggle_Idx,
  TM_Turbo_Melee_Toggle_Idx,
  AS_Precise_Auto_Sprint_Toggle_Idx,
  SC_Slide_Cancel_Toggle_Idx,
  PAC_Pickup_Cancel_Toggle_Idx,
  SC2_Swap_Cancel_Toggle_Idx,
  DS_Dropshot_Toggle_Idx,
  CS_Crouch_Shot_Toggle_Idx,
  YYC_YY_Cancel_Toggle_Idx,
  HT_Hair_Triggers_Toggle_Idx,
  HI_Humanise_Inputs_Toggle_Idx,
  DP_Menu_Options_Toggle_Idx,
  CF_Crossover_Fix_Toggle_Idx,
  BR_Block_Rumble_Toggle_Idx,
  RL_Rainbow_Led_Toggle_Idx,
  // ---
  TB_Tactical_Button_Toggle_Idx,
  LB_Lethal_Button_Toggle_Idx,
  AB_Aim_Button_Toggle_Idx,
  FB_Fire_Button_Toggle_Idx,
  SFB_Sprint_Focus_Button_Toggle_Idx,
  MB_Melee_Button_Toggle_Idx,
  PB_Ping_Button_Toggle_Idx,
  SB_Streak_Button_Toggle_Idx,
  JMB_Jump_Mantle_Button_Toggle_Idx,
  SSDB_Stance_Slide_Dive_Button_Toggle_Idx,
  RIB_Reload_Interact_Button_Toggle_Idx,
  SAB_Swap_Armour_Button_Toggle_Idx,
  _End_Mod_Plus_One_Idx_,

  // -- Input Layout index constants
  IL_Tactical_Button_Idx = 0,
  IL_Lethal_Button_Idx,
  IL_Aim_Button_Idx,
  IL_Fire_Button_Idx,
  IL_Sprint_Focus_Button_Idx,
  IL_Melee_Button_Idx,
  IL_Ping_Button_Idx,
  IL_Streak_Button_Idx,
  IL_Jump_Mantle_Button_Idx,
  IL_Stance_Slide_Dive_Button_Idx,
  IL_Reload_Interact_Button_Idx,
  IL_Swap_Armour_Button_Idx,
  _End_Input_Layout_Plus_One_Idx_,

  // -- Edit index constants
  AR_Vert_Value_Idx = 0,
  AR_Hori_Value_Idx,
  AR_Deadzone_Idx,
  AR_Rumble_Influence_Toggle_Idx,
  AR_Reduced_Rumble_Toggle_Idx,
  AR_Boost_Time_Idx,
  AA_Activation_Type_Toggle_Idx,
  AA_Radius_Idx,
  AA_Rotate_By_Angles_Idx,
  AA_Release_Point_Idx,
  SA_Angles_Divided_Idx,
  RC_Release_Activation_Type_Toggle_Idx,
  RC_Max_Reload_Time_For_Cancel_Idx,
  RC_Cancel_Method_Edit_Toggle_Idx,
  AR2_Release_Activation_Type_Toggle_Idx,
  AR2_Shoot_Time_Idx,
  JS_Activation_Type_Toggle_Idx,
  JS_Press_Variance_Time_Idx,
  RF_Activation_Type_Toggle_Idx,
  RF_Shot_Wait_Time_Idx,
  RF_Single_Shot_Time_Idx,
  AF_Type_Toggle_Idx,
  FAC_ADS_Time_Idx,
  AP_Min_Release_Activation_Time_Idx,
  AP_Activation_Type_Toggle_Idx,
  AP_Unping_On_Release_Toggle_Idx,
  AASO_Aim_Hold_Time_Idx,
  TJ_Jump_Wait_Time_Idx,
  AS_Type_Toggle_Idx,
  AS_Crouch_Prone_Delay_Time_Idx,
  SC_Type_Toggle_Idx,
  SC_Cancel_Delay_Time_Idx,
  SC2_Cancel_Delay_Time_Idx,
  DS_Activation_Type_Toggle_Idx,
  DS_Press_Variance_Time_Idx,
  DS_Stand_On_Release_Toggle_Idx,
  DS_Stand_Type_Toggle_Idx,
  CS_Activation_Type_Toggle_Idx,
  CS_Loop_Toggle_Idx,
  CS_Delay_Time_Idx,
  CS_Once_Release_Stand_Toggle_Idx,
  YY_Wait_Delay_Idx,
  YY_Cancel_Delay_Idx,
  II_Input_Interval_Idx,
  HI_Randomise_Values_Toggle_Idx,
  HI_Limit_Turbos_Toggle_Idx,
  DP_Menu_Font_Size_Idx,
  DP_Forward_Scroll_Time_Idx,
  DP_Backward_Scroll_Time_Idx,
  RL_Delay_Interval_Idx,
  RL_Brightness_Idx,
  RL_FX_Brightness_Idx,
  RL_Mod_Menu_Brightness_Idx,
  RL_Saturation_Idx,
  _End_Edit_Plus_One_Idx_,

  // -- Edit toggle index constants
  AA_On_Aim_And_Fire_Toggle_String_Idx = 0,
  AA_On_Aim_Or_Fire_Toggle_String_Idx,
  AA_On_Aim_Toggle_String_Idx,
  AA_On_Fire_Toggle_String_Idx,
  AA_None_Toggle_String_Idx,
  RC_On_Fire_Toggle_String_Idx,
  RC_On_Aim_And_Fire_Toggle_String_Idx,
  RC_Swap_Toggle_String_Idx,
  RC_Lethal_Toggle_String_Idx,
  RC_Tactical_Toggle_String_Idx,
  RC_Sprint_Toggle_String_Idx,
  RC_Emote_Toggle_String_Idx,
  AR2_On_Fire_Toggle_String_Idx,
  AR2_On_Aim_And_Fire_Toggle_String_Idx,
  JS_On_Press_Aim_Toggle_String_Idx,
  JS_On_Hold_Aim_Toggle_String_Idx,
  JS_Panic_Aim_And_Fire_Toggle_String_Idx,
  RF_On_Fire_Toggle_String_Idx,
  RF_On_Aim_And_Fire_Toggle_String_Idx,
  AP_Fully_Aiming_Toggle_String_Idx,
  AP_Aiming_Toggle_String_Idx,
  AP_Ignore_Aim_Toggle_String_Idx,
  AS_Turbo_Press_Toggle_String_Idx,
  AS_Hold_Toggle_String_Idx,
  AS_Press_Toggle_Toggle_String_Idx,
  AS_CW_Boost_Exploit_Toggle_String_Idx,
  SC_Cancel_Stand_Toggle_String_Idx,
  SC_Stand_Toggle_String_Idx,
  SC_Jump_Toggle_String_Idx,
  SC_MWII_Cancel_Toggle_String_Idx,
  AF_Hold_Toggle_String_Idx,
  AF_MWII_Quick_Gasp_Toggle_String_Idx,
  DS_On_Press_Fire_Toggle_String_Idx,
  DS_Panic_Aim_And_Fire_Toggle_String_Idx,
  DS_Sprint_Stand_Toggle_String_Idx,
  DS_Stand_Toggle_String_Idx,
  CS_On_Aim_Toggle_String_Idx,
  CS_On_Fire_Toggle_String_Idx,
  CS_On_Aim_And_Fire_Toggle_String_Idx,
  HI_Off_Toggle_String_Idx,
  HI_Aim_Only_Toggle_String_Idx,
  HI_All_Toggle_String_Idx,
  DP_Small_Font_Toggle_String_Idx,
  DP_Medium_Font_Toggle_String_Idx,
  DP_Large_Font_Toggle_String_Idx,

  // -- Button toggle index constants
  BTI_LB = 0,
  BTI_RB,
  BTI_LT,
  BTI_RT,
  BTI_LS,
  BTI_RS,
  BTI_UP,
  BTI_DOWN,
  BTI_LEFT,
  BTI_RIGHT,
  BTI_A,
  BTI_B,
  BTI_X,
  BTI_Y,

  // -- Edit value text type constants
  EVTT_None = 0,
  EVTT_Sec,
  EVTT_MS,
  EVTT_Percentage,
  EVTT_FPS,

  // -- ASCII character index constants
  SPACE = ASCII_SPACE, EXCLAMATION, DOUBLE_QUOTE, QUOTES = DOUBLE_QUOTE, POUND, DOLLAR, PERCENT, AND, SINGLE_QUOTE, QUOTE = SINGLE_QUOTE, OPEN_PARENTHESIS,
  CLOSE_PARENTHESIS, ASTERISK, PLUS, COMMA, MINUS, DASH = MINUS, PERIOD, DOT = PERIOD, SLASH, DIGIT0, DIGIT1, DIGIT2, DIGIT3, DIGIT4, DIGIT5, DIGIT6, DIGIT7, DIGIT8,
  DIGIT9, COLON, SEMICOLON, LESS_THAN, LEFT_ARROW = LESS_THAN, EQUAL, GREATER_THAN, RIGHT_ARROW = GREATER_THAN, QUESTION_MARK, AT, A, B, C, D, E, F, G, H,
  I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, OPEN_BRACKET, BACKSLASH, CLOSE_BRACKET, CARAT, UNDERSCORE, GRAVE, a, b, c, d, e, f, g, h, i, j, k,
  l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, OPEN_BRACE, BAR, PIPE = BAR, OR = BAR, CLOSE_BRACE, TILDE

}



// Display

// -- Note: Maybe put into a single array

const string Splash_Strings[] = {

/*0*/  "Welcome!",
/*1*/  "LT + MENU",
/*2*/  "L2 +",
/*3*/  "OPTIONS",
/*4*/  "ZL + PLUS"

}

const string Main_Menu_Strings[] = {

/*0*/  " Mods ",
/*1*/  " Settings "

};

const string Title_Strings[] = {

/*0*/  "COD Pro",
/*1*/  "v6.0.0"

};

// -- Note: Old, unused now

//const string Xbox_Button_Strings[] = {
//
///* 0*/  "LB",
///* 1*/  "RB",
///* 2*/  "LT",
///* 3*/  "RT",
///* 4*/  "LS",
///* 5*/  "RS",
///* 6*/  "UP",
///* 7*/  "DOWN",
///* 8*/  "LEFT",
///* 9*/  "RIGHT",
///*10*/  "A",
///*11*/  "B",
///*12*/  "X",
///*13*/  "Y"
//
//};

//const string Playstation_Button_Strings[] = {
//
///* 0*/  "L1",
///* 1*/  "R1",
///* 2*/  "L2",
///* 3*/  "R2",
///* 4*/  "L3",
///* 5*/  "R3",
///* 6*/  "UP",
///* 7*/  "DOWN",
///* 8*/  "LEFT",
///* 9*/  "RIGHT",
///*10*/  "CROSS",
///*11*/  "CIRCLE",
///*12*/  "SQUARE",
///*13*/  "TRIANGLE"
//
//};

//const string Nintendo_Button_Strings[] = {
//
///* 0*/  "L",
///* 1*/  "R",
///* 2*/  "ZL",
///* 3*/  "ZR",
///* 4*/  "L3",
///* 5*/  "R3",
///* 6*/  "UP",
///* 7*/  "DOWN",
///* 8*/  "LEFT",
///* 9*/  "RIGHT",
///*10*/  "B",
///*11*/  "A",
///*12*/  "Y",
///*13*/  "X"
//
//};



const uint8 Button_Mapping[] = {

/* 0*/  XB1_LB,
/* 1*/  XB1_RB,
/* 2*/  XB1_LT,
/* 3*/  XB1_RT,
/* 4*/  XB1_LS,
/* 5*/  XB1_RS,
/* 6*/  XB1_UP,
/* 7*/  XB1_DOWN,
/* 8*/  XB1_LEFT,
/* 9*/  XB1_RIGHT,
/*10*/  XB1_A,
/*11*/  XB1_B,
/*12*/  XB1_X,
/*13*/  XB1_Y

};



/*
// Didn't get around to adding this in yet
const uint8 Layout_Sticks[][] = {

  // Move X  Move Y  Look X  Look Y
  { XB1_RY, XB1_RX, XB1_LY, XB1_LX}, // Default
  { XB1_LY, XB1_LX, XB1_RY, XB1_RX}, // Southpaw
  { XB1_RY, XB1_LX, XB1_LY, XB1_RX}, // Legacy
  { XB1_LY, XB1_RX, XB1_LY, XB1_LX}  // Legacy Southpaw

};
*/



// Display

// -- Note: 255 = Doesn't have an edit value
const uint8 Edit_Range[][] = {

/* 0*/  { AR_Vert_Value_Idx, AR_Boost_Time_Idx },
/* 1*/  { AA_Activation_Type_Toggle_Idx, AA_Release_Point_Idx },
/* 2*/  { SA_Angles_Divided_Idx, SA_Angles_Divided_Idx },
/* 3*/  { RC_Release_Activation_Type_Toggle_Idx, RC_Max_Reload_Time_For_Cancel_Idx },
/* 4*/  { AR2_Release_Activation_Type_Toggle_Idx, AR2_Shoot_Time_Idx },
/* 5*/  { JS_Activation_Type_Toggle_Idx, JS_Press_Variance_Time_Idx },
/* 6*/  { RF_Activation_Type_Toggle_Idx, RF_Single_Shot_Time_Idx },
/* 7*/  { AF_Type_Toggle_Idx, FAC_ADS_Time_Idx },
/* 8*/  { AP_Min_Release_Activation_Time_Idx, AP_Unping_On_Release_Toggle_Idx },
/* 9*/  { AASO_Aim_Hold_Time_Idx, AASO_Aim_Hold_Time_Idx },
/*10*/  { 255, 255 },
/*11*/  { TJ_Jump_Wait_Time_Idx, TJ_Jump_Wait_Time_Idx },
/*12*/  { 255, 255 },
/*13*/  { AS_Type_Toggle_Idx, AS_Crouch_Prone_Delay_Time_Idx },
/*14*/  { SC_Type_Toggle_Idx, SC_Cancel_Delay_Time_Idx },
/*15*/  { 255, 255 },
/*16*/  { SC2_Cancel_Delay_Time_Idx, SC2_Cancel_Delay_Time_Idx },
/*17*/  { DS_Activation_Type_Toggle_Idx, DS_Stand_Type_Toggle_Idx },
/*18*/  { CS_Activation_Type_Toggle_Idx, CS_Once_Release_Stand_Toggle_Idx },
/*19*/  { YY_Wait_Delay_Idx, YY_Cancel_Delay_Idx },
/*20*/  { II_Input_Interval_Idx, II_Input_Interval_Idx },
/*21*/  { HI_Randomise_Values_Toggle_Idx, HI_Limit_Turbos_Toggle_Idx },
/*22*/  { DP_Menu_Font_Size_Idx, DP_Backward_Scroll_Time_Idx },
/*23*/  { 255, 255 },
/*24*/  { 255, 255 },
/*25*/  { RL_Delay_Interval_Idx, RL_Saturation_Idx },
/*26*/  { 255, 255 },
/*27*/  { 255, 255 },
/*28*/  { 255, 255 },
/*29*/  { 255, 255 },
/*30*/  { 255, 255 },
/*31*/  { 255, 255 },
/*32*/  { 255, 255 },
/*33*/  { 255, 255 },
/*34*/  { 255, 255 },
/*35*/  { 255, 255 },
/*36*/  { 255, 255 },
/*37*/  { 255, 255 },
/*38*/  { 255, 255 }

}

const uint8 Edit_Value_Text_Type[] = {

/* 0*/  EVTT_Percentage,
/* 1*/  EVTT_Percentage,
/* 2*/  EVTT_Percentage,
/* 3*/  EVTT_None,
/* 4*/  EVTT_None,
/* 5*/  EVTT_MS,
/* 6*/  EVTT_None,
/* 7*/  EVTT_Percentage,
/* 8*/  EVTT_None,
/* 9*/  EVTT_Percentage,
/*10*/  EVTT_None,
/*11*/  EVTT_None,
/*12*/  EVTT_MS,
/*13*/  EVTT_None,
/*14*/  EVTT_None,
/*15*/  EVTT_MS,
/*16*/  EVTT_None,
/*17*/  EVTT_MS,
/*18*/  EVTT_None,
/*19*/  EVTT_MS,
/*20*/  EVTT_MS,
/*21*/  EVTT_None,
/*22*/  EVTT_MS,
/*23*/  EVTT_Sec,
/*24*/  EVTT_None,
/*25*/  EVTT_None,
/*26*/  EVTT_MS,
/*27*/  EVTT_MS,
/*28*/  EVTT_None,
/*29*/  EVTT_MS,
/*30*/  EVTT_None,
/*31*/  EVTT_MS,
/*32*/  EVTT_MS,
/*33*/  EVTT_None,
/*34*/  EVTT_MS,
/*35*/  EVTT_None,
/*36*/  EVTT_None,
/*37*/  EVTT_None,
/*38*/  EVTT_None,
/*39*/  EVTT_MS,
/*40*/  EVTT_None,
/*41*/  EVTT_MS,
/*42*/  EVTT_MS,
/*43*/  EVTT_FPS,
/*44*/  EVTT_None,
/*45*/  EVTT_None,
/*46*/  EVTT_None,
/*47*/  EVTT_MS,
/*48*/  EVTT_MS,
/*49*/  EVTT_MS,
/*50*/  EVTT_Percentage,
/*51*/  EVTT_Percentage,
/*52*/  EVTT_Percentage,
/*53*/  EVTT_Percentage

}

const int16 Edit_Value_Range[][] = {

// -- Min, Max, Default
/* 0*/  { -60                           ,60                                                            ,AR_Vert_Value },
/* 1*/  { -60                           ,60                                                            ,AR_Hori_Value },
/* 2*/  { 0                             ,75                                                            ,AR_Deadzone },
/* 3*/  { FALSE                         ,TRUE                                                          ,AR_Rumble_Influence },
/* 4*/  { FALSE                         ,TRUE                                                          ,AR_Reduced_Rumble },
/* 5*/  { 0                             ,DP_Max_Small_Time_Based_Value                                 ,AR_Boost_Time },
/* 6*/  { 0                             ,4                                                             ,AA_Activation_Type },
/* 7*/  { 1                             ,60                                                            ,AA_Radius },
/* 8*/  { 1                             ,45                                                            ,AA_Rotate_By_Angles },
/* 9*/  { 1                             ,60                                                            ,AA_Release_Point },
/*10*/  { 2                             ,2 + 15                                                        ,SA_Angles_Divided },
/*11*/  { 0                             ,1                                                             ,RC_Release_Activation_Type },
/*12*/  { HT_Min_Standard_Game_Hold_Time,HT_Min_Standard_Game_Hold_Time + DP_Max_Large_Time_Based_Value,RC_Max_Reload_Time_For_Cancel },
/*13*/  { 0                             ,4                                                             ,0 },
/*14*/  { 0                             ,1                                                             ,AR2_Release_Activation_Type },
/*15*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,AR2_Shoot_Time },
/*16*/  { 0                             ,2                                                             ,JS_Activation_Type },
/*17*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,JS_Press_Variance_Time },
/*18*/  { 0                             ,1                                                             ,RF_Activation_Type },
/*19*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,RF_Shot_Wait_Time },
/*20*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,RF_Single_Shot_Time },
/*21*/  { 0                             ,1                                                             ,AF_Type },
/*22*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,FAC_ADS_Time },
/*23*/  { 0                             ,126                                                           ,AP_Min_Release_Activation_Time },
/*24*/  { 0                             ,1                                                             ,AP_Activation_Type },
/*25*/  { 0                             ,1                                                             ,AP_Unping_On_Release },
/*26*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,AASO_Aim_Hold_Time },
/*27*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,TJ_Jump_Wait_Time },
/*28*/  { 0                             ,3                                                             ,AS_Type },
/*29*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,AS_Crouch_Prone_Delay_Time },
/*30*/  { 0                             ,3                                                             ,SC_Type },
/*31*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,SC_Cancel_Delay_Time },
/*32*/  { 100                           ,100 + DP_Max_Small_Time_Based_Value                           ,SC2_Cancel_Delay_Time },
/*33*/  { 0                             ,1                                                             ,DS_Activation_Type },
/*34*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DS_Press_Variance_Time },
/*35*/  { FALSE                         ,TRUE                                                          ,DS_Stand_On_Release },
/*36*/  { 0                             ,1                                                             ,DS_Stand_Type },
/*37*/  { 0                             ,2                                                             ,CS_Activation_Type },
/*38*/  { FALSE                         ,TRUE                                                          ,CS_Loop },
/*39*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,CS_Delay_Time },
/*40*/  { FALSE                         ,TRUE                                                          ,CS_Once_Release_Stand },
/*41*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,YY_Wait_Delay },
/*42*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,YY_Cancel_Delay },
/*43*/  { 1                             ,50                                                            ,II_Input_Interval },
/*44*/  { 0                             ,2                                                             ,HI_Randomise_Values },
/*45*/  { FALSE                         ,TRUE                                                          ,HI_Limit_Turbos },
/*46*/  { 0                             ,2                                                             ,DP_Menu_Font_Size },
/*47*/  { 1                             ,DP_Max_Large_Time_Based_Value                                 ,DP_Forward_Scroll_Time },
/*48*/  { 1                             ,DP_Max_Small_Time_Based_Value                                 ,DP_Backward_Scroll_Time },
/*49*/  { 8                             ,DP_Max_Small_Time_Based_Value                                 ,RL_Delay_Interval },
/*50*/  { 1                             ,100                                                           ,RL_Brightness },
/*51*/  { 1                             ,100                                                           ,RL_FX_Brightness },
/*52*/  { 1                             ,100                                                           ,RL_Mod_Menu_Brightness },
/*53*/  { 1                             ,100                                                           ,RL_Saturation }

}

const uint8 Edit_Toggle_Value[] = {

/* 0*/  NOT_USE,
/* 1*/  NOT_USE,
/* 2*/  NOT_USE,
/* 3*/  TRUE,
/* 4*/  TRUE,
/* 5*/  NOT_USE,
/* 6*/  4,
/* 7*/  NOT_USE,
/* 8*/  NOT_USE,
/* 9*/  NOT_USE,
/*10*/  NOT_USE,
/*11*/  1,
/*12*/  NOT_USE,
/*13*/  0,
/*14*/  1,
/*15*/  NOT_USE,
/*16*/  2,
/*17*/  NOT_USE,
/*18*/  1,
/*19*/  NOT_USE,
/*20*/  NOT_USE,
/*21*/  1,
/*22*/  NOT_USE,
/*23*/  NOT_USE,
/*24*/  2,
/*25*/  TRUE,
/*26*/  NOT_USE,
/*27*/  NOT_USE,
/*28*/  3,
/*29*/  NOT_USE,
/*30*/  3,
/*31*/  NOT_USE,
/*32*/  NOT_USE,
/*33*/  1,
/*34*/  NOT_USE,
/*35*/  TRUE,
/*36*/  1,
/*37*/  2,
/*38*/  TRUE,
/*39*/  NOT_USE,
/*40*/  TRUE,
/*41*/  NOT_USE,
/*42*/  NOT_USE,
/*43*/  NOT_USE,
/*44*/  2,
/*45*/  TRUE,
/*46*/  2,
/*47*/  NOT_USE,
/*48*/  NOT_USE,
/*49*/  NOT_USE,
/*50*/  NOT_USE,
/*51*/  NOT_USE,
/*51*/  NOT_USE,
/*52*/  NOT_USE

}

const uint8 Round_Edit[] = {

  // -- Round to input interval value
  AR_Boost_Time_Idx,
  RC_Max_Reload_Time_For_Cancel_Idx,
  AR2_Shoot_Time_Idx,
  TJ_Jump_Wait_Time_Idx,
  RF_Shot_Wait_Time_Idx,
  RF_Single_Shot_Time_Idx,
  FAC_ADS_Time_Idx,
  AS_Crouch_Prone_Delay_Time_Idx,
  SC_Cancel_Delay_Time_Idx,
  SC2_Cancel_Delay_Time_Idx,
  CS_Delay_Time_Idx,
  // -- Round to max polling rate value
  JS_Press_Variance_Time_Idx,
  DS_Press_Variance_Time_Idx,
  DP_Forward_Scroll_Time_Idx,
  DP_Backward_Scroll_Time_Idx

}

const uint8 DP_Menu_Type_Interval_Time[] = { 32, 216 }

const uint8 Scroll_Strings[] = {

  1,

  // -- Mod Title

  SPACE, A,n,t,i, MINUS ,R,e,c,o,i,l, SPACE, 0,
  SPACE, A,i,m, SPACE, A,s,s,i,s,t, SPACE, QUOTE,S,l,o,w,d,o,w,n,QUOTE, SPACE, A,b,u,s,e, SPACE, 0,
  SPACE, S,t,e,a,d,y, SPACE, A,i,m, SPACE, 0,
  SPACE, R,e,l,o,a,d, SPACE, C,a,n,c,e,l, SPACE, 0,
  SPACE, A,u,t,o, SPACE, R,e,l,o,a,d, SPACE, 0,
  SPACE, J,u,m,p, SPACE, S,h,o,t, SPACE, 0,
  SPACE, R,a,p,i,d, SPACE, F,i,r,e, SPACE, 0,
  SPACE, A,u,t,o, SPACE, F,o,c,u,s, SPACE, 0,
  SPACE, A,u,t,o, SPACE, P,i,n,g, SPACE, 0,
  SPACE, A,i,m, SPACE, A,s,s,i,s,t, SPACE, QUOTE,S,n,a,p, SPACE, O,n,QUOTE, SPACE, A,b,u,s,e, SPACE, OPEN_PARENTHESIS, P,v,E, CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, Q,u,i,c,k, SPACE, S,c,o,p,e,r, SPACE, OPEN_PARENTHESIS, R,e,q,DOT, SPACE, T,h,r,o,w,i,n,g, SPACE, K,n,i,f,e, CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, T,u,r,b,o, SPACE, J,u,m,p, SPACE, 0,
  SPACE, T,u,r,b,o, SPACE, M,e,l,e,e, SPACE, 0,
  SPACE, A,u,t,o, SPACE, S,p,r,i,n,t, SPACE, 0,
  SPACE, S,l,i,d,e, SPACE, C,a,n,c,e,l, SPACE, 0,
  SPACE, P,i,c,k,u,p, SPACE, C,a,n,c,e,l, SPACE, 0,
  SPACE, S,w,a,p, SPACE, C,a,n,c,e,l, SPACE, 0,
  SPACE, D,r,o,p,s,h,o,t, SPACE, 0,
  SPACE, C,r,o,u,c,h, SPACE, S,h,o,t, SPACE, 0,
  SPACE, QUOTES,Y,Y,QUOTES, SPACE, C,a,n,c,e,l, SPACE, OPEN_PARENTHESIS,V,i,s,u,a,l,CLOSE_PARENTHESIS, SPACE, OPEN_PARENTHESIS,E,x,p,e,r,i,m,e,n,t,a,l,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, H,a,i,r, SPACE, T,r,i,g,g,e,r,s, SPACE, 0,
  SPACE, H,u,m,a,n,i,s,e, SPACE, I,n,p,u,t,s, SPACE, OPEN_PARENTHESIS,M,W,I,I,SLASH,DIGIT2,DIGIT0,DIGIT2,DIGIT2,PLUS,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, M,e,n,u, SPACE, O,p,t,i,o,n,s, SPACE, 0,
  SPACE, F,u,l,l, SPACE, C,r,o,s,s,o,v,e,r, SPACE, M,a,p,p,i,n,g, SPACE, 0,
  SPACE, B,l,o,c,k, SPACE, V,i,b,r,a,t,i,o,n, SPACE, 0,
  SPACE, H,u,e, SPACE, C,y,c,l,i,n,g, SPACE, L,E,D, SPACE, 0,
  SPACE, T,A,C,T,I,C,A,L, SPACE, 0,
  SPACE, L,E,T,H,A,L, SPACE, 0,
  SPACE, A,I,M, SPACE, 0,
  SPACE, F,I,R,E, SPACE, 0,
  SPACE, S,P,R,I,N,T, SPACE, F,O,C,U,S, SPACE, 0,
  SPACE, M,E,L,E,E, SPACE, 0,
  SPACE, P,I,N,G, SPACE, 0,
  SPACE, S,T,R,E,A,K, SPACE, 0,
  SPACE, J,U,M,P, SPACE, M,A,N,T,L,E, SPACE, 0,
  SPACE, S,T,A,N,C,E, SPACE, S,L,I,D,E, SPACE, D,I,V,E, SPACE, 0,
  SPACE, R,E,L,O,A,D, SPACE, I,N,T,E,R,A,C,T, SPACE, 0,
  SPACE, S,W,A,P, SPACE, A,R,M,O,U,R, SPACE, 0,

  // -- Mod Values

  // -- Switch Toggles
  SPACE, O,f,f, SPACE, 0,
  SPACE, O,n, SPACE, 0,
  SPACE, RIGHT_ARROW, LEFT_ARROW, SPACE, 0,

  // -- Button Toggles
  SPACE, L,B, SPACE, 0,
  SPACE, R,B, SPACE, 0,
  SPACE, L,T, SPACE, 0,
  SPACE, R,T, SPACE, 0,
  SPACE, L,S, SPACE, 0,
  SPACE, R,S, SPACE, 0,
  SPACE, U,P, SPACE, 0,
  SPACE, D,O,W,N, SPACE, 0,
  SPACE, L,E,F,T, SPACE, 0,
  SPACE, R,I,G,H,T, SPACE, 0,
  SPACE, A, SPACE, 0,
  SPACE, B, SPACE, 0,
  SPACE, X, SPACE, 0,
  SPACE, Y, SPACE, 0,

  // -- Edit Titles

  SPACE, V,e,r,t,i,c,a,l, SPACE, 0,
  SPACE, H,o,r,i,z,o,n,t,a,l, SPACE, 0,
  SPACE, D,e,a,d,z,o,n,e, SPACE, 0,
  SPACE, R,u,m,b,l,e, SPACE, I,n,f,l,u,e,n,c,e, SPACE, 0,
  SPACE, R,e,d,u,c,e, SPACE, R,u,m,b,l,e, SPACE, I,n,f,l,u,e,n,c,e, SPACE, 0,
  SPACE, I,n,i,t,i,a,l, SPACE, B,o,o,s,t, SPACE, R,u,m,b,l,e, SPACE, T,i,m,e, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, R,a,d,i,u,s, SPACE, OPEN_PARENTHESIS, QUOTE,s,t,r,e,n,g,t,h,QUOTE, CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, I,n,c,r,e,m,e,n,t, SPACE, R,o,t,a,t,i,o,n, SPACE, B,y, SPACE, OPEN_PARENTHESIS,d,e,g,r,e,e,s,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, R,e,l,e,a,s,e, SPACE, P,o,i,n,t, SPACE, 0,
  SPACE, A,i,m, SPACE, A,n,g,l,e,s, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, R,e,l,o,a,d, SPACE, T,i,m,e, SPACE, 0,
  SPACE, C,a,n,c,e,l, SPACE, M,e,t,h,o,d, SPACE, ASTERISK, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, R,e,q,u,i,r,e,d, SPACE, F,i,r,i,n,g, SPACE, T,i,m,e, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, P,a,n,i,c, SPACE, P,r,e,s,s, SPACE, T,i,m,e, SPACE, V,a,r,i,a,n,c,e, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, I,n,i,t,i,a,l, SPACE, D,e,l,a,y, SPACE, OPEN_PARENTHESIS,f,o,r, SPACE, t,a,p, SPACE, s,h,o,t,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, T,y,p,e, SPACE, 0,
  SPACE, A,D,S, SPACE, T,i,m,e, SPACE, 0,
  SPACE, R,e,l,e,a,s,e,d, SPACE, T,i,m,e, SPACE, F,o,r, SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, R,e,q,u,i,r,e,d, SPACE, A,i,m, SPACE, T,y,p,e, SPACE, 0,
  SPACE, U,n,p,i,n,g, SPACE, OPEN_PARENTHESIS,E,x,p,e,r,i,m,e,n,t,a,l,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, H,o,l,d, SPACE, T,i,m,e, SPACE, 0,
  SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, T,y,p,e, SPACE, 0,
  SPACE, C,r,o,u,c,h,e,d, SPACE, S,p,r,i,n,t, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, T,y,p,e, SPACE, 0,
  SPACE, C,a,n,c,e,l, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, C,a,n,c,e,l, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, P,a,n,i,c, SPACE, P,r,e,s,s, SPACE, T,i,m,e, SPACE, V,a,r,i,a,n,c,e, SPACE, 0,
  SPACE, S,t,a,n,d, SPACE, O,n, SPACE, R,e,l,e,a,s,e, SPACE, 0,
  SPACE, S,t,a,n,d, SPACE, T,y,p,e, SPACE, 0,
  SPACE, A,c,t,i,v,a,t,i,o,n, SPACE, 0,
  SPACE, L,o,o,p, SPACE, O,n, SPACE, H,o,l,d, SPACE, 0,
  SPACE, L,o,o,p, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, O,n,c,e, SPACE, DASH, SPACE, S,t,a,n,d, SPACE, O,n, SPACE, R,e,l,e,a,s,e, SPACE, 0,
  SPACE, W,a,i,t, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, C,a,n,c,e,l, SPACE, D,e,l,a,y, SPACE, 0,
  SPACE, I,n,p,u,t, SPACE, I,n,t,e,r,v,a,l, SPACE, 0,
  SPACE, R,a,n,d,o,m,i,s,e, SPACE, V,a,l,u,e,s, SPACE, 0,
  SPACE, L,i,m,i,t, SPACE, T,u,r,b,o,s, SPACE, S,p,e,e,d, SPACE, 0,
  SPACE, F,o,n,t, SPACE, S,i,z,e, SPACE, 0,
  SPACE, F,o,r,w,a,r,d,s, SPACE, S,c,r,o,l,l, SPACE, A,p,e,x, SPACE, T,i,m,e, SPACE, 0,
  SPACE, B,a,c,k,w,a,r,d,s, SPACE, S,c,r,o,l,l, SPACE, A,p,e,x, SPACE, T,i,m,e, SPACE, 0,
  SPACE, D,e,l,a,y, SPACE, I,n,t,e,r,v,a,l, SPACE, 0,
  SPACE, B,i,g,h,t,n,e,s,s, SPACE, 0,
  SPACE, F,X, SPACE, B,i,g,h,t,n,e,s,s, SPACE, 0,
  SPACE, M,e,n,u, SPACE, B,i,g,h,t,n,e,s,s, SPACE, 0,
  SPACE, S,a,t,u,r,a,t,i,o,n, SPACE, 0,

  // -- Edit Values
  // -- Note: If it is not 0 length then it will show a value instead of the constant text (the placeholder space)

  0,
  0,
  0,
  SPACE, 0,
  SPACE, 0,
  0,

  SPACE, 0,
  0,
  0,
  0,

  0,

  SPACE, 0,
  0,
  SPACE, 0,

  SPACE, 0,
  0,

  SPACE, 0,
  0,

  SPACE, 0,
  0,
  0,

  SPACE, 0,
  0,

  0,
  SPACE, 0,
  SPACE, 0,

  0,

  0,

  SPACE, 0,
  0,

  SPACE, 0,
  0,

  0,

  SPACE, 0,
  0,
  SPACE, 0,
  SPACE, 0,

  SPACE, 0,
  SPACE, 0,
  0,
  SPACE, 0,

  0,
  0,

  0,

  SPACE, 0,
  SPACE, 0,

  SPACE, 0,
  0,
  0,

  0,
  0,
  0,
  0,
  0,

  // -- Edit Toggles

  SPACE, A,I,M, SPACE, AND, SPACE, F,I,R,E, SPACE, 0,
  SPACE, A,I,M, SPACE, OR, SPACE, F,I,R,E, SPACE, 0,
  SPACE, A,I,M, SPACE, 0,
  SPACE, F,I,R,E, SPACE, 0,
  SPACE, N,o,n,e, SPACE, OPEN_PARENTHESIS,a,l,w,a,y,s, SPACE, o,n,CLOSE_PARENTHESIS, SPACE, 0,

  SPACE, P,r,e,s,s, SPACE, F,I,R,E, SPACE, 0,
  SPACE, P,r,e,s,s, SPACE, A,I,M, SPACE, OR, SPACE, F,I,R,E, SPACE, 0,

  /*SPACE, S,w,a,p,*/ SPACE, 0,
  /*SPACE, L,e,t,h,a,l,*/ SPACE, 0,
  /*SPACE, T,a,c,t,i,c,a,l,*/ SPACE, 0,
  /*SPACE, S,p,r,i,n,t,*/ SPACE, 0,
  /*SPACE, E,m,o,t,e,*/ SPACE, 0,

  SPACE, R,e,l,e,a,s,e, SPACE, F,I,R,E, SPACE, 0,
  SPACE, R,e,l,e,a,s,e, SPACE, A,I,M, SPACE, AND, SPACE, F,I,R,E, SPACE, 0,

  SPACE, P,r,e,s,s, SPACE, A,I,M, SPACE, 0,
  SPACE, H,o,l,d, SPACE, A,I,M, SPACE, 0,
  SPACE, P,a,n,i,c, SPACE, P,r,e,s,s, SPACE, OPEN_PARENTHESIS,A,I,M, SPACE, AND, SPACE, F,I,R,E,CLOSE_PARENTHESIS, SPACE, 0,

  SPACE, F,I,R,E, SPACE, 0,
  SPACE, A,I,M, SPACE, AND, SPACE, F,I,R,E, SPACE, 0,

  SPACE, F,u,l,l,y, SPACE, A,i,m,i,n,g, SPACE, 0,
  SPACE, H,o,l,d,i,n,g, SPACE, A,i,m, SPACE, 0,
  SPACE, N,o,n,e, SPACE, 0,

  SPACE, T,u,r,b,o, SPACE, OPEN_PARENTHESIS,p,r,e,s,s, SPACE, m,o,d,e,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, H,o,l,d, SPACE, OPEN_PARENTHESIS,h,o,l,d, SPACE, m,o,d,e,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, P,r,e,s,s, SPACE, OPEN_PARENTHESIS,t,o,g,g,l,e, SPACE, m,o,d,e,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, C,W, SPACE, B,o,o,s,t, SPACE, E,x,p,l,o,i,t, SPACE, OPEN_PARENTHESIS, p,r,e,s,s, SPACE, m,o,d,e,CLOSE_PARENTHESIS, SPACE, 0,

  SPACE, L,e,g,a,c,y, SPACE, C,a,n,c,e,l, SPACE, S,t,a,n,d, SPACE, 0,
  SPACE, S,t,a,n,d, SPACE, 0,
  SPACE, QUOTE,J,u,m,p,QUOTE, SPACE, 0,
  SPACE, M,W,I,I, SPACE, C,a,n,c,e,l, SPACE, 0,

  SPACE, H,o,l,d, SPACE, 0,
  SPACE, Q,u,i,c,k, SPACE, G,a,s,p, SPACE, OPEN_PARENTHESIS,M,W,I,I,CLOSE_PARENTHESIS, SPACE, 0,

  SPACE, P,r,e,s,s, SPACE, F,I,R,E, SPACE, 0,
  SPACE, P,a,n,i,c, SPACE, P,r,e,s,s, SPACE, OPEN_PARENTHESIS,A,I,M, SPACE, AND, SPACE, F,I,R,E,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, S,p,r,i,n,t, SPACE, OPEN_PARENTHESIS,f,a,s,t,CLOSE_PARENTHESIS, SPACE, 0,
  SPACE, S,t,a,n,d, SPACE, 0,

  SPACE, A,I,M, SPACE, 0,
  SPACE, F,I,R,E, SPACE, 0,
  SPACE, A,I,M, SPACE, AND, SPACE, F,I,R,E, SPACE, 0,

  SPACE, O,f,f, SPACE, 0,
  SPACE, A,i,m, SPACE, O,n,l,y, SPACE, 0,
  SPACE, A,l,l, SPACE, 0,

  SPACE, E,y,e, SPACE, S,t,r,a,i,n, SPACE, 0,
  SPACE, N,o,r,m,i,e, SPACE, 0,
  SPACE, T,h,e, SPACE, C,o,u,c,h, SPACE, 0

};

																																																																																																																																																																		const uint8 Line[]={69,58,31,28,27,8,6,89,13}

/*
// Polar Aim Assist Abuse + Steady Aim

const int16 Cos_Circle[] = {

  32767,32762,32747,32722,32687,32642,32587,32522,32448,32363,32269,32164,32050,31927,31793,31650,31497,31335,31163,
  30981,30790,30590,30381,30162,29934,29696,29450,29195,28931,28658,28377,28086,27787,27480,27165,26841,26509,26168,
  25820,25464,25100,24729,24350,23964,23570,23169,22761,22347,21925,21497,21062,20620,20173,19719,19259,18794,18323,
  17846,17363,16876,16383,15885,15383,14875,14364,13847,13327,12803,12274,11742,11206,10667,10125,9580,9031,8480,
  7927,7370,6812,6252,5689,5125,4560,3993,3425,2855,2285,1714,1143,571,0,-571,-1143,-1714,-2285,-2855,-3425,-3993,
  -4560,-5125,-5689,-6252,-6812,-7370,-7927,-8480,-9031,-9580,-10125,-10667,-11206,-11742,-12274,-12803,-13327,-13847,
  -14364,-14875,-15383,-15885,-16383,-16876,-17363,-17846,-18323,-18794,-19259,-19719,-20173,-20620,-21062,-21497,
  -21925,-22347,-22761,-23169,-23570,-23964,-24350,-24729,-25100,-25464,-25820,-26168,-26509,-26841,-27165,-27480,
  -27787,-28086,-28377,-28658,-28931,-29195,-29450,-29696,-29934,-30162,-30381,-30590,-30790,-30981,-31163,-31335,
  -31497,-31650,-31793,-31927,-32050,-32164,-32269,-32363,-32448,-32522,-32587,-32642,-32687,-32722,-32747,-32762,
  -32767,-32762,-32747,-32722,-32687,-32642,-32587,-32522,-32448,-32363,-32269,-32164,-32050,-31927,-31793,-31650,
  -31497,-31335,-31163,-30981,-30790,-30590,-30381,-30162,-29934,-29696,-29450,-29195,-28931,-28658,-28377,-28086,
  -27787,-27480,-27165,-26841,-26509,-26168,-25820,-25464,-25100,-24729,-24350,-23964,-23570,-23169,-22761,-22347,
  -21925,-21497,-21062,-20620,-20173,-19719,-19259,-18794,-18323,-17846,-17363,-16876,-16383,-15885,-15383,-14875,
  -14364,-13847,-13327,-12803,-12274,-11742,-11206,-10667,-10125,-9580,-9031,-8480,-7927,-7370,-6812,-6252,-5689,
  -5125,-4560,-3993,-3425,-2855,-2285,-1714,-1143,-571,0,571,1143,1714,2285,2855,3425,3993,4560,5125,5689,6252,6812,
  7370,7927,8480,9031,9580,10125,10667,11206,11742,12274,12803,13327,13847,14364,14875,15383,15885,16383,16876,17363,
  17846,18323,18794,19259,19719,20173,20620,21062,21497,21925,22347,22761,23169,23570,23964,24350,24729,25100,25464,
  25820,26168,26509,26841,27165,27480,27787,28086,28377,28658,28931,29195,29450,29696,29934,30162,30381,30590,30790,
  30981,31163,31335,31497,31650,31793,31927,32050,32164,32269,32363,32448,32522,32587,32642,32687,32722,32747,32762

}
*/



// Persistent Variables

// -- Start of where data is stored
function reset_spvar() {

  pv_current_slot = SPVAR_1;
  pv_current_bit = 0;
  pv_current_value = 0;

}

// -- Function used to count the number of bits used by the given value
function get_bit_count(f_val) {

  pv_temp = 0;  // -- We need to start at 0, we use pv_temp here as we need to track the bits during our loop below

  while(f_val) {
    pv_temp ++;  // -- Increment the bit count by 1
    f_val = abs(f_val >> 1);  // -- Shift the value down 1 bit, once we have no more bits set this will result in 0, unless the value is negative - in which case this will be endless, we do abs here to make it always
  }

  return pv_temp;

}

// -- Function used to count the number of bits used by 2 given values
function get_bit_count2(f_val1, f_val2) {

  pv_temp = max(get_bit_count(f_val1), get_bit_count(f_val2));  // -- Get the highest bit count required for either min or max

  if(is_signed2(f_val1, f_val2))  // -- Check if we need to know if the value is negative or not
    pv_temp ++;  // -- If we need to track if the saved value is negative, we need 1 bit for that specifically - the others are used to store the actual value

  return pv_temp;

}

// -- Function used to determine if either of 2 given values is negative
function is_signed2(f_val1, f_val2) {

  return f_val1 < 0 || f_val2 < 0;

}

// -- Function used to generate a bitmask for the sign bit, this will always be the highest bit in the range we're requesting it for, to do that - we need to start with the lowest bit set and move it up the number of steps there is between 1 and the bits we need, this needs to be a maximum of 31 but can never be negative
function make_sign(f_bits) {

  return 1 << clamp(f_bits - 1, 0, 31);

}

// -- Function used to generate a full bitmask (essentially all bits set up to and including the number of bits given)
function make_full_mask(f_bits) {

  if(f_bits == 32)  // -- If we're wanting a bitmask for all bits, we can simply return -1 (which is all bits set to 1)
    return -1;

  return 0x7FFFFFFF >> (31 - f_bits);  // -- What we do here is basically take a value with all bits except the highest set and shift them down as many times as we need to get a mask that fits the bit count we're looking for

}

// -- Function used to generate a bitmask for just the bits required for the value part of a signed range, this means all the bits below the sign bit
function make_sign_mask(f_bits) {

  return make_full_mask(f_bits - 1);

}

// -- Function used to pack a value that has potential for being negative in a way that we use the least number of bits we really need to represent the value
function pack_i(f_val, f_bits) {

  if(f_val < 0)
    return (abs(f_val) & make_sign_mask(f_bits)) | make_sign(f_bits);  // -- Get the positive version of the value and keep the bits that are within range of what we're doing and add the sign bit since we have a negative value and return the result

  return f_val & make_sign_mask(f_bits);  // -- Get the bits that are within our range

}

// -- Function used to unpack (restore) a value that has potential for being negative, essentially reversing what pack_i does above
function unpack_i(f_val, f_bits) {

  if(f_val & make_sign(f_bits))  // -- Check if the stored value is supposed to ve negative
    return 0 - (f_val & make_sign_mask(f_bits));  // -- Retrieve the stored positive value and subtract it from 0 (resulting in the same value except negative), return the result

  return f_val & make_sign_mask(f_bits);  // -- Retrieve the stored positive value and return it

}

// -- Function used to read the value of a SPVAR without any limits
function read_spvar_slot(f_slot) {

  return get_pvar(f_slot, 0x80000000, 0x7FFFFFFF, 0);

}

// -- Function used to save your value in the SPVARs, this is the function you'll be calling when saving a value. You need to provide the value to save aswell as the range (minimum and maximum value, this is how we determine how many bits to use when saving this value)
function save_spvar(f_val, f_min, f_max) {

  pv_bits = get_bit_count2(f_min, f_max);  // -- Set pv_bits to the number of bits we need for this range

  f_val = clamp(f_val, f_min, f_max);  // -- Make sure the value is within our defined range to begin with

  if(is_signed2(f_min, f_max))  // -- If either min or max is negative, we need to pack this value as a possibly negative value
    f_val = pack_i(f_val, pv_bits);  // -- Pack as signed value (possibly negative)

  f_val = f_val & make_full_mask(pv_bits);  // -- Pack as unsigned value (always positive), this essentially just makes the resulting value not have any extra bits set - it's safe to use after the signed packing since we're not using any bits outside of the unsigned range anyways

  if(pv_bits >= 32 - pv_current_bit) {  // -- Check if there is not enough bits remaining to save this value as-is. if there aren't enough bits, we save what we can here and store the remaining bits in the next spvar, if this means we're hitting the end, we can make this smaller by handling the case where we use all bits here aswell
    pv_current_value = pv_current_value | (f_val << pv_current_bit);  // -- Add what we can to the current value where there is bits available to use
    set_pvar(pv_current_slot, pv_current_value);  // -- Save the current SPVAR before advancing to the next one
    pv_current_slot ++;  // -- Move to the next slot
    pv_bits -= (32 - pv_current_bit);  // -- Update the required bits according to our needs for the next slot, if we don't do this here, we'll screw up the saved value by moving it too far out of range
    f_val = f_val >> (32 - pv_current_bit);  // -- Move the remaining bits down, discarding the bits we've already saved
    pv_current_bit = 0;  // -- Reset the current bit counter since we're starting with a new SPVAR
    pv_current_value = 0;  // -- Reset our value so we start clean, we aren't currently using any bits anyways
  }

  pv_current_value = pv_current_value | (f_val << pv_current_bit);  // -- Merge the current SPVAR value with our currently value where there is space to keep our value

  pv_current_bit += pv_bits;  // -- Move up the counter of next available bit to where we are currently saving data at

  if(!pv_current_bit)
    pv_current_value = 0;  // -- Reset our value so we start clean, we aren't currently using any bits anyways

  set_pvar(pv_current_slot, pv_current_value);  // -- Save the SPVAR with the current value, this won't write anything to flash unless the value changed - so we can do this for each variable saved to no risk missing anything

}

// -- Function used to read your value from the SPVARs, this is the function you'll be calling when reading a value. You need to provide the range (minimum and maximum value, this is how we determine how many bits to use when reading the value)
function read_spvar(f_min, f_max) {

  pv_bits = get_bit_count2(f_min, f_max);  // -- Set pv_bits to the number of bits we need for this range
  pv_current_value = (read_spvar_slot(pv_current_slot) >> pv_current_bit) & make_full_mask(pv_bits);  // -- Read the current SPVAR value from flash and shift them into position, we'll handle split values next

  if(pv_bits >= 32 - pv_current_bit) {  // -- Check if we are dealing with a split SPVAR value, essentially if the current position means we're using more than 32 bits in the SPVAR, we need to retrieve the missing bits from the next SPVAR and put them back to our current value, we use the same space saving trick here as in the save function
    pv_current_value = (pv_current_value & make_full_mask(32 - pv_current_bit)) | ((read_spvar_slot(pv_current_slot + 1) & make_full_mask(pv_bits - (32 - pv_current_bit))) << (32 - pv_current_bit));
    // -- Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
    //pv_temp = read_spvar_slot(pv_current_slot + 1);  // -- Read the SPVAR slot coming after the initial one we used to pv_temp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
    //pv_temp = pv_temp & make_full_mask(pv_bits - (32 - pv_current_bit));  // -- Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
    //pv_temp = pv_temp << (32 - pv_current_bit);  // -- Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
    //pv_current_value = (pv_current_value & make_full_mask(32 - pv_current_bit)) | pv_temp;  // -- put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
  }

  pv_current_bit += pv_bits;  // -- Move up the counter of next available bit to where we are will be reading data from next

  pv_current_value = pv_current_value & make_full_mask(pv_bits);  // -- Extract all bits included for this value and discard any other bits

  if(pv_current_bit >= 32) {
    pv_current_slot ++;  // -- Move to the next SPVAR slot
    pv_current_bit -= 32;  // -- Remove 32 from the pv_current_bit tracker since we've gone beyond what we can do here
  }

  if(is_signed2(f_min, f_max))  // -- Check if the value can be negative and handle it accordingly
    pv_current_value = unpack_i(pv_current_value, pv_bits);  // -- Restore the signed, possibly negative value

  if(pv_current_value < f_min || pv_current_value > f_max)  // -- Check if the value is below our specified min or above our specified max, if so - return the min value
    return f_min;

  // -- Return the retrieved value to the user since it's within the expected range
  return pv_current_value;

}
 ú»ˆ±€¶ƒ±†²†ÄòÃôÂ